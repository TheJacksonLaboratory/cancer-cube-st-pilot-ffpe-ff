---
title: "TNBC"
output: html_notebook
---

```{r}
# pacman is a "package manager" that defines the p_load function.
# p_load automatically installs a library if it is not already installed.
# This often, but doesn't always, works.
if(!require("pacman")) {
  install.packages("pacman")
}
suppressPackageStartupMessages(library(pacman)) 
suppressPackageStartupMessages(library(Seurat))
suppressPackageStartupMessages(p_load(ggplot2))
suppressPackageStartupMessages(p_load(edgeR))
suppressPackageStartupMessages(p_load(patchwork))
suppressPackageStartupMessages(p_load(dplyr))
suppressPackageStartupMessages(p_load(plyr))
suppressPackageStartupMessages(p_load(cowplot))
suppressPackageStartupMessages(p_load(reshape2))
# suppressPackageStartupMessages(library(devtools))
# install_github("jokergoo/ComplexHeatmap")
suppressPackageStartupMessages(p_load(ComplexHeatmap))
# devtools::install_github("sjmgarnier/viridisLite")
suppressPackageStartupMessages(library(viridisLite))
suppressPackageStartupMessages(p_load(ggpubr))
suppressPackageStartupMessages(p_load(rstatix))
suppressPackageStartupMessages(p_load(gtools))
suppressPackageStartupMessages(p_load(foreach))
suppressPackageStartupMessages(p_load(parallel))
suppressPackageStartupMessages(p_load(gridExtra))
suppressPackageStartupMessages(p_load(openxlsx))
suppressPackageStartupMessages(p_load(data.table))
suppressPackageStartupMessages(library("gplots"))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(p_load(harmony))

# suppressPackageStartupMessages(p_load(spots))
# install.packages("devtools")
# devtools::install_github("stevexniu/spots")
suppressPackageStartupMessages(library(spots))

suppressPackageStartupMessages(p_load(dplyr))
suppressPackageStartupMessages(p_load(tibble))
suppressPackageStartupMessages(p_load(tidyr))

suppressPackageStartupMessages(p_load(matrixStats))

suppressPackageStartupMessages(p_load(msigdbr))
suppressPackageStartupMessages(p_load(fgsea))

suppressPackageStartupMessages(library(tiff)) 
# Colorblind / colorsafe
# https://stackoverflow.com/questions/57153428/r-plot-color-combinations-that-are-colorblind-accessible
p_load(rcartocolor)
suppressPackageStartupMessages(library(uwot)) # for umap 
suppressPackageStartupMessages(p_load(jsonlite))  

dyn.load("/home/whitebr/local/hdf5-1.14.0/lib/libhdf5_hl.so.310")
suppressPackageStartupMessages(library(hdf5r))
if(!require("spacexr")) {
  devtools::install_github("dmcable/spacexr", build_vignettes = FALSE)
  suppressPackageStartupMessages(p_load(spacexr))
}
```


Setup a parallel execution environment.

```{r}
num.cores <- detectCores()
if(!is.na(num.cores) && (num.cores > 1)) {
  suppressPackageStartupMessages(p_load("doMC"))
  # num.cores <- min(num.cores,6)
  cat(paste("Registering ", num.cores-1, " cores.\n", sep=""))
  registerDoMC(cores=(num.cores-1))
  options(mc.cores=num.cores-1)
}

```

```{r}
url <- "https://raw.githubusercontent.com/TheJacksonLaboratory/cancer-cube-st-pilot-ffpe-ff/main/utils.R"
source(url)
url <- "https://raw.githubusercontent.com/TheJacksonLaboratory/cancer-cube-st-pilot-ffpe-ff/main/plotting-utils.R"
source(url)
```


```{r}
process.catch.init.file <- function(init.file) {
  dataset.info <- read.table(init.file, sep=",", header=TRUE)

  datasets <- dataset.info$names
  spaceranger_dirs <- dataset.info$dataset_names

  names(spaceranger_dirs) <- datasets
  names(datasets) <- datasets

  return(list("info" = dataset.info, "spaceranger_dirs" = spaceranger_dirs, "datasets" = datasets))
  
}

# Create rank-based enrichment scores (using GSEA) for each of the ST dataset in objs
# and the gene sets in gene.sets. 
# Attempts to read pre-existig, saved results in output_dir named
# <output_dir>//mp-gsea-hvg-p0/<sample_name>/mp-gsea-hvg-p0-<sample_name>.rds
create.rank.gsea.matrices <- function(objs, gene.sets, output_dir) {
  
  nms <- names(objs)
  names(nms) <- nms
  
  cross.sample.gsea.res <-
    llply(nms,
        .parallel = FALSE,
        .fun = function(nm) {
          obj <- objs[[nm]]
          nm.dir <- paste0(output_dir, "/mp-gsea-hvg-p0/", nm)
          dir.create(nm.dir, recursive=TRUE)

          rds.file <- paste0(nm.dir, "/", "mp-gsea-hvg-p0-", nm, ".rds")
          if(!file.exists(rds.file)) {
            cat(paste0(nm, ": computing results (", rds.file, ")\n"))
            mat <- GetAssayData(obj, assay="Spatial", slot="counts")
            # Calculate the rank matrix based on the raw counts
            rank.mat <- t(sparseMatrixStats::colRanks(mat, ties.method = 'average'))
            rownames(rank.mat) <- rownames(mat)
            colnames(rank.mat) <- colnames(mat)

            cols <- colnames(rank.mat)
            names(cols) <- cols
          
            # Calculate GSEA based on the ranks
            all.gsea.res <-
              llply(cols,
                    .fun = function(col) {
                      ranks <- rank.mat[,col]
                      # fgsea sorts stats (not their abs value) in descending order
                      # i.e., stats = sort(stats, decreasing=TRUE)
                      fgseaRes <- suppressWarnings(fgsea(gene.sets, stats = ranks, nperm = 1000, scoreType = "pos", gseaParam = 0))
                    })
            saveRDS(all.gsea.res, file = rds.file)
          } else {
            cat(paste0(nm, ": results exist (", rds.file, ")\n"))
          }
          readRDS(rds.file)
                    
        })

}

# Format sample-specific, rank-based enrichment scores output by create.rank.gsea.matrices
# into sample-specific matrices with rows samples, columns gene set, and entries either 
# the score (for "gsea.mats" output) or the p-value of that score (for "gsea.pval.mats")
format.gsea.results <- function(sample.level.gsea.mats) {
  gsea.mats <-
    llply(sample.level.gsea.mats,
          .fun = function(gsea.res) {
            gsea.df <- ldply(gsea.res, .fun = function(elem) elem[, c("pathway", "pval", "padj", "ES", "NES")])
            gsea.mat <- reshape2::dcast(data = gsea.df, formula=.id ~ pathway, value.var="NES")
            rownames(gsea.mat) <- gsea.mat$.id
            gsea.mat <- gsea.mat[,!(colnames(gsea.mat) %in% c(".id"))]
            gsea.mat
          })

  gsea.pval.mats <-
    llply(sample.level.gsea.mats,
          .fun = function(gsea.res) {
            gsea.df <- ldply(gsea.res, .fun = function(elem) elem[, c("pathway", "pval", "padj", "ES", "NES")])
            gsea.mat <- reshape2::dcast(data = gsea.df, formula=.id ~ pathway, value.var="pval")
            rownames(gsea.mat) <- gsea.mat$.id
            gsea.mat <- gsea.mat[,!(colnames(gsea.mat) %in% c(".id"))]
            gsea.mat
        })

  common.pathways <- Reduce(intersect, lapply(gsea.mats, function(mat) colnames(mat)))

  gsea.mats <- llply(gsea.mats, .fun = function(mat) mat[, common.pathways])
  gsea.mats <- llply(gsea.mats, .fun = function(mat) na.omit(mat))

  gsea.pval.mats <- llply(gsea.pval.mats, .fun = function(mat) mat[, common.pathways])
  gsea.pval.mats <- llply(gsea.pval.mats, .fun = function(mat) na.omit(mat))
  
  return(list("gsea.mats" = gsea.mats, "gsea.pval.mats" = gsea.pval.mats))
}

combine.gsea.mats <- function(mats) {
  samples <- names(mats)
  names(samples) <- samples
  all.mat <- ldply(samples, .fun = function(sm) cbind(spot = rownames(mats[[sm]]), mats[[sm]]))
  colnames(all.mat)[1] <- "orig.ident"
  all.mat
}


process.rank.gsea.matrices_ <- function(init.info, gene.sets, output_dir) {

  cat("Creating Seurat objects\n")
  filtered.objs <- create.visium.seurat.objects(init.info$spaceranger_dirs, filter.spots = TRUE)
  
  cat("Creating GSEA rank matrices\n")
  sample.level.gsea.mats <- create.rank.gsea.matrices(filtered.objs, gene.sets, output_dir) 
  
  cat("Formatting GSEA rank matrices\n")
  formatted.gsea.mats <- format.gsea.results(sample.level.gsea.mats)
  
  cat("Combining GSEA matrices")
  all.gsea.mat <- combine.gsea.mats(formatted.gsea.mats$gsea.mats)
  
  all.gsea.mat
}

process.rank.gsea.matrices <- function(init.file, gene.sets, output_dir) {

  init.info <- process.catch.init.file(init.file)
  
  process.rank.gsea.matrices_(init.info, gene.sets, output_dir)
}
```


```{r}
# Assemble all of the metadata files listing the various ST datasets in human and mouse
root.dir <- "/projects/activities/jaxcc/CATch-project/raw-data/visium/analysis_dir/"
analysis.root.dir <- "./"
human.init.files <-
  list("Osteosarcoma" = paste0(root.dir,"Osteosarcoma/Osteosarcoma.csv"),
       "Brain" = paste0(root.dir, "Brain/gbm.csv"),
       "Endometrium" = paste0(root.dir, "Endometrium/Endometrium.csv"),
       "Peritoneum" = paste0(root.dir, "Peritoneum/peritoneum.csv"))

# Just use Breast_2, which are Ed/Francesca data
mouse.init.files <-
  list(
       #"Breast_1" = paste0(root.dir, "Breast_1/breastcancer.csv"),
       "Breast_2" = paste0(root.dir, "Breast_2/breast_2.csv")
       #"Colon" = paste0(root.dir, "Colon/Colon.csv"),
       #"Lung_1" = paste0(root.dir, "Lung_1/lungcancer.csv"),
       #"Lung_2" = paste0(root.dir, "Lung_2/lungcancer_2.csv"),
       #"Orthotropic_melanoma" = paste0(root.dir, "Orthotropic_melanoma/Orthotropic_melanoma.csv"),
       #"Pdac" = paste0(root.dir, "Pdac/pdac.csv")
       )

all.init.files <- c(human.init.files, mouse.init.files)

output_base_dir <- '/projects/compsci/jgeorge/whitebr/cancer-cube/pan-catch-mp-rank-gsea/'
dir.create(output_base_dir, recursive=TRUE)

analysis_dir <- paste0(output_base_dir, '/analysis/')
plots_dir <- paste0(output_base_dir, '/plots/')
dir.create(plots_dir, showWarnings = FALSE, recursive = TRUE)

spaceranger_dirs <- llply(mouse.init.files, function(init.file) process.catch.init.file(init.file)$spaceranger_dirs)
spaceranger_dirs <- Reduce(c,  spaceranger_dirs)
mouse_spaceranger_dirs <- spaceranger_dirs
```

```{r}
define.tnbc.metadata <- function() {
  # Original data
  orig.datasets <- c("SC2200259_9990", "SC2200260_9990", "SC2200261_7031", "SC2200262_7031", "SC2200263_4700", "SC2200264_4700", "SC2200265_2171", "SC2200266_2171")
  use.spaceranger.2.0.0.results <- TRUE
  orig_base_dir <- '/projects/compsci/jgeorge/whitebr/tnbc/'
  analysis_base_dir <- '/projects/compsci/jgeorge/whitebr/tnbc/'
  if(use.spaceranger.2.0.0.results) {
    orig_base_dir <- '/projects/activities/jaxcc/CATch-project/raw-data/visium/tnbc/orig-data-spaceranger-2.0.0/22-scbct-023/'
    analysis_base_dir <- '/projects/compsci/jgeorge/whitebr/tnbc-spaceranger-2.0.0/'
  }
  
  # New data, including some overlapping samples
  new.datasets <- c("SC2300228_JP9990", "SC2300228_JP9990-reseq", "SC2300229_JP1127", "SC2300230_JP1330A", "SC2300231_JP1863B", "SC2300231_JP1863B-reseq", "SC2300232_JP6970", "SC2300233_JP6110", "SC2300234_JP4401B", "SC2300235_JP4700", "SC2300235_JP4700-reseq")
  new_base_dir <- '/projects/chuang-lab/USERS/whitebr/tnbc/tnbc-050223/'
  
  spaceranger_dirs <- paste0(orig_base_dir, orig.datasets, "/spaceranger/")
  spaceranger_dirs <- c(spaceranger_dirs, paste0(new_base_dir, new.datasets, "/spaceranger/"))
  datasets <- c(orig.datasets, new.datasets)
  
  # datasets <- datasets[1:5]
  # spaceranger_dirs <- spaceranger_dirs[1:5]
  #names(spaceranger_dirs) <- datasets
  #names(datasets) <- datasets
  

  spaceranger_version <-
    unlist(lapply(spaceranger_dirs,
                  function(spaceranger_dir) fromJSON(paste0(spaceranger_dir, "summary.json"))$cellranger_version))
  
  info.df <- data.frame(names = datasets, labels = "Frozen", species = "Human", spaceranger_dirs = spaceranger_dirs, spaceranger = spaceranger_version)

  names(datasets) <- datasets
  
  # Extract the sample name from the datasets (i.e., foo_<sample>)
  patient <- unlist(lapply(datasets, function(str) unlist(strsplit(str, split="_"))[2]))
  sample <- unlist(lapply(datasets, function(str) unlist(strsplit(str, split="_"))[1]))
  
  patient.df <- as.data.frame(patient)
  patient.df$sample <- rownames(patient.df)
  patient.df$short.sample <- sample
  patient.df$label <- "Batch 1"
  flag <- grepl(patient.df$sample, pattern="JP")
  patient.df[flag,"label"] <- "Batch 2"
  flag <- grepl(patient.df$sample, pattern="reseq")
  patient.df[flag,"label"] <- "Batch 2-reseq"
  patient.df$patient <- gsub(patient.df$patient, pattern="-reseq", replacement="")
  patient.df$patient <- gsub(patient.df$patient, pattern="JP", replacement="")
  rownames(patient.df) <- patient.df$sample
  
  info.df <- merge(info.df, patient.df[, c("sample", "patient")], by.x = c("names"), by.y = c("sample"))
  colnames(info.df)[colnames(info.df) == "patient"] <- "biological_replicate"
  

  samples.by.patient <- dlply(patient.df, .variables = c("patient"), .fun = function(df) df$sample)
  
  # This comes from SCBL_Data-Release_20230320-KP.xlsx (sent by Bill on 3/20/23),
  # SCBL-Release_20220601_JC.xlsx (sent by Bill on 6/1/22)
  batch2.xls <- paste0(analysis.root.dir, "/scbl-releases/", "SCBL_Data-Release_20230320-KP.xlsx")
  batch2.df <- read.xlsx(batch2.xls, sheet=1)
  batch2.df$treated <- "Untreated"
  batch1.xls <- paste0(analysis.root.dir, "/scbl-releases/","SCBL-Release_20220601_JC.xlsx")
  batch1.df <- read.xlsx(batch1.xls, sheet=1)
  batch1.df$treated <- "Treated"
  # I assume that the batch2 reseq were all done in the same lane. Fake this since I haven't received
  # an xls sheet from Bill yet.
  batch2.reseq.df <- data.frame(Output.ID = grep(rownames(patient.df), pattern="reseq", value=TRUE),
                                Flow.Cell = "dummy", Lane.on.FlowCell = "dummy")
  batch2.reseq.df$treated <- "Untreated"
  batch.df <- rbind(batch1.df[,c("Output.ID", "Flow.Cell", "Lane.on.FlowCell", "treated")], 
                    batch2.df[,c("Output.ID", "Flow.Cell", "Lane.on.FlowCell", "treated")],
                    batch2.reseq.df[,c("Output.ID", "Flow.Cell", "Lane.on.FlowCell", "treated")])
  patient.df <- merge(patient.df, batch.df, by.x=c("sample"), by.y = c("Output.ID"))
  # Some of the samples in batches 2 and 2-reseq are actually treated
  patient.df[patient.df$patient %in% subset(patient.df, treated == "Treated")$patient, "treated"] <- "Treated"
  patient.df$batch.var <- paste(patient.df$label, patient.df$Flow.Cell, patient.df$Lane.on.FlowCell, sep="-")
  patient.df <- patient.df[order(patient.df$patient, patient.df$label, decreasing=FALSE),]
  rownames(patient.df) <- patient.df$sample
  
  tmp <- patient.df
  tmp$label <- factor(tmp$label, levels=c("Batch 2", "Batch 2-reseq", "Batch 1"))
  tmp <- tmp[order(tmp$label),]
  # Select one sample per patient, favoring batch 2
  one.sample.per.patient.batch.2.bias.df <- tmp[!duplicated(tmp$patient),]
  
  tmp <- patient.df
  tmp$label <- factor(tmp$label, levels=c("Batch 1", "Batch 2", "Batch 2-reseq"))
  tmp <- tmp[order(tmp$label),]
  # Select one sample per patient, favoring batch 2
  one.sample.per.patient.batch.1.bias.df <- tmp[!duplicated(tmp$patient),]
  
  return(list("info.df" = info.df, "patient.df" = patient.df,
              "one.sample.per.patient.batch.2.bias.df" = one.sample.per.patient.batch.2.bias.df,
              "one.sample.per.patient.batch.1.bias.df" = one.sample.per.patient.batch.1.bias.df))
}

```


```{r}
shannon.entropy <- function(p) {
  p.norm <- p[p>0]/sum(p)
	-sum(log2(p.norm)*p.norm)
}

plot.cluster.fraction.by.annotation <- function(cluster.label, annotation.label, cols = NULL, num.spots.y.lab = paste0("# Spots")) {
  tbl <- reshape2::dcast(as.data.frame(table(annotation.label, cluster.label)), formula=annotation.label~cluster.label, value.var="Freq")
  rownames(tbl) <- tbl$annotation.label
  tbl <- tbl[,!(colnames(tbl) %in% c("annotation.label"))]
  tbl$All <- rowSums(tbl)
  per.tbl <- t(apply(tbl, 1, function(row) row / colSums(tbl)))

  tmp <- reshape2::melt(per.tbl)
  colnames(tmp) <- c("Var1", "cluster", "fraction")
  tmp$Var1 <- factor(tmp$Var1)
  tmp$cluster <- as.character(tmp$cluster)
  tmp$cluster <- factor(tmp$cluster, levels = c("All", sort(as.numeric(unique(tmp$cluster)[unique(tmp$cluster) != "All"]))))
  
  
  
  entropies <- apply(per.tbl, 2, function(freqs) shannon.entropy(freqs))
  entropy.df <- data.frame(cluster = names(entropies), entropy = as.numeric(entropies))
  entropy.df$cluster <- factor(entropy.df$cluster, levels = levels(tmp$cluster))

  size.df <- data.frame(cluster = colnames(tbl), size = as.numeric(colSums(tbl)))
  size.df$cluster <- factor(size.df$cluster, levels = levels(tmp$cluster))
  
  # Plot bar plot of fraction of cluster belonging to each annotation (Var1)
  g <- ggplot(data = tmp, aes(x = cluster, y = fraction, fill = Var1)) + geom_col()
  sub <- subset(tmp, cluster=="All")
  sub <- sub[order(sub$Var1, decreasing=TRUE),]
  # For comparison (against null hypothesis that clusters are spread across annotation),
  # make a horizontal line for the fraction of total comprised by each annotation
  for(frac in cumsum(sub$fraction)) {
    g <- g + geom_hline(yintercept = frac, linetype=2)
  }

  text.sz <- 30
  g <- g + ylab("Fraction of Cluster") + xlab("Cluster") + labs(fill = NULL)
  g <- g + theme(text = element_text(size=text.sz),
                 legend.text = element_text(size=text.sz),
                 axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size=text.sz))
  if(!is.null(cols)) {
    g <- g + scale_fill_manual(values = cols)
  }

  g.ent <- ggplot(data = entropy.df, aes(x = cluster, y = entropy)) + geom_col() +
    ylab("H") +
    theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          axis.title.x = element_blank(), text = element_text(size = text.sz))

  g.size <- ggplot(data = size.df, aes(x = cluster, y = size)) + geom_col() +
    ylab(num.spots.y.lab) +
    theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          axis.title.x = element_blank(), text = element_text(size = text.sz)) +
    scale_y_continuous(trans='log2') +
    coord_cartesian(clip = 'off') 

  
  g.tot <- plot_grid(
    plot_grid(g.ent, g.size, g + theme(legend.position = "none"), ncol=1, align="v", rel_heights=c(1,1,9)),
    plot_grid(NULL, NULL, get_legend(g), ncol=1, rel_heights=c(2.5,2.5,9)), 
    rel_widths=c(7,3))

  g.tot
}
```

```{r}
make.cluster.plots <- function(cluster.label, sample.label, treatment.label) {
  
  samples <- unique(sort(sample.label))
  sample_cols = carto_pal(length(samples), "Safe")
  names(sample_cols) <- names(samples)
  treated_cols <- c("Treated" = "blue", "Untreated" = "black")

  anno.df <- data.frame(cluster = cluster.label, sample = sample.label, treatment = treatment.label)
  g.all.samples <- plot.cluster.fraction.by.annotation(anno.df$cluster, anno.df$sample, cols=sample_cols)

  sub.anno.df <- subset(anno.df, treatment == "Treated")
  g.treated.samples <- plot.cluster.fraction.by.annotation(sub.anno.df$cluster, sub.anno.df$sample, cols=sample_cols, num.spots.y.lab = paste0("#\nSpots"))

  sub.anno.df <- subset(anno.df, treatment == "Untreated")
  g.untreated.samples <- plot.cluster.fraction.by.annotation(sub.anno.df$cluster, sub.anno.df$sample, cols=sample_cols, num.spots.y.lab = paste0("#\nSpots"))

  g.treatment <- plot.cluster.fraction.by.annotation(anno.df$cluster, anno.df$treatment, cols=treated_cols)

  if(FALSE) {
  g1 <- plot_grid(g.treatment, plot_grid(g.treated.samples, g.untreated.samples,ncol=1,labels=c("B","C")),ncol=2,labels=c("A",""))
  g2 <- plot_grid(g.all.samples, plot_grid(g.treated.samples, g.untreated.samples,ncol=1,labels=c("B","C")),ncol=2,labels=c("A",""))
  g3 <- plot_grid(g.all.samples, plot_grid(g.treated.samples, g.untreated.samples,ncol=1,labels=c("B","C")),g.treatment, ncol=3, labels=c("A","","D"))
  }
  g1 <- plot_grid(g.treatment, plot_grid(g.treated.samples, g.untreated.samples,ncol=1),ncol=2)
  g2 <- plot_grid(g.all.samples, plot_grid(g.treated.samples, g.untreated.samples,ncol=1),ncol=2)
  g3 <- plot_grid(g.all.samples, plot_grid(g.treated.samples, g.untreated.samples,ncol=1),g.treatment, ncol=3)
  g4 <- plot_grid(g.all.samples, g.treatment,nrow=1)
  
  return(list("treat" = g1, "samples" = g2, "treat.and.samples" = g3, "all.samples.and.treat" = g4))
}
```

```{r}
plot.cluster.with.hne <- function(seurat.objs, anno.df, cluster.num, sample.col = "orig.ident", spot.col = "spot", cluster.col = "cluster") {

  nms <- names(seurat.objs)
  names(nms) <- nms
  plts <- 
    llply(nms,
          .fun = function(sm) {
            obj <- seurat.objs[[sm]]
            tmp <- anno.df[anno.df[, sample.col] == sm, ]
            rownames(tmp) <- tmp[, spot.col]
            tmp <- tmp[, cluster.col, drop=FALSE]
            obj <- add.metadata.to.seurat.obj(obj, tmp)
            Idents(obj) <- cluster.col
            # if(!any(Idents(obj) %in% cluster.num)) { return(NULL) }
            g1 <- plot.hne(obj)
            colors <- c("cluster" = "yellow", "Unselected" = "black")
            names(colors)[1] <- cluster.num
            cells.to.highlight <- "dummy"
            if(any(Idents(obj) %in% cluster.num)) { 
              cells.to.highlight <- CellsByIdentities(object = obj, ident=cluster.num)
            }
            g2 <- SpatialDimPlot(obj, cells.highlight = cells.to.highlight) + scale_fill_manual(values= colors) 
            g2 <- g2 + labs(fill = "Cluster")
            g2 <- g2 + theme(text = element_text(size=20), legend.title=element_text(size = 20), legend.text=element_text(size=20), legend.direction="horizontal")
            g2 <- g2 + scale_fill_manual(values = c("yellow", "black"),
                                         breaks=c(cluster.num, "Unselected"),
                                         labels=c(cluster.num, "Other"))
            g2 <- g2 + guides(fill = guide_legend(override.aes = list(size=8)))
            g <- plot_grid(g1, g2 + theme(legend.position = "none"), ncol = 1, align = "v")
            # plot_grid(g1, g2 + theme(legend.position = "none"), ncol = 1, align = "v")
            g <- add.title.to.plot(g, sm, rel_heights = c(0.1,1), size=20)
            list("g" = g, "leg" = get_legend(g2))
          })
  plts <- plts[unlist(lapply(plts, function(p) !is.null(p)))]
  gs <- llply(plts, .fun = function(lst) lst$g)
  leg <- plts[[1]]$leg
  g <- plot_grid(plotlist=gs)
  plot_grid(g, leg, nrow=2, rel_heights=c(1,0.05))

}
```

```{r}
info.tbl <- ldply(all.init.files, function(init.file) process.catch.init.file(init.file)$info)
colnames(info.tbl)[1] <- "project"
info.tbl$spaceranger <-
  unlist(lapply(info.tbl$dataset_names,
         function(spaceranger_dir) fromJSON(paste0(spaceranger_dir, "summary.json"))$cellranger_version))
info.tbl <- info.tbl[, c("project", "names", "labels", "species", "biological_replicate", "spaceranger")]
```


```{r}
# Read in the meta programs to be used as gene sets
# Do gene set enrichment analysis against the hallmark gene sets from msigdb
human_hallmarks_df <- msigdbr(species = "Homo sapiens", category = "H")
human_hallmark_fgsea_sets <- human_hallmarks_df %>% split(x = .$gene_symbol, f = .$gs_name)

library(MCPcounter)
human.mcp.genes <- read.table(curl("http://raw.githubusercontent.com/ebecht/MCPcounter/master/Signatures/genes.txt"),sep="\t",stringsAsFactors=FALSE,header=TRUE,colClasses="character",check.names=FALSE)

colnames(human.mcp.genes) <- c("Hugo symbols", "pop", "ENTREZID", "ENSEMBL ID")
human.mcp.sets <- dlply(human.mcp.genes, .variables = c("pop"), .fun = function(df) df$`Hugo symbols`)

human.hallmark.mcp.sets <- c(human_hallmark_fgsea_sets, human.mcp.sets)

if(!require("mMCPcounter")) {
  p_load(devtools)
  devtools::install_github("cit-bioinfo/mMCP-counter")
}
library("mMCPcounter")

data("mMCPcounter_signatures_GCRm39", envir = sys.frame(sys.nframe()), 
            package = "mMCPcounter")
mouse.mcp.genes <- mMCPcounter_signatures_GCRm39
mouse.mcp.sets <- dlply(mouse.mcp.genes, .variables = c("Denomination"), .fun = function(df) df$Gene.Symbol)

mouse_hallmarks_df <- msigdbr(species = "Mus musculus", category = "H")
mouse_hallmark_fgsea_sets <- mouse_hallmarks_df %>% split(x = .$gene_symbol, f = .$gs_name)

mouse.hallmark.mcp.sets <- c(mouse_hallmark_fgsea_sets, mouse.mcp.sets)

# Read in the cancer metaprograms from Gavish et al.
cancer.mps <- read.xlsx(paste0(analysis.root.dir, "/external-data/","41586_2023_6130_MOESM6_ESM.xlsx"), sheet=1)
cancer.mps <- as.list(cancer.mps)

human.hallmark.gene.set.len <- ldply(human_hallmark_fgsea_sets, length)
colnames(human.hallmark.gene.set.len) <- c("geneset", "human.length")

mouse.hallmark.gene.set.len <- ldply(mouse_hallmark_fgsea_sets, length)
colnames(mouse.hallmark.gene.set.len) <- c("geneset", "mouse.length")

hallmark.gene.set.len <- merge(human.hallmark.gene.set.len, mouse.hallmark.gene.set.len)

# Number of genes in human and mouse are strongly correlated / nearly identical
# plot(hallmark.gene.set.len$human.length, hallmark.gene.set.len$mouse.length)

# Read in the immune / stromal metaprograms from Gavish et al.
cell.types <- c("B_cells", "Endothelial", "Epithelial", "Fibroblasts", "Macrophages", "CD4", "CD8")
names(cell.types) <- cell.types
cell.type.mps <-
  llply(cell.types,
        .fun = function(ct) {
          #This is Supp Table 10 of Gavish
          lst <- read.xlsx(paste0(analysis.root.dir, "/external-data/","41586_2023_6130_MOESM14_ESM.xlsx"), sheet=ct)
          names(lst) <- paste0(ct, ".", names(lst))
          lst
        })
all.cell.type.mps <- Reduce(c, cell.type.mps)

all.mps <- c(cancer.mps, all.cell.type.mps)
```


```{r}

output_base_dir <- '/projects/compsci/jgeorge/whitebr/cancer-cube/pan-catch-human-mp-rank-gsea/'
dir.create(output_base_dir, recursive=TRUE)

analysis_dir <- paste0(output_base_dir, '/analysis/')



```


```{r}
output_base_dir <- '/projects/compsci/jgeorge/whitebr/cancer-cube/pan-catch-mouse-hallmark-mcp-rank-gsea/'
dir.create(output_base_dir, recursive=TRUE)

analysis_dir <- paste0(output_base_dir, '/analysis/')
plots_dir <- paste0(output_base_dir, '/plots/')
dir.create(plots_dir, recursive=TRUE)
mouse_hallmark_plots_dir <- plots_dir

projects <- names(mouse.init.files)
names(projects) <- projects

mouse.hallmark.mcp.gsea.mats <-
  llply(projects,
        .parallel = FALSE,
        .fun = function(project) {
          print(project)
          output_dir <- paste0(analysis_dir, "/", project)
          print(output_dir)
          suppressWarnings(process.rank.gsea.matrices(mouse.init.files[[project]], mouse.hallmark.mcp.sets, output_dir))
        })

```

```{r}
output_base_dir <- '/projects/compsci/jgeorge/whitebr/cancer-cube/pan-catch-human-hallmark-mcp-rank-gsea/'
dir.create(output_base_dir, recursive=TRUE)

analysis_dir <- paste0(output_base_dir, '/analysis/')



human.hallmark.mcp.gsea.mats <- list()
project <- "tnbc"
output_dir <- paste0(analysis_dir, "/", project)
tnbc.metadata <- define.tnbc.metadata()
dirs <- tnbc.metadata$info.df$spaceranger_dirs
names(dirs) <- tnbc.metadata$info.df$names
tnbc.init.info <- list(spaceranger_dirs = dirs)
human.hallmark.mcp.gsea.mats[["TNBC"]] <- suppressWarnings(process.rank.gsea.matrices_(tnbc.init.info, human.hallmark.mcp.sets, output_dir))
```

```{r}
combined.mouse.hallmark.mcp.gsea <- ldply(mouse.hallmark.mcp.gsea.mats)
colnames(combined.mouse.hallmark.mcp.gsea)[1] <- "project"
umap.mouse.hallmark.mcp.gsea <- umap(subset(combined.mouse.hallmark.mcp.gsea, select=-c(project, orig.ident, spot)), scale=TRUE)
mouse.hallmark.mcp.gsea.df <- data.frame(umap1 = umap.mouse.hallmark.mcp.gsea[,1], umap2 = umap.mouse.hallmark.mcp.gsea[,2], project = combined.mouse.hallmark.mcp.gsea$project, sample = combined.mouse.hallmark.mcp.gsea$orig.ident)
```

```{r}
combined.human.hallmark.mcp.gsea <- ldply(human.hallmark.mcp.gsea.mats)
colnames(combined.human.hallmark.mcp.gsea)[1] <- "project"
umap.human.hallmark.mcp.gsea <- umap(subset(combined.human.hallmark.mcp.gsea, select=-c(project, orig.ident, spot)), scale=TRUE)
human.hallmark.mcp.gsea.df <- data.frame(umap1 = umap.human.hallmark.mcp.gsea[,1], umap2 = umap.human.hallmark.mcp.gsea[,2], project = combined.human.hallmark.mcp.gsea$project, sample = combined.human.hallmark.mcp.gsea$orig.ident)
g <- ggplot(data = human.hallmark.mcp.gsea.df, aes(x = umap1, y = umap2, colour = sample)) + geom_point()
g <- ggplot(data = human.hallmark.mcp.gsea.df, aes(x = umap1, y = umap2, colour = project)) + geom_point()
```

```{r}
human.mouse.common.cols <- intersect(colnames(combined.mouse.hallmark.mcp.gsea),
                                     colnames(combined.human.hallmark.mcp.gsea))
```


```{r}
mt <- subset(combined.human.hallmark.mcp.gsea, project %in% c("Osteosarcoma"))
mt <- subset(combined.human.mp.gsea, project %in% c("Osteosarcoma"))
# mt <- combined.human.mp.gsea
sds <- apply(subset(mt, select=-c(project, orig.ident, spot)), 2, sd)
hvfs <- names(sds[order(sds,decreasing=TRUE)])[1:25]
mt <- merge(mt, info.tbl, by.x = c("project", "orig.ident"), by.y = c("project", "names"))

projects <- unique(mt$orig.ident)
project_cols <- carto_pal(length(projects), "Safe")
names(project_cols) <- projects
project_labels <- mt$orig.ident

samples <- unique(mt$orig.ident)
sample_cols <- carto_pal(length(samples), "Safe")
names(sample_cols) <- samples
sample_labels <- mt$orig.ident

mt <- subset(mt, select=-c(project, orig.ident, spot))
mt <- mt[,hvfs]
mt <- as.matrix(mt)
rownames(mt) <- NULL
sz <- 16

file <- paste0(plots_dir, "/", "osteo-mp-gsea-heatmap", ".tiff")

set.seed(1)
tiff(file, width = 3 * 480, height = 2 * 480)

hm <- Heatmap(mt, name="Meta Program\nNES", use_raster=TRUE, raster_device="tiff",
              raster_by_magick = FALSE, raster_resize_mat = TRUE, column_names_rot = 45,
              column_names_gp = gpar(fontsize = sz), column_title_gp = gpar(fontsize = sz),
              row_title_gp = gpar(fontsize = sz), column_names_max_height = unit(8, "cm"),
              heatmap_legend_param = list(title_gp = gpar(fontsize = sz), 
                                          labels_gp = gpar(fontsize = sz)), 
              cluster_rows=TRUE, cluster_columns=TRUE, row_km = 6, column_km = 6)

#hm <- hm + rowAnnotation(project = project_labels, col = list(project = project_cols), annotation_legend_param = list(project = list(title_gp = gpar(fontsize = sz), labels_gp = gpar(fontsize = sz))))
hm <- hm + rowAnnotation(sample = sample_labels, col = list(sample = sample_cols),
                         annotation_name_gp= gpar(fontsize = sz),
                         annotation_legend_param = 
                           list(sample = list(title_gp = gpar(fontsize = sz), 
                                              labels_gp = gpar(fontsize = sz))))
hm <- draw(hm)
row_clustering <- row_order(hm)

d <- dev.off()
```

```{r}
mt <- subset(combined.human.mp.gsea, project %in% c("Osteosarcoma", "Brain"))
# mt <- combined.human.mp.gsea
sds <- apply(subset(mt, select=-c(project, orig.ident, spot)), 2, sd)
hvfs <- names(sds[order(sds,decreasing=TRUE)])[1:25]
mt <- merge(mt, info.tbl, by.x = c("project", "orig.ident"), by.y = c("project", "names"))

datasets <- unique(mt$project)
if(length(datasets) == 2) {
  dataset_cols <- c("blue", "black")
} else {
  dataset_cols <- carto_pal(length(datasets), "Safe")
}
names(dataset_cols) <- datasets
dataset_labels <- mt$project

samples <- unique(mt$orig.ident)
sample_cols <- carto_pal(length(samples), "Safe")
names(sample_cols) <- samples
sample_labels <- mt$orig.ident

mt <- subset(mt, select=-c(project, orig.ident, spot))
mt <- mt[,hvfs]
mt <- as.matrix(mt)
rownames(mt) <- NULL
sz <- 16

file <- paste0(plots_dir, "/", "osteo-brain-mp-gsea-heatmap", ".tiff")

set.seed(1)
tiff(file, width = 3 * 480, height = 2 * 480)


hm <- Heatmap(mt, name="Meta Program\nNES", use_raster=TRUE, raster_device="tiff",
              raster_by_magick = FALSE, raster_resize_mat = TRUE, column_names_rot = 45,
              column_names_gp = gpar(fontsize = sz), column_title_gp = gpar(fontsize = sz),
              row_title_gp = gpar(fontsize = sz), column_names_max_height = unit(8, "cm"),
              heatmap_legend_param = list(title_gp = gpar(fontsize = sz), 
                                          labels_gp = gpar(fontsize = sz)), 
              cluster_rows=TRUE, cluster_columns=TRUE, row_km = 6, column_km = 6)

#hm <- hm + rowAnnotation(project = project_labels, col = list(project = project_cols), annotation_legend_param = list(project = list(title_gp = gpar(fontsize = sz), labels_gp = gpar(fontsize = sz))))
#hm <- hm + rowAnnotation(sample = sample_labels, col = list(sample = sample_cols), annotation_legend_param = list(sample = list(title_gp = gpar(fontsize = sz), labels_gp = gpar(fontsize = sz))))
hm <- hm + rowAnnotation(sample = sample_labels, dataset = dataset_labels, 
                         col = list(sample = sample_cols, dataset = dataset_cols),
                         annotation_name_gp= gpar(fontsize = sz),
                         annotation_legend_param = 
                           list(sample = list(title_gp = gpar(fontsize = sz), 
                                              labels_gp = gpar(fontsize = sz)),
                                dataset = list(title_gp = gpar(fontsize = sz),
                                               labels_gp = gpar(fontsize = sz))))
hm <- draw(hm)
row_clustering <- row_order(hm)
d <- dev.off()
```

```{r}
stop("stop")
```

```{r}
mt <- rbind(subset(combined.mouse.hallmark.mcp.gsea, project %in% c("Breast_1", "Breast_2"))[, human.mouse.common.cols],
            subset(combined.human.hallmark.mcp.gsea, project %in% c("TNBC"))[, human.mouse.common.cols])
info.tbl.subset <- info.tbl
info.tbl.subset <- subset(info.tbl.subset, (project %in% c("Breast_1", "Breast_2")))
info.tbl.subset <- subset(info.tbl.subset, labels == "Frozen")
info.tbl.subset <- subset(info.tbl.subset, species == "Mouse")
# Only keep one sample per mouse
#info.tbl.subset <- info.tbl.subset[!duplicated(info.tbl.subset$biological_replicate),]

orig.idents <- c(info.tbl.subset$names, tnbc.metadata$one.sample.per.patient.batch.2.bias.df$sample)

mt <- subset(mt, orig.ident %in% orig.idents)
mt[mt$project == "TNBC","project"] <- "Human"
mt[mt$project == "Breast_2","project"] <- "Mouse"
mt.orig <- mt
mt.melted <- reshape2::melt(subset(mt, select = -c(project, spot)), id = "orig.ident")
g <- ggplot(data = mt.melted, aes(x = orig.ident, y = value)) + facet_wrap(~ variable) + geom_boxplot()

mouse.ids <- c("B1P-821MGT", "B1P-802MGT", "B1P-935MG", "B1P-936MG")

#mt.melted$variable <- gsub(mt.melted$variable, pattern="HALLMARK_", replacement="")
#mt.melted$variable <- gsub(mt.melted$variable, pattern="_", replacement=" ")

# Calculate coefficient of variation for each sample (and variable),
# then calculate mean CV across samples.
# Calculate in human TNBC samples
mt.human.melted <- subset(mt.melted, !(orig.ident %in% mouse.ids))
cvs <-
  ddply(mt.human.melted, .variables = c("orig.ident", "variable"),
        .fun = function(df) {
          data.frame(cv = sd(df$value)/mean(df$value))
        })

mean.cvs <-
  ddply(cvs, .variables = c("variable"),
        .fun = function(df) {
          data.frame(mean.cv = mean(df$cv))
        })
mean.cvs <- mean.cvs[order(mean.cvs$mean.cv, decreasing=TRUE),]





sds <- apply(subset(mt, select=-c(project, orig.ident, spot)), 2, sd)
means <- apply(subset(mt, select=-c(project, orig.ident, spot)), 2, mean)
hvfs.across.all.samples <- names(sort(sds/means, decreasing=TRUE))[1:25]

sds <- apply(subset(subset(mt, project=="TNBC"), select=-c(project, orig.ident, spot)), 2, sd)
means <- apply(subset(subset(mt, project=="TNBC"), select=-c(project, orig.ident, spot)), 2, mean)
sds <- sds[grepl(names(sds), pattern="HALLMARK")]
means <- means[grepl(names(means), pattern="HALLMARK")]
tnbc.hvfs <- names(sort(sds/means, decreasing=TRUE))[1:25]
# tnbc.hvfs <- names(sds)

tnbc.hvfs <- as.character(mean.cvs[order(mean.cvs$mean.cv, decreasing=TRUE),"variable"][1:20])

g.high.var <- ggplot(data = subset(mt.melted, orig.ident %in% mouse.ids & variable %in% head(mean.cvs$variable,n=10)), aes(x = orig.ident, y = value)) + facet_wrap(~ variable, scale="free_y", labeller = label_wrap_gen(width = 2, multi_line = TRUE)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

g.low.var <- ggplot(data = subset(mt.melted, orig.ident %in% mouse.ids & variable %in% tail(mean.cvs$variable,n=10)), aes(x = orig.ident, y = value)) + facet_wrap(~ variable, scale="free_y", labeller = label_wrap_gen(width = 2, multi_line = TRUE)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))


```

```{r}
# Deconvolve mouse data using scRNA-seq from Bach et al
external.data.dir <- "/projects/activities/jaxcc/CATch-project/analysis/tnbc/external-data"
bach.rds.file <- paste0(external.data.dir, "/", "BRCA1_SCE.rds")
sce <- readRDS(bach.rds.file)
bach.cnts <- as.matrix(assay(sce, "counts"))
bach.metadata <- as.data.frame(colData(sce))
cell.names <- paste0(bach.metadata$Sample, "-", bach.metadata$barcode)
colnames(bach.cnts) <- cell.names



```

```{r}
anno.var <- "CellTypesFinal"
anno.var <- "MajorGroups"
bach.cell.types <- bach.metadata[, anno.var]
bach.cell.types <- as.factor(bach.cell.types)
names(bach.cell.types) <- cell.names
```


```{r}
sc.cell.types <- bach.cell.types
sc.counts <- bach.cnts
sc.cell.types <- sc.cell.types[colnames(sc.counts)]
nUMI <- colSums(sc.counts)
reference <- Reference(sc.counts, sc.cell.types, nUMI, n_max_cells = ncol(sc.counts) + 1)
```

```{r}
nms <- names(mouse.filtered.objs)
names(nms) <- nms

rds.dir <- paste0("/projects/activities/jaxcc/CATch-project/analysis/tnbc/bach-rds-", anno.var, "/")
dir.create(rds.dir, showWarnings = FALSE, recursive = TRUE)

rctds <-
  llply(nms,
        .parallel = FALSE,
        .fun = function(nm) {

          rds.file <- paste0(rds.dir, "/", nm, "-rctd.rds")
          if(!file.exists(rds.file)) {
            st.obj <- mouse.filtered.objs[[nm]]
          
            # Get raw ST coiunts
            st.counts <- GetAssayData(st.obj, assay="Spatial", slot="counts")

            # Get the spot coordinates
            st.coords <- st.obj[[]][, c("col", "row")]
            colnames(st.coords) <- c("x","y")

            # Get the # of UMI per spot
            nUMI <- colSums(st.counts) # In this case, total counts per pixel is nUMI

            # Create the RCTD 'puck', representing the ST data
            puck <- SpatialRNA(st.coords, st.counts, nUMI)


            max_cores <- min(5, detectCores() - 1)

            # Note that we have keep_reference = TRUE here. Without it, the default is
            # keep_reference = FALSE, which would ignore the Reference we have 
            # intentionally created above.
            myRCTD.all <- create.RCTD(puck, reference, max_cores = max_cores, keep_reference = TRUE)
          
            myRCTD.all <- suppressPackageStartupMessages(run.RCTD(myRCTD.all, doublet_mode = 'full'))

            saveRDS(myRCTD.all, file = rds.file)
          }
          return(readRDS(rds.file))

        })
```

```{r}
stop("stop")
```


```{r}

# See https://stackoverflow.com/questions/9563711/r-color-palettes-for-many-data-classes/41230685#41230685
mt <- mt.orig
datasets <- unique(mt$project)
if(length(datasets) == 2) {
  dataset_cols <- c("blue", "black")
} else {
  dataset_cols <- carto_pal(length(datasets), "Safe")
}
names(dataset_cols) <- datasets
dataset_labels <- mt$project

samples <- unique(mt$orig.ident)
if(length(samples) < 13) {
  sample_cols <- carto_pal(length(samples), "Safe")
} else {
  c25 <- c(
    "dodgerblue2", "#E31A1C", # red
    "green4",
    "#6A3D9A", # purple
    "#FF7F00", # orange
    "black", "gold1",
    "skyblue2", "#FB9A99", # lt pink
    "palegreen2",
    "#CAB2D6", # lt purple
    "#FDBF6F", # lt orange
    "gray70", "khaki2",
    "maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
    "darkturquoise", "green1", "yellow4", "yellow3",
    "darkorange4", "brown"
  )
  sample_cols <- c25[1:length(samples)]
}
names(sample_cols) <- samples
sample_labels <- mt$orig.ident

mt.df <- mt
mt <- subset(mt, select=-c(project, orig.ident, spot))
mt <- mt[,tnbc.hvfs]
colnames(mt) <- gsub(colnames(mt), pattern="HALLMARK_", replacement="")
colnames(mt) <- gsub(colnames(mt), pattern="_", replacement=" ")

mt <- scale(mt, center = TRUE, scale = TRUE)
mt <- as.matrix(mt)
rownames(mt) <- NULL
sz <- 16

results <- prcomp(mt, center=TRUE, scale=TRUE)
var_explained = results$sdev^2 / sum(results$sdev^2)

# num of PCs required to have ~90% variance explained
num.pcs <- which.min((cumsum(var_explained)-0.9)^2)
num.col.clusters <- num.pcs  

results <- prcomp(t(mt), center=TRUE, scale=TRUE)
var_explained = results$sdev^2 / sum(results$sdev^2)

# num of PCs required to have ~90% variance explained
num.pcs <- which.min((cumsum(var_explained)-0.9)^2)
num.row.clusters <- num.pcs  


file <- paste0(mouse_hallmark_plots_dir, "/", "mouse-human-breast-hallmark-mcp-gsea-heatmap-new")

set.seed(1)
tiff(paste0(file, ".tiff"), width = 3 * 480, height = 2 * 480)
raster_dev <- "tiff"
#png(paste0(file, ".png"), width = 3 * 480, height = 2 * 480)
#raster_dev <- "CairoPNG"
#raster_dev <- "png"


hm <- Heatmap(mt, name="Hallmark\nNES", use_raster=FALSE, raster_device=raster_dev,
              raster_by_magick = FALSE, raster_resize_mat = TRUE, column_names_rot = 45,
              # raster_quality = 0.1,
              column_names_gp = gpar(fontsize = sz), column_title_gp = gpar(fontsize = sz),
              row_title_gp = gpar(fontsize = sz), column_names_max_height = unit(12, "cm"),
              heatmap_legend_param = list(title_gp = gpar(fontsize = sz), 
                                          labels_gp = gpar(fontsize = sz)), 
              cluster_rows = TRUE, row_km = num.row.clusters)
#              cluster_rows=FALSE, cluster_columns=FALSE)
#              cluster_rows=TRUE, cluster_columns=TRUE, 
#              row_km = num.row.clusters, column_km = num.col.clusters)

#hm <- hm + rowAnnotation(project = project_labels, col = list(project = project_cols), annotation_legend_param = list(project = list(title_gp = gpar(fontsize = sz), labels_gp = gpar(fontsize = sz))))
#hm <- hm + rowAnnotation(sample = sample_labels, col = list(sample = sample_cols), annotation_legend_param = list(sample = list(title_gp = gpar(fontsize = sz), labels_gp = gpar(fontsize = sz))))
hm <- hm + rowAnnotation(sample = sample_labels, dataset = dataset_labels, 
                         col = list(sample = sample_cols, dataset = dataset_cols),
                         annotation_name_gp= gpar(fontsize = sz),
                         annotation_legend_param = 
                           list(sample = list(title_gp = gpar(fontsize = sz), 
                                              labels_gp = gpar(fontsize = sz)),
                                dataset = list(title_gp = gpar(fontsize = sz),
                                               labels_gp = gpar(fontsize = sz))))
# The padding argument can give the error
# Error in mat[seq(ind_r1[i], ind_r2[i]), seq(ind_c1[j], ind_c1[j]), drop = FALSE] : 
#  subscript out of bounds
# for these values of padding
# padding <- unit(c(2, 10, 2, 2), "mm")
# padding <- unit(c(5.5, 2 * 5.5, 5.5, 5.5), "points")
# whereas hm <- draw(hm) does not.
# This is the default (GLOBAL_PADDING):
# padding <- unit(c(5.5, 5.5, 5.5, 5.5), "points")
# Actually, draw(hm) also seems to cause the error
# It seems like the error only occurs in the context of this 
# code (as opposed to interactively). Possibly in the context of
# outputing to a tiff file
# use_raster seems to be the problem.
# I have disabled for now, but it may be required for large
# matrices and larger files.
padding <- unit(c(5.5, 5.5, 5.5, 5.5), "points")
# hm <- draw(hm, padding = padding)
hm <- draw(hm)

# print(hm)
d <- dev.off()

row_clustering <- row_order(hm)

row_clustering <- ldply(row_clustering, .fun = function(elem) data.frame(index=elem))
colnames(row_clustering) <- c("cluster", "index")
row_clustering <- row_clustering[order(row_clustering$index, decreasing=FALSE),]

mt.df$index <- 1:nrow(mt.df)
mt.df <- merge(mt.df, row_clustering, by = "index")

tbl <- as.matrix(table(mt.df$cluster, mt.df$project))
tbl[,1] <- tbl[,1] / sum(tbl[,1])
tbl[,2] <- tbl[,2] / sum(tbl[,2])
mouse.clusters <- rownames(tbl[tbl[,2] > tbl[,1],])

# g <- plot.cluster.fraction.by.annotation(mt.df$cluster, mt.df$project)
mt.df.mouse <- subset(mt.df, orig.ident %in% mouse.ids)
mt.df.mouse <- subset(mt.df.mouse, cluster %in% mouse.clusters)
g <- plot.cluster.fraction.by.annotation(mt.df.mouse$cluster, mt.df.mouse$orig.ident)
file <- paste0(mouse_hallmark_plots_dir, "/", "mouse-human-breast-hallmark-mcp-gsea-cluster-frac-new.png")
w <- 2 * 2.75
png(file, width = w * 480, height = 2.75 * 480)
print(g)
d <- dev.off()
       
# g <- plot.cluster.fraction.by.annotation(mt.df$cluster, mt.df$project)
mt.df.human <- subset(mt.df, !(orig.ident %in% mouse.ids))
mt.df.human <- subset(mt.df.human, !(cluster %in% mouse.clusters))
g <- plot.cluster.fraction.by.annotation(mt.df.human$cluster, mt.df.human$orig.ident)
file <- paste0(mouse_hallmark_plots_dir, "/", "human-only-breast-hallmark-mcp-gsea-cluster-frac-new.png")
w <- 2 * 2.75
png(file, width = w * 480, height = 2.75 * 480)
print(g)
d <- dev.off()

```
```{r}
mouse.filtered.objs <- suppressWarnings(create.visium.seurat.objects(mouse_spaceranger_dirs, filter.spots = TRUE))

```


```{r}

mt.df.mod <- mt.df
objs <- mouse.human.filtered.objs[unique(mt.df$orig.ident)]
names(objs) <- unlist(lapply(names(objs), function(str) ifelse(grepl(str, pattern="_"), unlist(strsplit(str, split="_"))[2], str)))
mt.df.mod$orig.ident <- unlist(laply(mt.df.mod$orig.ident, function(str) ifelse(grepl(str, pattern="_"), unlist(strsplit(str, split="_"))[2], str)))
for(cluster in unique(row_clustering$cluster)) {
  print(cluster)
  g <- suppressWarnings(plot.cluster.with.hne(objs, mt.df.mod, cluster.num = cluster))
  g <- add.title.to.plot(g, paste0("Cluster ", cluster), rel_heights = c(0.1,1), size = 20)
  file <- paste0(mouse_hallmark_plots_dir, "/", "mouse-human-breast-hallmark-mcp-gsea-hne-cluster-", cluster, "-new.png")
  dw <- 1.5
  dh <- 2
  png(file, width = dw * 480, height = dh * 480)
  print(g)
  d <- dev.off()
}
```


```{r}
# To do 
# Plot distribution of datasets across clusters
# re-run tnbc gsea
# integrate tnbc human and breast mouse
mt <- combined.mouse.hallmark.mcp.gsea
info.tbl.subset <- info.tbl
# Only keep epithelial tumors
info.tbl.subset <- subset(info.tbl.subset, !(project %in% "Orthotropic_melanoma"))
info.tbl.subset <- subset(info.tbl.subset, labels == "Frozen")
info.tbl.subset <- subset(info.tbl.subset, species == "Mouse")
# Only keep one sample per mouse
info.tbl.subset <- info.tbl.subset[!duplicated(info.tbl.subset$biological_replicate),]
mt <- merge(mt, info.tbl.subset, by.x = c("project", "orig.ident"), by.y = c("project", "names"))
print(unique(info.tbl.subset[, c("project", "names", "labels", "species", "biological_replicate", "spaceranger")]))
sds <- apply(subset(mt, select=-c(project, orig.ident, spot, labels, species, biological_replicate, spaceranger)), 2, sd)
means <- apply(subset(mt, select=-c(project, orig.ident, spot, labels, species, biological_replicate, spaceranger)), 2, mean)
hvfs <- names(sort(sds/means, decreasing=TRUE))[1:25]

# See https://stackoverflow.com/questions/9563711/r-color-palettes-for-many-data-classes/41230685#41230685
datasets <- unique(mt$project)
if(length(datasets) == 2) {
  dataset_cols <- c("blue", "black")
} else {
  dataset_cols <- carto_pal(length(datasets), "Safe")
}
names(dataset_cols) <- datasets
dataset_labels <- mt$project

samples <- unique(mt$orig.ident)
if(length(samples) < 13) {
  sample_cols <- carto_pal(length(samples), "Safe")
} else {
  c25 <- c(
    "dodgerblue2", "#E31A1C", # red
    "green4",
    "#6A3D9A", # purple
    "#FF7F00", # orange
    "black", "gold1",
    "skyblue2", "#FB9A99", # lt pink
    "palegreen2",
    "#CAB2D6", # lt purple
    "#FDBF6F", # lt orange
    "gray70", "khaki2",
    "maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
    "darkturquoise", "green1", "yellow4", "yellow3",
    "darkorange4", "brown"
  )
  sample_cols <- c25[1:length(samples)]
}
names(sample_cols) <- samples
sample_labels <- mt$orig.ident

mt.df <- mt
mt <- subset(mt, select=-c(project, orig.ident, spot, species, biological_replicate))
mt <- mt[,hvfs]
mt <- scale(mt, center = TRUE, scale = TRUE)
mt <- as.matrix(mt)
rownames(mt) <- NULL
sz <- 16

results <- prcomp(mt, center=TRUE, scale=TRUE)
var_explained = results$sdev^2 / sum(results$sdev^2)

# num of PCs required to have ~90% variance explained
num.pcs <- which.min((cumsum(var_explained)-0.9)^2)
num.col.clusters <- num.pcs  

results <- prcomp(t(mt), center=TRUE, scale=TRUE)
var_explained = results$sdev^2 / sum(results$sdev^2)

# num of PCs required to have ~90% variance explained
num.pcs <- which.min((cumsum(var_explained)-0.9)^2)
num.row.clusters <- num.pcs  


file <- paste0(mouse_hallmark_plots_dir, "/", "mouse-frozen-epi-hallmark-mcp-gsea-heatmap", ".tiff")

set.seed(1)
tiff(file, width = 3 * 480, height = 2 * 480)


hm <- Heatmap(mt, name="Meta Program\nNES", use_raster=TRUE, raster_device="tiff",
              raster_by_magick = FALSE, raster_resize_mat = TRUE, column_names_rot = 45,
              column_names_gp = gpar(fontsize = sz), column_title_gp = gpar(fontsize = sz),
              row_title_gp = gpar(fontsize = sz), column_names_max_height = unit(12, "cm"),
              heatmap_legend_param = list(title_gp = gpar(fontsize = sz), 
                                          labels_gp = gpar(fontsize = sz)), 
              cluster_rows=TRUE, cluster_columns=TRUE, 
              row_km = num.row.clusters, column_km = num.col.clusters)

#hm <- hm + rowAnnotation(project = project_labels, col = list(project = project_cols), annotation_legend_param = list(project = list(title_gp = gpar(fontsize = sz), labels_gp = gpar(fontsize = sz))))
#hm <- hm + rowAnnotation(sample = sample_labels, col = list(sample = sample_cols), annotation_legend_param = list(sample = list(title_gp = gpar(fontsize = sz), labels_gp = gpar(fontsize = sz))))
hm <- hm + rowAnnotation(sample = sample_labels, dataset = dataset_labels, 
                         col = list(sample = sample_cols, dataset = dataset_cols),
                         annotation_name_gp= gpar(fontsize = sz),
                         annotation_legend_param = 
                           list(sample = list(title_gp = gpar(fontsize = sz), 
                                              labels_gp = gpar(fontsize = sz)),
                                dataset = list(title_gp = gpar(fontsize = sz),
                                               labels_gp = gpar(fontsize = sz))))
hm <- draw(hm, padding = unit(c(2, 40, 2, 2), "mm"))
d <- dev.off()

row_clustering <- row_order(hm)

row_clustering <- ldply(row_clustering, .fun = function(elem) data.frame(index=elem))
colnames(row_clustering) <- c("cluster", "index")
row_clustering <- row_clustering[order(row_clustering$index, decreasing=FALSE),]

mt.df$index <- 1:nrow(mt.df)
mt.df <- merge(mt.df, row_clustering, by = "index")

g <- plot.cluster.fraction.by.annotation(mt.df$cluster, mt.df$project)
file <- paste0(mouse_hallmark_plots_dir, "/", "mouse-frozen-epi-hallmark-mcp-gsea-cluster-frac.png")
w <- 2 * 2.75
png(file, width = w * 480, height = 2.75 * 480)
print(g)
d <- dev.off()
       
mouse.filtered.objs <- create.visium.seurat.objects(spaceranger_dirs, filter.spots = TRUE)
g <- plot.cluster.with.hne(mouse.filtered.objs[unique(mt.df$orig.ident)], mt.df, cluster.num = 1)
g <- add.title.to.plot(g, paste0("Cluster 1"), rel_heights = c(0.1,1), size = 20)
file <- paste0(mouse_hallmark_plots_dir, "/", "mouse-frozen-epi-hallmark-mcp-gsea-hne-cluster-1.png")
dw <- 1.5
dh <- 2
png(file, width = dw * 480, height = dh * 480)
print(g)
d <- dev.off()

```


```{r}
stop("stop")
```

```{r}
# To do:
# Heatmap
# Annotate fresh frozen vs ffpe
# Annotate patient
# Plots showing distribution across cluster
# Isolate shared cluster
```



```{r}
# Original data
orig.datasets <- c("SC2200259_9990", "SC2200260_9990", "SC2200261_7031", "SC2200262_7031", "SC2200263_4700", "SC2200264_4700", "SC2200265_2171", "SC2200266_2171")
use.spaceranger.2.0.0.results <- TRUE
orig_base_dir <- '/projects/compsci/jgeorge/whitebr/tnbc/'
analysis_base_dir <- '/projects/compsci/jgeorge/whitebr/tnbc/'
if(use.spaceranger.2.0.0.results) {
  orig_base_dir <- '/projects/activities/jaxcc/CATch-project/raw-data/visium/tnbc/orig-data-spaceranger-2.0.0/22-scbct-023/'
  analysis_base_dir <- '/projects/compsci/jgeorge/whitebr/tnbc-spaceranger-2.0.0/'
}

# New data, including some overlapping samples
new.datasets <- c("SC2300228_JP9990", "SC2300228_JP9990-reseq", "SC2300229_JP1127", "SC2300230_JP1330A", "SC2300231_JP1863B", "SC2300231_JP1863B-reseq", "SC2300232_JP6970", "SC2300233_JP6110", "SC2300234_JP4401B", "SC2300235_JP4700", "SC2300235_JP4700-reseq")
new_base_dir <- '/projects/chuang-lab/USERS/whitebr/tnbc/tnbc-050223/'

spaceranger_dirs <- paste0(orig_base_dir, orig.datasets, "/spaceranger/")
spaceranger_dirs <- c(spaceranger_dirs, paste0(new_base_dir, new.datasets, "/spaceranger/"))
datasets <- c(orig.datasets, new.datasets)

# datasets <- datasets[1:5]
# spaceranger_dirs <- spaceranger_dirs[1:5]
names(spaceranger_dirs) <- datasets
names(datasets) <- datasets


# Define and create output results and plots directories
analysis_dir <- paste0(analysis_base_dir, '/combined-analysis/')
dir.create(analysis_dir, showWarnings = FALSE, recursive = TRUE)
plots_dir <- paste0(analysis_base_dir, '/combined-plots/')
dir.create(plots_dir, showWarnings = FALSE, recursive = TRUE)

# Prefix for all output files (results and plots)
analysis_file_prefix <- paste0("tnbc-")
```

```{r}

names(datasets) <- datasets


# Extract the sample name from the datasets (i.e., foo_<sample>)
patient <- unlist(lapply(datasets, function(str) unlist(strsplit(str, split="_"))[2]))
sample <- unlist(lapply(datasets, function(str) unlist(strsplit(str, split="_"))[1]))

patient.df <- as.data.frame(patient)
patient.df$sample <- rownames(patient.df)
patient.df$short.sample <- sample
patient.df$label <- "Batch 1"
flag <- grepl(patient.df$sample, pattern="JP")
patient.df[flag,"label"] <- "Batch 2"
flag <- grepl(patient.df$sample, pattern="reseq")
patient.df[flag,"label"] <- "Batch 2-reseq"
patient.df$patient <- gsub(patient.df$patient, pattern="-reseq", replacement="")
patient.df$patient <- gsub(patient.df$patient, pattern="JP", replacement="")
rownames(patient.df) <- patient.df$sample

samples.by.patient <- dlply(patient.df, .variables = c("patient"), .fun = function(df) df$sample)

# This comes from SCBL_Data-Release_20230320-KP.xlsx (sent by Bill on 3/20/23),
# SCBL-Release_20220601_JC.xlsx (sent by Bill on 6/1/22)
batch2.xls <- "SCBL_Data-Release_20230320-KP.xlsx"
batch2.df <- read.xlsx(batch2.xls, sheet=1)
batch2.df$treated <- "Untreated"
batch1.xls <- "SCBL-Release_20220601_JC.xlsx"
batch1.df <- read.xlsx(batch1.xls, sheet=1)
batch1.df$treated <- "Treated"
# I assume that the batch2 reseq were all done in the same lane. Fake this since I haven't received
# an xls sheet from Bill yet.
batch2.reseq.df <- data.frame(Output.ID = grep(rownames(patient.df), pattern="reseq", value=TRUE),
                              Flow.Cell = "dummy", Lane.on.FlowCell = "dummy")
batch2.reseq.df$treated <- "Untreated"
batch.df <- rbind(batch1.df[,c("Output.ID", "Flow.Cell", "Lane.on.FlowCell", "treated")], 
                  batch2.df[,c("Output.ID", "Flow.Cell", "Lane.on.FlowCell", "treated")],
                  batch2.reseq.df[,c("Output.ID", "Flow.Cell", "Lane.on.FlowCell", "treated")])
patient.df <- merge(patient.df, batch.df, by.x=c("sample"), by.y = c("Output.ID"))
# Some of the samples in batches 2 and 2-reseq are actually treated
patient.df[patient.df$patient %in% subset(patient.df, treated == "Treated")$patient, "treated"] <- "Treated"
patient.df$batch.var <- paste(patient.df$label, patient.df$Flow.Cell, patient.df$Lane.on.FlowCell, sep="-")
patient.df <- patient.df[order(patient.df$patient, patient.df$label, decreasing=FALSE),]
rownames(patient.df) <- patient.df$sample

tmp <- patient.df
tmp$label <- factor(tmp$label, levels=c("Batch 2", "Batch 2-reseq", "Batch 1"))
tmp <- tmp[order(tmp$label),]
# Select one sample per patient, favoring batch 2
one.sample.per.patient.batch.2.bias.df <- tmp[!duplicated(tmp$patient),]

tmp <- patient.df
tmp$label <- factor(tmp$label, levels=c("Batch 1", "Batch 2", "Batch 2-reseq"))
tmp <- tmp[order(tmp$label),]
# Select one sample per patient, favoring batch 2
one.sample.per.patient.batch.1.bias.df <- tmp[!duplicated(tmp$patient),]

```

```{r}
# Define samples to use for analysis
# Take two patients with replicates within and across batches. These are both treated.
# Also take two untreated.
samples <- c(subset(patient.df, patient == "9990")$sample, subset(patient.df, patient == "4700")$sample,"SC2300229_JP1127","SC2300230_JP1330A")
names(samples) <- samples
samples.replicate <- samples
#samples <- patient.df$sample

samples <- one.sample.per.patient.batch.1.bias.df$sample
names(samples) <- samples
samples.batch.1.bias <- samples

samples <- one.sample.per.patient.batch.2.bias.df$sample
names(samples) <- samples
samples.batch.2.bias <- samples
```



```{r}
# See https://stackoverflow.com/questions/59140960/remove-outliers-and-reduce-ylim-appropriately-for-each-facet-in-ggplot2
# filtering function - turns outliers into NAs to be removed
filter_lims <- function(x){
  l <- boxplot.stats(x)$stats[1]
  u <- boxplot.stats(x)$stats[5]

  for (i in 1:length(x)){
    x[i] <- ifelse(x[i]>l & x[i]<u, x[i], NA)
  }
  return(x)
}

```


```{r}
# See https://satijalab.org/seurat/articles/spatial_vignette.html, which says:
# DefaultAssay(brain.merge) <- "SCT"
# VariableFeatures(brain.merge) <- c(VariableFeatures(brain), VariableFeatures(brain2))
# brain.merge <- RunPCA(brain.merge, verbose = FALSE)
# brain.merge <- FindNeighbors(brain.merge, dims = 1:30)
# brain.merge <- FindClusters(brain.merge, verbose = FALSE)
# brain.merge <- RunUMAP(brain.merge, dims = 1:30)
run.pca.umap <- function(obj, n.pcs = 50, features = NULL) {
  DefaultAssay(obj) <- "SCT"
  reduction <- "pca"
  obj <- RunPCA(obj, features = features, verbose = FALSE, npcs=n.pcs)
  n.pcs <- min(n.pcs, ncol(obj@reductions[[1]]@cell.embeddings))
  obj <- FindNeighbors(obj, reduction = reduction, dims = 1:n.pcs)
  obj <- FindClusters(obj, verbose = FALSE)
  obj <- RunUMAP(obj, reduction = reduction, dims = 1:n.pcs)
  obj
}

run.umap.on.pca <- function(obj, dims = 1:50, features = NULL) {
  DefaultAssay(obj) <- "SCT"
  reduction <- "pca"
  obj <- FindNeighbors(obj, reduction = reduction, dims = dims)
  obj <- FindClusters(obj, verbose = FALSE)
  obj <- RunUMAP(obj, reduction = reduction, dims = dims)
  obj
}

prepare.seurat.objs <- function(samples) {
  all.objs <- Reduce(merge, filtered.objs[samples])
  Idents(all.objs) <- all.objs$orig.ident
  #all.objs <- apply.sctransform_(all.objs, use.v2 = TRUE)
  #print(VariableFeatures(all.objs, assay="SCT"))
  #VariableFeatures(all.objs, assay="SCT") <- unique(c(VariableFeatures(all.objs, assay="SCT"), unique(unname(unlist(lapply(filtered.objs[samples], function(x) VariableFeatures(x, assay="SCT")))))))
  VariableFeatures(all.objs, assay="SCT") <- unique(unname(unlist(lapply(filtered.objs[samples], function(x)
    VariableFeatures(x, assay="SCT")))))

  umap.obj <- run.pca.umap(all.objs)

  # Try a whole bunch of resolutions (0.8 is the default)
  resolutions <- seq(from=0.1, to=0.7, by=0.1)
  umap.obj2 <- umap.obj
  for(r in resolutions) {
    print(r)
    umap.obj2 <- FindClusters(umap.obj2, resolution = r)
  }
  umap.obj2
}
```


```{r}
prepare.gsea.mat <- function(samples) {
  dims <- llply(samples, function(sm) nrow(gsea.mats[[sm]]))
  # all.pval.mat <- Reduce(rbind, lapply(samples, function(sm) gsea.pval.mats[[sm]]))
  # all.mat <- Reduce(rbind, lapply(samples, function(sm) gsea.mats[[sm]]))
  
  all.mat <- ldply(samples, .fun = function(sm) cbind(spot = rownames(gsea.mats[[sm]]), gsea.mats[[sm]]))
  colnames(all.mat)[1] <- "orig.ident"

  all.pval.mat <- ldply(samples, .fun = function(sm) cbind(spot = rownames(gsea.pval.mats[[sm]]), gsea.pval.mats[[sm]]))
  colnames(all.pval.mat)[1] <- "orig.ident"

  
  sds <- apply(all.mat[, !(colnames(all.mat) %in% c("spot", "orig.ident"))], 2, sd)
  hvfs <- names(sds)[order(sds, decreasing=TRUE)][1:50]

  treated.labels <- Reduce(c, llply(samples, function(sm) rep(patient.df[sm,"treated"], dims[[sm]])))

  anno.df <- data.frame(sample = all.mat$orig.ident, spot = all.mat$spot, treated = treated.labels, index = 1:length(treated.labels))

  return(list("anno.df" = anno.df, "all.mat" = all.mat, "all.pval.mat" = all.pval.mat, "sds" = sds, "hvfs"= hvfs))
                   
}
```

```{r}
# Return a dataframe where each row corresponds to a spot,
# its barcode is the rowname, its position is in the x and y columns,
# and its normalized weights are in the remaining columns, named
# according to the corresponding cell type.
format.rctd.output <- function(rctd) {
  df <- format.rctd.output_(rctd, normalize = FALSE)
  df$Stromal <- apply(df[, c("dPVL", "imPVL", "iCAFs", "myCAFs")], 1, function(row) sum(row))
  df$T_Cells <- apply(df[, c("CD4+ T-cells", "CD8+ T-cells", "T_cells_unassigned", "T-cells Cycling", "T-Regs", "Tfh cells")], 1, function(row) sum(row))
  df$Immune <- apply(df[, c("CD4+ T-cells", "CD8+ T-cells", "T_cells_unassigned", "T-cells Cycling", "T-Regs", "Tfh cells", "B_Cells", "NK cells", "NKT cells", "Plasma_Cells")], 1, function(row) sum(row))
  df$Epithelial <- apply(df[, c("Epithelial_Basal", "Epithelial_Basal_Cycling", "Epithelial_Luminal_Mature")], 1, function(row) sum(row))
  cell.types <- c("dPVL", "imPVL")
  df$PVL <- apply(df[, cell.types], 1, function(row) sum(row))
  cell.types <- c("iCAFs", "myCAFs")
  df$CAF <- apply(df[, cell.types], 1, function(row) sum(row))
  df
}

```


```{r}
# Read in the filtered and unfiltered matrices and append the tissue positions information to the metadata:
rds.output.file <- paste0(analysis_dir, "/filtered-objs-with-sct.rds")
if(!file.exists(rds.output.file)) {
  filtered.objs <- suppressWarnings(create.visium.seurat.objects(spaceranger_dirs, filter.spots = TRUE))
  
  # Perform normalization of counts using SCTransform (which fits a negative binomial to the count data)
  # This adds a new assay "SCT" to the returned Seurat object. That assay has slots "counts" (the corrected counts),
  # "data" (log1p(counts)), and "scale.data" (the "pearson residuals").
  # These would be accessible via GetAssayData(filtered.objs[[1]], slot = "data", assay = "SCT")
  # Running with default parameters (the most interesting of which look to be variable.features.n and/or variable.features.rv.th)
  filtered.objs <- apply.sctransform(filtered.objs)
  saveRDS(filtered.objs, rds.output.file)
}
filtered.objs <- readRDS(rds.output.file)
# unfiltered.objs <- create.visium.seurat.objects(spaceranger_dirs, filter.spots = FALSE)
```


```{r}
load.sc.ref <- FALSE
for(dataset in datasets) {
  rds.file <- paste0(analysis_dir, "/", dataset, "-rctd.rds")
  if(!file.exists(rds.file)) {
    load.sc.ref <- TRUE
  }
}
marker.rds.file <- paste0(analysis_dir, "/", "wu-markers.rds")
if(!file.exists(marker.rds.file)) {
  load.sc.ref <- TRUE
}
if(load.sc.ref) {
  
  # Directory holding the scRNA-seq data to be used for deconvolution
  scrnaseq_dir <- paste0("/projects/compsci/jgeorge/whitebr/tnbc/external/wu-emboj/")
  scrnaseq_cnt_file <- paste0(scrnaseq_dir, "Wu_EMBOJ_count_matrix_sparse.mtx")
  scrnaseq_gene_file <- paste0(scrnaseq_dir, "Wu_EMBOJ_genes.tsv")
  scrnaseq_barcode_file <- paste0(scrnaseq_dir, "Wu_EMBOJ_barcodes.tsv")
  scrnaseq_metadata_file <- paste0(scrnaseq_dir, "Wu_EMBO_metadata.csv")
  
  tnbc.cnts <- Matrix::readMM(scrnaseq_cnt_file)
  tnbc.genes <- read.table(scrnaseq_gene_file, sep="\t", header=FALSE)
  tnbc.barcodes <- read.table(scrnaseq_barcode_file, sep="\t", header=FALSE)
  rownames(tnbc.cnts) <- tnbc.genes$V1
  colnames(tnbc.cnts) <- tnbc.barcodes$V1
  tnbc.metadata <- read.table(scrnaseq_metadata_file, sep=",", header=TRUE)
  # Row first row, which is just the type of each column
  tnbc.metadata <- tnbc.metadata[-1,]
  tnbc.cell.types <- tnbc.metadata$celltype_final
  tnbc.cell.types <- as.factor(tnbc.cell.types)
  names(tnbc.cell.types) <- tnbc.metadata$NAME
  tnbc.cell.types <- tnbc.cell.types[colnames(tnbc.cnts)]
}
```

```{r}
# Run RCTD spot deconvolution
rctds <- 
  llply(datasets, .parallel = FALSE,
        .fun = function(dataset) {
          print(dataset)
          rds.file <- paste0(analysis_dir, "/", dataset, "-rctd.rds")
          print(file.exists(rds.file))
          myRCTD <- rctd.wrapper(filtered.objs[[dataset]], tnbc.cnts, tnbc.cell.types, rds.output.file = rds.file, run.rctd = TRUE, intersect.sc.and.st.genes = FALSE)
          gc()
          myRCTD
        })
```

```{r}
# Add RCTD metadata to the Seurat objects
filtered.objs <-
  llply(datasets, .parallel = FALSE,
        .fun = function(nm) {
          # print(nm)
          md.df <- format.rctd.output(rctds[[nm]])
          obj <- add.metadata.to.seurat.obj(filtered.objs[[nm]], md.df)
          obj
        })
```

```{r}
run.harmony.umap <- function(obj, var = make.names("orig ident")) {
  DefaultAssay(obj) <- "SCT"
  obj <- RunHarmony(obj, group.by.vars = var)
  reduction <- "harmony"
  obj <- FindNeighbors(obj, reduction = reduction, dims = 1:20)
  resolutions <- seq(from=0.1, to=0.8, by=0.1)
  for(r in resolutions) {
    print(r)
    obj <- FindClusters(obj, resolution = r)
  }
  
  obj <- RunUMAP(obj, reduction = reduction, dims = 1:20)
  obj
}
```

```{r}
make.umap.plots <- function(obj, cluster.col, cluster.col.name, title.suffix = "SCT-based UMAP", plot.patient = FALSE, reduction = "umap") {
  uv <- sort(unique(as.character(obj[[]][, "orig.ident"])))
  cols = carto_pal(length(uv), "Safe")
  names(cols) <- uv
  g1 <- DimPlot(obj, group.by="orig.ident", reduction=reduction, cols = cols) +
    ggtitle(paste0("Sample (", title.suffix, ")")) +
    theme(plot.title = element_text(hjust = 0.5),
          text = element_text(size = 20),
          legend.text=element_text(size=20),
          axis.text=element_text(size=20),
          legend.position = "right") 
  meta.df <- obj[[]][, c("orig.ident"), drop=FALSE]
  meta.df$spot.ids <- rownames(meta.df)
  meta.df <- merge(meta.df, patient.df[, c("sample", "treated", "label", "patient")],
                   by.x = c("orig.ident"), by.y = c("sample"))
  rownames(meta.df) <- meta.df$spot.ids
  meta.df <- meta.df[, !(colnames(meta.df) %in% c("spot.ids"))]

  obj <- add.metadata.to.seurat.obj(obj, meta.df)
  g2 <- DimPlot(obj, group.by=cluster.col, reduction=reduction) +
    ggtitle(paste0("Clusters (", cluster.col.name, "; ", title.suffix, ")")) +
    theme(plot.title = element_text(hjust = 0.5),
          text = element_text(size = 20),
          legend.text=element_text(size=20),
          axis.text=element_text(size=20),
          legend.position = "right")
  gb <- "treated"
  title <- paste0("Treatment Status (", title.suffix, ")")
  cols <- NULL
  if(plot.patient) {
    gb <- "patient"
    title <- paste0("Patient (", title.suffix, ")")
    uv <- sort(unique(as.character(obj[[]][, gb])))
    cols = carto_pal(length(uv), "Safe")
    names(cols) <- uv
  }
                        
                        
  g3 <- DimPlot(obj, group.by=gb, reduction=reduction, cols = cols) +
    ggtitle(title) +
    theme(plot.title = element_text(hjust = 0.5),
          text = element_text(size = 20),
          legend.text=element_text(size=20),
          axis.text=element_text(size=20),
          legend.position = "right") 
  g4 <- DimPlot(obj, group.by="label", reduction=reduction) +
    ggtitle(paste0("Batch (", title.suffix, ")")) +
    theme(plot.title = element_text(hjust = 0.5),
          text = element_text(size = 20),
          legend.text=element_text(size=20),
          axis.text=element_text(size=20),
          legend.position = "right")
  #g <- plot_grid(g1, g2, labels="AUTO", ncol = 1, align = "v")
  g <- plot_grid(
    plot_grid(g1 + theme(legend.position = "none"),
              get_legend(g1),
              g2 + theme(legend.position = "none"),
              get_legend(g2),
              nrow = 1, rel_widths=c(5, 3, 5, 2, 5, 2)),
    plot_grid(g3 + theme(legend.position = "none"),
              get_legend(g3),
              g4 + theme(legend.position = "none"),
              get_legend(g4),
              nrow = 1, rel_widths=c(5, 3, 5, 2, 5, 2)),
    ncol = 1, rel_heights=c(1,1))
  g
}
```


```{r}
samples.lst <- list("repl" = samples.replicate, "batch.1" = samples.batch.1.bias, "batch.2" = samples.batch.2.bias)

nms <- names(samples.lst)
names(nms) <- nms
lst.seurat <-
  llply(nms,
        .fun = function(nm) { 
          rds.file <- paste0(analysis_dir, "/merged-seurat-", nm, ".rds")
          print(rds.file)
          if(!file.exists(rds.file)) {
            merged.obj <- prepare.seurat.objs(samples.lst[[nm]])
            saveRDS(merged.obj, file = rds.file)
          }
          merged.obj <- readRDS(rds.file)
          merged.obj
        })
```

```{r}
lst.harmonized <-
  llply(nms,
        .fun = function(nm) { 
          rds.file <- paste0(analysis_dir, "/merged-harmonized-seurat-", nm, ".rds")
          print(rds.file)
          if(!file.exists(rds.file)) {
            obj <- lst.seurat[[nm]]
            # Remove any old clusterings
            cluster.cols <- grep(x=colnames(obj[[]]), pattern="SCT_snn_res|seurat_clusters", value=TRUE)
            for(col in cluster.cols) { obj[[col]] <- NULL }
            merged.obj <- run.harmony.umap(obj, var = "orig.ident")
            saveRDS(merged.obj, file = rds.file)
          }
          merged.obj <- readRDS(rds.file)
          merged.obj
        })
```

```{r}
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
g <- make.umap.plots(lst.harmonized[[2]], cluster.col = "SCT_snn_res.0.7", cluster.col.name = "foo", reduction="harmony")
g <- make.umap.plots(lst.harmonized[[2]], cluster.col = "SCT_snn_res.0.7", cluster.col.name = "foo", reduction="umap")
```


```{r}
stop("stop")
```

```{r}



nms <- names(filtered.objs)
names(nms) <- nms

```

```{r}
exclude.genes.from.ranking <- FALSE

if(exclude.genes.from.ranking) {

nms <- names(filtered.objs)
names(nms) <- nms
exclude.genes <-
  llply(nms,
        .parallel = FALSE,
        .fun = function(nm) {
          obj <- filtered.objs[[nm]]
          mat <- GetAssayData(obj, assay="Spatial", slot="counts")
          orig.genes <- rownames(mat)
          
          flag <- rowSums(mat) == 0
          cat(paste0(nm, ": ", "excluding ", length(which(flag)), " of ", nrow(mat), " genes with all zero counts\n"))
          mat <- mat[!flag,]
          
          cnt.gt.0 <- rowSums(mat>0)
          cutoff <- 0.01 * ncol(mat)
          flag <- cnt.gt.0 < cutoff
          cat(paste0(nm, ": ", "excluding ", length(which(flag)), " of ", nrow(mat), " genes with > 0 reads in < ", cutoff, " samples\n"))
          mat <- mat[!flag,]
          
          return(orig.genes[!(orig.genes %in% rownames(mat))])
        })

all.exclude.genes <- sort(unique(Reduce(intersect, exclude.genes)))
}

```


```{r}
if(FALSE && exclude.genes.from.ranking) {
jaccard <- function(a, b) {
    intersection = length(intersect(a, b))
    union = length(a) + length(b) - intersection
    return (intersection/union)
}

# To find the number of highly variable genes, look at technical replicates (across batches) to see at
# which cutoff we maximize the Jaccard index between their respective variable genes.
# Assume that once this starts to fall off, we are hitting noise.
if(FALSE) {
# No, this logic doesn't work. The jaccard index just keeps going up.
candidate.cutoffs <- c(100, 200, 500, 1000, 2000, 3000, 4000, 5000, 10000, 20000)
names(candidate.cutoffs) <- candidate.cutoffs
replicate.pairs <- list("SC2200260_9990-SC2300228_JP9990" = c("SC2200260_9990", "SC2300228_JP9990"),
                        "SC2200263_4700-SC2300235_JP4700" = c("SC2200263_4700", "SC2300235_JP4700"))
# Try doing a cross sample analysis
replicate.pairs <- list("SC2200260_9990-SC2300228_JP9990" = c("SC2200260_9990", "SC2300235_JP4700"),
                        "SC2200263_4700-SC2300235_JP4700" = c("SC2200263_4700", "SC2300228_JP9990"))
jaccards <-
  ldply(replicate.pairs,
        .parallel = FALSE,
        .fun = function(pair) {
          nm1 <- pair[1]
          nm2 <- pair[2]
          
          obj1 <- filtered.objs[[nm1]]
          mat1 <- GetAssayData(obj1, assay="Spatial", slot="counts")
          rank.mat1 <- t(colRanks(mat1, ties.method = 'average'))
          rownames(rank.mat1) <- rownames(mat1)
          rank.mat1 <- rank.mat1[!(rownames(rank.mat1) %in% exclude.genes[[nm1]]),]
          sds1 <- apply(rank.mat1, 1, sd)
          sds1 <- sds[order(sds1, decreasing=TRUE)]
          
          obj2 <- filtered.objs[[nm2]]
          mat2 <- GetAssayData(obj2, assay="Spatial", slot="counts")
          rank.mat2 <- t(colRanks(mat2, ties.method = 'average'))
          rownames(rank.mat2) <- rownames(mat2)
          rank.mat2 <- rank.mat2[!(rownames(rank.mat2) %in% exclude.genes[[nm2]]),]
          sds2 <- apply(rank.mat2, 1, sd)
          sds2 <- sds[order(sds2, decreasing=TRUE)]
          
          ldply(candidate.cutoffs, .fun = function(cutoff) data.frame(jac = jaccard(names(sds1)[1:cutoff], names(sds2)[1:cutoff])))
        })
} #FALSE
}
```


```{r}
if(exclude.genes.from.ranking) {
rds.file <- paste0(analysis_dir, "/all-filtered-genes.rds")
if(!file.exists(rds.file)) {
  
  subset.mats <-
    llply(nms,
          .fun = function(nm) {
            obj <- filtered.objs[[nm]]
            mat <- GetAssayData(obj, assay="Spatial", slot="counts")
            if(exclude.genes.from.ranking) { 
              mat[!(rownames(mat) %in% all.exclude.genes),]
            }
            mat
          })
  
  common.genes <- Reduce(intersect, lapply(subset.mats, function(mat) rownames(mat)))
  
  subset.mats <- llply(subset.mats, .fun = function(mat) mat[common.genes,])
  combined.mat <- Reduce(cbind, subset.mats)
  
  combined.rank.mat <- t(colRanks(combined.mat, ties.method = 'average'))
  rownames(combined.rank.mat) <- rownames(combined.mat)
  colnames(combined.rank.mat) <- colnames(combined.mat)

  filtered.genes <-
    llply(nms,
          .parallel = FALSE,
          .fun = function(nm) {
            obj <- filtered.objs[[nm]]
            mat <- GetAssayData(obj, assay="Spatial", slot="counts")
            
            flag <- rownames(mat) %in% exclude.genes[[nm]]
            mat <- mat[!flag,]
            
            rank.mat <- t(colRanks(mat, ties.method = 'average'))
            rownames(rank.mat) <- rownames(mat)
            colnames(rank.mat) <- colnames(mat)
            
            sds <- apply(rank.mat, 1, sd)
            sds <- sds[order(sds, decreasing=TRUE)]
            num.var.to.keep <- 1000
            cat(paste0(nm, ": ", "retaining ", num.var.to.keep, " of ", nrow(mat), " variable genes\n"))
            
            return(names(sds)[1:num.var.to.keep])
          })
  
  all.filtered.genes <- sort(unique(Reduce(union, filtered.genes)))
  
  combined.sds <- apply(combined.rank.mat, 1, sd)
  combined.sds <- combined.sds[order(combined.sds, decreasing=TRUE)]
  
  # Keep as many genes with high _inter_-sample variance as the _total_ of genes with high
  # _intra_-sample variances
  table(names(combined.sds)[1:length(all.filtered.genes)] %in% all.filtered.genes)
  
  all.filtered.genes <- sort(unique(c(all.filtered.genes, names(combined.sds)[1:length(all.filtered.genes)])))
  length(all.filtered.genes)
  
  saveRDS(all.filtered.genes, file = rds.file)
}
all.filtered.genes <- readRDS(rds.file)
} # end exclude.genes.from.ranking
```



```{r}

```


```{r}
gsea.mats <-
  llply(cross.sample.gsea.res,
        .fun = function(gsea.res) {
          foo <- ldply(gsea.res, .fun = function(elem) elem[, c("pathway", "pval", "padj", "ES", "NES")])
          bar <- reshape2::dcast(data = foo, formula=.id ~ pathway, value.var="NES")
          rownames(bar) <- bar$.id
          bar <- bar[,!(colnames(bar) %in% c(".id"))]
          # rownames(bar) <- NULL
          bar
        })

gsea.pval.mats <-
  llply(cross.sample.gsea.res,
        .fun = function(gsea.res) {
          foo <- ldply(gsea.res, .fun = function(elem) elem[, c("pathway", "pval", "padj", "ES", "NES")])
          bar <- reshape2::dcast(data = foo, formula=.id ~ pathway, value.var="pval")
          rownames(bar) <- bar$.id
          bar <- bar[,!(colnames(bar) %in% c(".id"))]
          # rownames(bar) <- NULL
          bar
        })

common.pathways <- Reduce(intersect, lapply(gsea.mats, function(mat) colnames(mat)))

gsea.mats <- llply(gsea.mats, .fun = function(mat) mat[, common.pathways])
gsea.mats <- llply(gsea.mats, .fun = function(mat) na.omit(mat))

gsea.pval.mats <- llply(gsea.pval.mats, .fun = function(mat) mat[, common.pathways])
gsea.pval.mats <- llply(gsea.pval.mats, .fun = function(mat) na.omit(mat))

```

```{r}
#stop("stop")
```


```{r}
gsea.repl <- prepare.gsea.mat(samples.replicate)
gsea.batch.1 <- prepare.gsea.mat(samples.batch.1.bias)
gsea.batch.2 <- prepare.gsea.mat(samples.batch.2.bias)
```

```{r}
lst.res <- list("repl" = gsea.repl, "batch.1" = gsea.batch.1, "batch.2" = gsea.batch.2)
samples.lst <- list("repl" = samples.replicate, "batch.1" = samples.batch.1.bias, "batch.2" = samples.batch.2.bias)
hvfs <- list()
hms <- list()
#hvfs[["0"]] <- list()
for(nm in names(lst.res)) {
  mt <- lst.res[[nm]]$all.mat
  cols <- colnames(mt)
  cols <- cols[!(cols %in% c("orig.ident", "spot"))]
  sds <- apply(mt[,cols], 2, sd)
  qs <- apply(mt[,cols], 2, function(col) quantile(col, probs=c(0.025, 1 - 0.025)))
  o <- order(qs[2,], decreasing=TRUE)
  qs <- qs[,o]
  df <- data.frame(x = 1:ncol(qs), y = qs[2,])
  df <- rbind(df, data.frame(x = 1:ncol(qs), y = qs[1,]))
  plot(df$x, df$y)
  hvfs[[nm]] <- colnames(qs)[1:50]
  Sys.sleep(1)
}
```



```{r}
hms <- list()
hvfs[["batch.2.9.clusters"]] <- hvfs[["batch.2"]]
lst.res <- list("batch.2" = gsea.batch.2, "batch.2.9.clusters" = gsea.batch.2, "batch.1" = gsea.batch.1, "repl" = gsea.repl)
lst.samples <- list("batch.2" = samples.batch.2.bias, "batch.2.9.clusters" = samples.batch.2.bias, "batch.1" = samples.batch.1.bias, "repl" = samples.replicate)
column_kms <- list("batch.2" = 9, "batch.2.9.clusters" = 9, "batch.1" = 8, "repl" = 1)
row_kms <- list("batch.2" = 6, "batch.2.9.clusters" = 9, "batch.1" = 6, "repl" = 1)

column_kms <- list("batch.2" = 1, "batch.2.9.clusters" = 1, "batch.1" = 1, "repl" = 1)
row_kms <- list("batch.2" = 1, "batch.2.9.clusters" = 1, "batch.1" = 1, "repl" = 1)


if(TRUE) {
  nms <- names(lst.res)
#nms <- "batch.2"
for(nm in nms) {
  base.file.name <- paste0("heatmap-", nm, "-hvfs-50")
  rds.file <- paste0(base.file.name, ".rds")
  if(file.exists(rds.file)) {
    hms[[nm]] <- readRDS(rds.file)
    next
  }
  file <- paste0(plots_dir, "/", base.file.name, ".tiff")
  print(file)
  sample_cols = carto_pal(length(lst.samples[[nm]]), "Safe")
  names(sample_cols) <- names(lst.samples[[nm]])
  treated_cols <- c("Treated" = "blue", "Untreated" = "black")

  sample.labels <- lst.res[[nm]]$anno.df[, "sample"]
  treated.labels <- lst.res[[nm]]$anno.df[, "treated"]
  cols <- colnames(lst.res[[nm]]$all.mat)
  cols <- cols[!(cols %in% c("orig.ident", "spot"))]
  cols <- hvfs[[nm]]
  set.seed(1)
  tiff(file, width = 3 * 480, height = 2 * 480)
  sz <- 16
  mt <- as.matrix(lst.res[[nm]]$all.mat[, cols])
  hm <- Heatmap(mt, name="Meta Program\nNES", row_km=row_kms[[nm]], column_km=column_kms[[nm]], use_raster=TRUE, raster_device="tiff", raster_by_magick = FALSE, raster_resize_mat = TRUE, column_names_rot = 45, column_names_gp = gpar(fontsize = sz), column_title_gp = gpar(fontsize = sz), row_title_gp = gpar(fontsize = sz), column_names_max_height = unit(8, "cm"), heatmap_legend_param = list(title_gp = gpar(fontsize = sz), labels_gp = gpar(fontsize = sz))) + rowAnnotation(sample = sample.labels, treated = treated.labels, col = list(sample = sample_cols, treated = treated_cols), annotation_name_gp= gpar(fontsize = sz), annotation_legend_param = list(sample = list(title_gp = gpar(fontsize = sz), labels_gp = gpar(fontsize = sz)), treated = list(title_gp = gpar(fontsize = sz), labels_gp = gpar(fontsize = sz))))
  hm <- draw(hm)
  hms[[nm]] <- hm
  d <- dev.off()
  saveRDS(hms[[nm]], file=rds.file)
}
}

if(FALSE) {
nms <- names(lst.res)
for(nm in nms) {
  base.file.name <- paste0("heatmap-", nm, "-hvfs-50")
  rds.file <- paste0(analysis_dir, "/", base.file.name, ".rds")
  saveRDS(hms[[nm]], file=rds.file)
}
}
  
```

```{r}
#stop("stop")
```


```{r}
if(FALSE) {
milp.hms <- list()
milp.hvfs <- list()
hvfs.lst <- hvfs[["0"]]
for(nm in names(lst.res)) {
  mt <- lst.res[[nm]]$all.mat[, hvfs.lst[[nm]]]
  all.mat.cm <- cor(mt)
  n <- nrow(all.mat.cm)

  results <- prcomp(mt, center=TRUE, scale=TRUE)
  var_explained = results$sdev^2 / sum(results$sdev^2)

  # num of PCs required to have ~90% variance explained
  num.pcs <- which.min((cumsum(var_explained)-0.9)^2)
  
  #create scree plot
  df <- data.frame(x = 1:length(var_explained), var_explained = var_explained)
  ggplot(data = subset(df, x < max(25, num.pcs+1)), aes(x = x, y = var_explained)) + 
    geom_line() + 
    xlab("Principal Component") + 
    ylab("Variance Explained") +
    ggtitle("Scree Plot") +
    ylim(0, 1)  +
    geom_vline(xintercept = num.pcs)

  # https://math.stackexchange.com/questions/3817389/finding-nearly-orthogonal-subset-of-vectors-from-a-set-of-vectors
  # Find a set of vectors with minimum correlation
  # https://www.r-orms.org/mixed-integer-linear-programming/packages/modelling-milp/
  suppressPackageStartupMessages(p_load(ompr))
  suppressPackageStartupMessages(p_load(ROI))
  suppressPackageStartupMessages(p_load(ROI.plugin.glpk))
  suppressPackageStartupMessages(p_load(ompr.roi))

  # Find a set of vectors with minimum correlation
  #stop("I think there is a bug below -- objective should be forall i < j, not sum over i < j")
  set.seed(1)
  k <- floor(length(hvfs.lst[[nm]])/2)
  k <- 15
  #weights <- abs(all.mat.cm[1:25,1:25])
  #initial.vars <- hvfs
  #weights <- abs(all.mat.cm[initial.vars,initial.vars])
  weights <- abs(all.mat.cm)
  n <- nrow(weights)
  model.base <- MIPModel() %>% 
    add_variable(x[i], i = 1:n, type = "binary") %>% 
    add_variable(z, type = "continuous") %>% 
    add_constraint(z >= weights[i, j] * ( x[i] + x[j] - 1 ), i = 1:n, j = 1:n, i < j) %>%
    set_objective(z, sense="min")
  
  model <- model.base %>%
    add_constraint(sum_expr(x[i], i = 1:n) == k) 
  result <- model %>% 
    solve_model(with_ROI("glpk", verbose = TRUE))
  soln <- get_solution(result, x[i]) %>% 
      dplyr::filter(value == 1)
  #select.vars <- initial.vars[soln$i]
  select.vars <- soln$i
  sub.weights <- weights[select.vars,select.vars]
  print(max(sub.weights[lower.tri(sub.weights,diag=FALSE)]))

  milp.hvfs[[nm]] <- sort(colnames(mt)[select.vars])
  file <- paste0(plots_dir, "/heatmap-", nm, "-hvfs-50-milp.tiff")
  print(file)
  print(milp.hvfs[[nm]])
  sample_cols = carto_pal(length(lst.samples[[nm]]), "Safe")
  names(sample_cols) <- names(lst.samples[[nm]])
  treated_cols <- c("Treated" = "blue", "Untreated" = "black")

  sample.labels <- lst.res[[nm]]$anno.df[, "sample"]
  treated.labels <- lst.res[[nm]]$anno.df[, "treated"]
  cols <- colnames(lst.res[[nm]]$all.mat)
  cols <- cols[!(cols %in% c("orig.ident", "spot"))]
  cols <- milp.hvfs[[nm]]
  set.seed(1)
  tiff(file, width = 2 * 480, height = 2 * 480)
  hm <- Heatmap(as.matrix(lst.res[[nm]]$all.mat[, cols]), row_km=6, use_raster=TRUE, raster_device="tiff", raster_by_magick = FALSE, raster_resize_mat = TRUE, column_title_rot = 45) + rowAnnotation(sample = sample.labels, treated = treated.labels, col = list(sample = sample_cols, treated = treated_cols))
  hm <- draw(hm)
  milp.hms[[nm]] <- hm
  d <- dev.off()
  
}
} # END FALSE

```



```{r}
#stop("stop")
```



```{r}
# Add a dummy GSEA object
lst.seurat.dummies <- list()
nm <- "batch.2"
all.mat <- lst.res[[nm]]$all.mat
mat <- all.mat[,!(colnames(all.mat) %in% c("orig.ident", "spot"))]
colnames(mat) <- gsub(colnames(mat), pattern="_", replacement="-")
spot.ids <- make.names(all.mat$spot, unique=TRUE)
rownames(mat) <- spot.ids
meta.df <- data.frame(orig.ident = all.mat$orig.ident, spot = all.mat$spot)
rownames(meta.df) <- spot.ids

obj <- CreateSeuratObject(t(mat), assay="gsea", meta.data=meta.df)
meta.df$spot.id <- rownames(meta.df)
#meta.df <- merge(meta.df, gsea.annos[[nm]][, c("orig.ident", "spot", "treated", "cluster")])
meta.df <- merge(meta.df, gsea.annos[[nm]][, c("orig.ident", "spot", "cluster")])
rownames(meta.df) <- meta.df$spot.id
meta.df <- meta.df[, !(colnames(meta.df) %in% c("spot.id"))]
obj <- add.metadata.to.seurat.obj(obj, meta.df)

DefaultAssay(obj) <- "gsea"
reduction <- "pca"
obj <- ScaleData(obj)
hvf.names <- gsub(lst.res[[nm]]$hvfs, pattern="_",replacement="-")
obj <- RunPCA(obj, features = hvf.names, verbose = FALSE, npcs=n.pcs)
n.pcs <- 20
red.mat <- as.matrix(mat[,hvf.names])
colnames(red.mat) <- paste0("gred_", 1:ncol(red.mat))
obj[["gred"]] <- CreateDimReducObject(embeddings = red.mat, key = "gred_", assay = "gsea")
reduction <- "gred"
obj <- FindNeighbors(obj, reduction = reduction, dims = 1:n.pcs)
obj <- FindClusters(obj, verbose = FALSE)
obj <- RunUMAP(obj, reduction = reduction, dims = 1:n.pcs)
# DimPlot(obj, reduction="umap", group.by="cluster",split.by="cluster")
lst.seurat.dummies[[nm]] <- obj
```




```{r}
nms <- names(lst.seurat)
names(nms) <- nms
sub.dir <- paste0(plots_dir, "/umap-clusters/")
plts <-
  llply(nms,
        .fun = function(nm) {
          obj <- lst.seurat[[nm]]
          cluster.cols <- grep(colnames(obj[[]]), pattern="SCT_snn_res", value=TRUE)
          names(cluster.cols) <- cluster.cols
          dir.create(paste0(sub.dir, nm), recursive=TRUE)
          llply(cluster.cols,
                .fun = function(cluster.col) {
                        g <- make.umap.plots(obj, cluster.col, cluster.col.name = cluster.col, title.suffix = "SCT->PCA->UMAP", plot.patient = (nm == "repl"))
                        file <- paste0(sub.dir, nm, "/", "umap-cluster-", nm, "-", cluster.col, ".png")
                        print(file)
                        png(file, width = 3 * 480, height = 2 * 480)
                        print(g)
                        d <- dev.off()
                })
        })

# Plot for gsea as well
nms <- names(lst.seurat.dummies)
names(nms) <- nms
sub.dir <- paste0(plots_dir, "/umap-clusters/")
plts <-
  llply(nms,
        .fun = function(nm) {
          obj <- lst.seurat.dummies[[nm]]
          #cluster.cols <- grep(colnames(obj[[]]), pattern="cluster", value=TRUE)
          #names(cluster.cols) <- cluster.cols
          #names(cluster.cols) <- cluster.cols
          cluster.cols <- list("MP GSEA cluster" = "cluster")
          cluster.col.names <- names(cluster.cols)
          names(cluster.col.names) <- as.vector(cluster.cols)
          dir.create(paste0(sub.dir, nm), recursive=TRUE)
          llply(cluster.cols,
                .fun = function(cluster.col) {
                        g <- make.umap.plots(obj, cluster.col, cluster.col.name = cluster.col.names[cluster.col], title.suffix = "MP GSEA->UMAP", plot.patient = (nm == "repl"))
                        file <- paste0(sub.dir, nm, "/", "umap-gsea-cluster-", nm, "-", cluster.col, ".png")
                        print(file)
                        png(file, width = 3 * 480, height = 2 * 480)
                        print(g)
                        d <- dev.off()
                })
        })
  
  
```


```{r}
#stop("stop")
```

```{r}
# Randomly select one MP per cluster
nm <- "batch.2"
for(nm in names(lst.res)[names(lst.res) != "repl"]) {
set.seed(1)
cnames <- colnames(lst.res[[nm]]$all.mat[, lst.res[[nm]]$hvfs])
col.sample <- as.vector(unlist(llply(column_order(hms[[nm]]), function(indices) cnames[sample(indices,size=1)])))

mat <- lst.res[[nm]]$all.mat[, c("orig.ident", "spot", col.sample)]
mat <- merge(mat, patient.df[, c("sample", "treated")], by.x = c("orig.ident"), by.y = c("sample"))
col.flag <- !(colnames(mat) %in% c("orig.ident", "spot", "treated", "label"))
colnames(mat)[col.flag] <- gsub(colnames(mat)[col.flag], pattern="\\.", replacement=" ")
tmp <- subset(patient.df, sample %in% mat$orig.ident)
tmp <- tmp[order(tmp$treated),]
tmp$sample <- gsub(tmp$sample, pattern="_", replacement=" ")
ident.levels <- tmp$sample
mat$orig.ident <- gsub(mat$orig.ident, pattern="_", replacement=" ")
mat.melted <- reshape2::melt(mat, id.vars=c("orig.ident", "spot", "treated"))
colnames(mat.melted) <- c("orig.ident", "spot", "treated", "MP", "value")
mat.melted$orig.ident <- factor(mat.melted$orig.ident, levels = ident.levels)
mat.melted$label <- paste0(mat.melted$orig.ident, " ", mat.melted$treated)
g <- ggplot(data = mat.melted, aes(x = value, fill=treated)) + geom_density() + facet_grid(MP ~ orig.ident + treated, scales="free_y", labeller = label_wrap_gen(10)) + ylab("Density") + xlab("Value") + theme(text = element_text(size=20)) + labs(fill=NULL)
sub.dir <- paste0(plots_dir, "/", "mp-densities/")
dir.create(sub.dir, recursive=TRUE)
file <- paste0(sub.dir, "/", "mp-density-", nm, ".png")
print(file)
png(file, width = 3 * 480, height = 2 * 480)
print(g)
d <- dev.off()
}
```


```{r}
if(FALSE) {
# Downsample
lst.res <- list("repl" = gsea.repl, "batch.1" = gsea.batch.1, "batch.2" = gsea.batch.2)
lst.res <- list("batch.2" = gsea.batch.2)
#lst.res <- list("repl" = gsea.repl)
lst.samples <- list("repl" = samples.replicate, "batch.1" = samples.batch.1.bias, "batch.2" = samples.batch.2.bias)
hms <- list()
ds.size <- 5
num.ds <- 5
for(nm in names(lst.res)) {
  for(i in 1:num.ds) {
    file <- paste0(plots_dir, "/heatmap-", nm, "-all-ds-", i, ".tiff")
    print(file)
    tiff(file, width = 2 * 480, height = 2 * 480)
    sample_cols = carto_pal(length(lst.samples[[nm]]), "Safe")
    names(sample_cols) <- names(lst.samples[[nm]])
    treated_cols <- c("Treated" = "blue", "Untreated" = "black")
  
    sample.labels <- lst.res[[nm]]$anno.df[, "sample"]
    treated.labels <- lst.res[[nm]]$anno.df[, "treated"]
    set.seed(i)
    nr <- nrow(lst.res[[nm]]$all.mat)
    rows <- sample.int(nr, ceiling(nr/ds.size), replace = FALSE)
    cols <- colnames(lst.res[[nm]]$all.mat)
    cols <- cols[!(cols %in% c("orig.ident", "spot"))]
    cols <- hvfs
    hm <- Heatmap(as.matrix(lst.res[[nm]]$all.mat[rows,cols]), use_raster=TRUE, raster_device="tiff") + rowAnnotation(sample = sample.labels[rows], treated = treated.labels[rows], col = list(sample = sample_cols, treated = treated_cols))
    hm <- draw(hm)
    # heatmap3(as.matrix(lst.res[[nm]]$all.mat[rows,cols]),useRaster=TRUE)
    d <- dev.off()
  }
}
}
```



```{r}
#stop("stop")
```

```{r}
res.names <- names(lst.res)
res.names <- res.names[row_kms > 1]
names(res.names) <- res.names
gsea.annos <-
  llply(res.names,
        .fun = function(nm) {
          print(nm)
          anno.df <- lst.res[[nm]]$anno.df
          row.clustering <- ldply(row_order(hms[[nm]]), .fun = function(elem) data.frame(index=elem))
          colnames(row.clustering)[1] <- "cluster"
          anno.df <- merge(anno.df, row.clustering)
          anno.df <- anno.df[, c("index", "sample", "spot", "treated", "cluster")]
          colnames(anno.df) <- c("index", "orig.ident", "spot", "treated", "cluster")
          anno.df
        })
```

```{r}

mat <- gsea.batch.2$all.mat[,!(colnames(gsea.batch.2$all.mat) %in% c("orig.ident", "spot"))]
colnames(mat) <- gsub(colnames(mat), pattern="_", replacement="-")
spot.ids <- make.names(gsea.batch.2$all.mat$spot, unique=TRUE)
rownames(mat) <- spot.ids
meta.df <- data.frame(orig.ident = gsea.batch.2$all.mat$orig.ident, spot = gsea.batch.2$all.mat$spot)
rownames(meta.df) <- spot.ids

# DimPlot(obj, reduction="umap")

obj <- CreateSeuratObject(t(mat), assay="gsea", meta.data=meta.df)
meta.df$spot.id <- rownames(meta.df)
meta.df <- merge(meta.df, gsea.annos[["batch.2"]][, c("orig.ident", "spot", "treated", "cluster")])
rownames(meta.df) <- meta.df$spot.id
meta.df <- meta.df[, !(colnames(meta.df) %in% c("spot.id"))]
obj <- add.metadata.to.seurat.obj(obj, meta.df)

DefaultAssay(obj) <- "gsea"
reduction <- "pca"
obj <- ScaleData(obj)
hvf.names <- gsub(gsea.batch.2$hvfs, pattern="_",replacement="-")
obj <- RunPCA(obj, features = gsub(gsea.batch.2$hvfs, pattern="_",replacement="-"), verbose = FALSE, npcs=n.pcs)
n.pcs <- 20
red.mat <- as.matrix(mat[,hvf.names])
colnames(red.mat) <- paste0("gred_", 1:ncol(red.mat))
obj[["gred"]] <- CreateDimReducObject(embeddings = red.mat, key = "gred_", assay = "gsea")
reduction <- "gred"
obj <- FindNeighbors(obj, reduction = reduction, dims = 1:n.pcs)
obj <- FindClusters(obj, verbose = FALSE)
obj <- RunUMAP(obj, reduction = reduction, dims = 1:n.pcs)
DimPlot(obj, reduction="umap", group.by="cluster",split.by="cluster")


umap.res <- umap(gsea.batch.2$all.mat[,!(colnames(gsea.batch.2$all.mat) %in% c("orig.ident", "spot"))], scale=TRUE, pca = 20)
df <- data.frame(umap1 = umap.res[,1], umap2 = umap.res[,2], orig.ident = gsea.batch.2$all.mat[, "orig.ident"], spot = gsea.batch.2$all.mat[, "spot"])
df <- merge(df, gsea.annos[["batch.2"]][, c("orig.ident", "spot", "treated", "cluster")])
g <- ggplot(data = df) + geom_point(aes(x=umap1,y=umap2)) + facet_wrap(~ treated)
```


```{r}
seurat.annos <- 
  llply(res.names,
        .fun = function(nm) {
          meta.obj.df <- lst.seurat[[nm]][[]]
          # Strip off the suffixes appended when we merged the objects
          spots <- unlist(lapply(rownames(meta.obj.df), function(str) unlist(strsplit(str, split="-"))[1]))
          spots <- paste0(spots, "-1")
          anno.df <- data.frame(orig.ident = meta.obj.df$orig.ident, spot = spots)
          rownames(anno.df) <- rownames(meta.obj.df)
          cluster.cols <- grep(colnames(meta.obj.df), pattern="SCT_snn_res", value=TRUE)
          anno.df <- merge(anno.df, meta.obj.df[, cluster.cols, drop=FALSE], by="row.names")
          anno.df <- anno.df[, !(colnames(anno.df) == "Row.names")]
          anno.df <- merge(anno.df, patient.df[, c("sample", "treated")], by.x = c("orig.ident"), by.y = c("sample"))
          anno.df
        })
```





```{r}
plot.hne.with.all.clusters <- function(seurat.objs, anno.df, sample.col = "orig.ident", spot.col = "spot", cluster.col = "cluster") {

  nms <- names(seurat.objs)
  names(nms) <- nms
  plts <- 
    llply(nms,
          .fun = function(sm) {
            print(sm)
            obj <- seurat.objs[[sm]]
            tmp <- anno.df[anno.df[, sample.col] == sm, ]
            rownames(tmp) <- tmp[, spot.col]
            tmp <- tmp[, cluster.col, drop=FALSE]
            obj <- add.metadata.to.seurat.obj(obj, tmp)
            Idents(obj) <- cluster.col
            g.hne <- plot.hne(obj)

            sub.anno.df <- anno.df[anno.df[, sample.col] == sm,]
            clusters <- unique(as.numeric(as.character(sub.anno.df[, cluster.col])))
            clusters <- sort(clusters, decreasing=FALSE)
            names(clusters) <- clusters
            
            sm.plts <- 
              llply(clusters,
                    .fun = function(cluster) {
                      colors <- c("cluster" = "yellow", "Unselected" = "black")
                      names(colors)[1] <- cluster
                      g.clust <- suppressWarnings(SpatialDimPlot(obj, cells.highlight = CellsByIdentities(object = obj, ident=cluster)) + scale_fill_manual(values= colors) + theme(legend.position = "none"))
                      g.clust <- g.clust + ggtitle(paste0("Clust ", cluster)) + theme(plot.title = element_text(hjust = 0.5))
                      g.clust <- g.clust + theme(text = element_text(size = 20))
                      g.clust
                    })
            g <- plot_grid(plotlist = c(list(g.hne), sm.plts))
            # g <- add.title.to.plot(g, sm, rel_heights=c(0.1,1))
            g
            
            
          })
  plts

}

```


```{r}
# Plot GSEA clusters
nms <- names(gsea.annos)
names(nms) <- nms
cluster.hne.plts <-
  llply(nms,
        .fun = function(nm) {
          anno.df <- gsea.annos[[nm]]
          treated.values <- unique(anno.df$treated)
          names(treated.values) <- treated.values
          clusters <- unique(as.numeric(as.character(anno.df$cluster)))
          names(clusters) <- clusters
          plts <- 
            llply(clusters,
                  .fun = function(cluster) {
                    samples <- samples.lst[[nm]]
                    llply(treated.values,
                          .fun = function(treated.status) {
                            sub.samples <- rownames(subset(patient.df[samples,], treated == treated.status))
                            g <- plot.cluster.with.hne(filtered.objs[sub.samples], anno.df, cluster.num = cluster, sample.col = "orig.ident", spot.col = "spot", cluster.col = "cluster")
                            cluster.col <- "gsea-cluster"
                            g <- add.title.to.plot(g, paste0("Cluster ", cluster, ": ", treated.status, " samples"), rel_heights = c(0.1,1), size = 20)
                            sub.dir <- paste0(plots_dir, "/", nm, "/", cluster.col)
                            dir.create(sub.dir, recursive=TRUE)
                            file <- paste0(sub.dir, "/", "samples-", nm, "-clustering-", cluster.col, "-cluster-", cluster, "-", treated.status, ".png")
                            print(file)
                            dw <- 1.5
                            dh <- 2
                            if(treated.status == "Treated") {
                              dw <- 1
                              dh <- 2
                            }
                            png(file, width = dw * 480, height = dh * 480)
                            print(g)
                            d <- dev.off()
                            g
                          })
                  })
          
        })
```

```{r}
nms <- names(seurat.annos)
names(nms) <- nms
cluster.hne.plts <-
  llply(nms,
        .fun = function(nm) {
          anno.df <- seurat.annos[[nm]]
          treated.values <- unique(anno.df$treated)
          names(treated.values) <- treated.values
          cluster.cols <- grep(colnames(anno.df), pattern="SCT_snn_res", value=TRUE)
          names(cluster.cols) <- cluster.cols
          clustering.plts <-
            llply(cluster.cols,
                  .fun = function(cluster.col) {
                    print(cluster.col)
                    clusters <- unique(as.numeric(as.character(anno.df[, cluster.col])))
                    names(clusters) <- clusters
                    
                    plts <- 
                      llply(clusters,
                            .fun = function(cluster) {
                              print(c(cluster.col, cluster))
                              samples <- samples.lst[[nm]]
                              cluster.plts <-
                                llply(treated.values,
                                    .fun = function(treated.status) {
                                      sub.samples <- rownames(subset(patient.df[samples,], treated == treated.status))
                                      tmp <- subset(unique(anno.df[, c("orig.ident", cluster.col)]), orig.ident %in% sub.samples)
                                      if(!(cluster %in% tmp[, cluster.col])) { return(NULL) }
                                                    
                                      g <- plot.cluster.with.hne(filtered.objs[sub.samples], anno.df, cluster.num = cluster, sample.col = "orig.ident", spot.col = "spot", cluster.col = cluster.col)
                                      g <- add.title.to.plot(g, paste0("Clust ", cluster, ": ", treated.status, " samples"), rel_heights = c(0.1,1), size = 20)
                                      sub.dir <- paste0(plots_dir, "/", nm, "/", cluster.col)
                                      dir.create(sub.dir, recursive=TRUE)
                                      file <- paste0(sub.dir, "/", "samples-", nm, "-clustering-", cluster.col, "-cluster-", cluster, "-", treated.status, ".png")
                                      png(file, width = 3 * 480, height = 2 * 480)
                                      print(g)
                                      d <- dev.off()
                                      g
                                    })
                              cluster.plts <- cluster.plts[unlist(lapply(cluster.plts, function(p) !is.null(p)))]
                              cluster.plts
                            })
                  })
          
        })

```


```{r}
nms <- names(gsea.annos)
names(nms) <- nms
all.cluster.hne.plts <-
  llply(nms,
        .fun = function(nm) {
          anno.df <- gsea.annos[[nm]]
          treated.values <- unique(anno.df$treated)
          names(treated.values) <- treated.values
          clusters <- unique(as.numeric(as.character(anno.df$cluster)))
          names(clusters) <- clusters
          samples <- samples.lst[[nm]]
          plts <- 
            llply(treated.values,
                  .fun = function(treated.status) {
                    sub.samples <- rownames(subset(patient.df[samples,], treated == treated.status))
                    gs <- plot.hne.with.all.clusters(filtered.objs[sub.samples], anno.df, sample.col = "orig.ident", spot.col = "spot", cluster.col = "cluster")
                    g.names <- names(gs)
                    names(g.names) <- g.names
                    cluster.col <- "gsea-cluster"
                    sub.dir <- paste0(plots_dir, "/", nm, "/", cluster.col)
                    dir.create(sub.dir, recursive=TRUE)
                    for(smpl in g.names) {
                      file <- paste0(sub.dir, "/", "samples-", nm, "-sample-", smpl, "-clustering-", cluster.col,  "-", treated.status, ".png")
                      print(file)
                      png(file, width = 1.75 * 480, height = 2 * 480)
                      tmp <- add.title.to.plot(gs[[smpl]], paste0(smpl, " (", treated.status, ")"), rel_heights=c(0.1,1), size = 20)
                      print(tmp)
                      d <- dev.off()
                    }
                    gs
                  })
          
        })
```

```{r}
# working
nms <- names(lst.seurat)
names(nms) <- nms
all.sct.cluster.hne.plts <-
  llply(nms,
        .fun = function(nm) {
          anno.df <- seurat.annos[[nm]]
          treated.values <- unique(anno.df$treated)
          names(treated.values) <- treated.values
          cluster.cols <- grep(colnames(anno.df), pattern="SCT_snn_res", value=TRUE)
          names(cluster.cols) <- cluster.cols
          clustering.plts <-
            llply(cluster.cols,
                  .fun = function(cluster.col) {
                    print(cluster.col)
                    clusters <- unique(as.numeric(as.character(anno.df[, cluster.col])))
                    names(clusters) <- clusters
                    samples <- samples.lst[[nm]]
                    plts <- 
                      llply(treated.values,
                            .fun = function(treated.status) {
                              sub.samples <- rownames(subset(patient.df[samples,], treated == treated.status))
                              gs <- plot.hne.with.all.clusters(filtered.objs[sub.samples], anno.df, sample.col = "orig.ident", spot.col = "spot", cluster.col = cluster.col)
                              g.names <- names(gs)
                              names(g.names) <- g.names
                              sub.dir <- paste0(plots_dir, "/", nm, "/", cluster.col)
                              dir.create(sub.dir, recursive=TRUE)
                              for(smpl in g.names) {
                                file <- paste0(sub.dir, "/", "samples-", nm, "-sample-", smpl, "-clustering-", cluster.col,  "-", treated.status, ".png")
                                print(file)
                                png(file, width = 3 * 480, height = 2 * 480)
                                tmp <- add.title.to.plot(gs[[smpl]], paste0(smpl, " (", treated.status, ")"), rel_heights=c(0.1,1), size = 20)
                                print(tmp)
                                d <- dev.off()
                              }
                              gs
                            })
                  })
                    
        })
```

```{r}
stop("working")
```

```{r}
krt.genes <- c("KRTCAP2", "KRT7", "KRT6A", "KRT6B", "KRT8", "KRT18", "KRT10", "KRT14")
```


```{r}
cpms <-
  llply(filtered.objs,
        .fun = function(obj) {
          mat <- GetAssayData(obj, assay="Spatial", slot="counts")
          norm.mat <- edgeR::cpm(as.matrix(mat), log=FALSE)
          norm.mat
        })
```

```{r}
rank.mats <-
  llply(filtered.objs,
        .fun = function(obj) {
          mat <- GetAssayData(obj, assay="Spatial", slot="counts")
         
          if(exclude.genes.from.ranking) {
            mat <- mat[rownames(mat) %in% all.filtered.genes,]
          }
          rank.mat <- t(colRanks(mat, ties.method = 'average'))
          rownames(rank.mat) <- rownames(mat)
          colnames(rank.mat) <- colnames(mat)
          rank.mat
        })

```

```{r}
# Add CPMs to objs
nms <- names(filtered.objs)
names(nms) <- nms
cpm.objs <-
  llply(nms,
        .fun = function(nm) {
          # filtered.objs[[nm]][["CPM"]] <- CreateAssayObject(data = cpms[[nm]])
          obj <- CreateSeuratObject(cpms[[nm]], assay="cpm")
          obj@images <- filtered.objs[[nm]]@images
          obj
        })


# Add ranks to objs
nms <- names(filtered.objs)
names(nms) <- nms
rank.objs <-
  llply(nms,
        .fun = function(nm) {
          obj <- CreateSeuratObject(rank.mats[[nm]], assay="rank")
          obj@images <- filtered.objs[[nm]]@images
          obj
        })

```


```{r}
igkcs <-
  ldply(cpms, 
        .fun = function(mat) {
          data.frame(spot = colnames(mat), igkc = mat["IGKC",])
    
  })
colnames(igkcs)[1] <- "orig.ident"

igkc.ranks <-
  ldply(rank.mats, 
        .fun = function(mat) {
          data.frame(spot = colnames(mat), igkc = mat["IGKC",])
    
  })
colnames(igkc.ranks)[1] <- "orig.ident"

m <- merge(igkcs, gsea.annos[["batch.2"]])
m$label <- paste0(m$orig.ident, "\n(", m$treated, ")")
#g <- ggplot(data = m, aes(x = cluster, y = igkc)) + geom_boxplot() + facet_wrap(~ orig.ident, scales = "free_y")
g <- m %>% 
    group_by(label, cluster) %>%  # do the same calcs for each box
    mutate(value2 = filter_lims(igkc))  %>% as_data_frame() %>%
    ggplot(aes(y = value2, x = cluster)) +
    geom_boxplot(na.rm = TRUE, outlier.shape = NA) + facet_wrap(~ label, scales="free_y")

m.rank <- merge(igkc.ranks, gsea.annos[["batch.2"]])
m.rank$label <- paste0(m.rank$orig.ident, "\n(", m.rank$treated, ")")
g.rank <- m.rank %>% 
    group_by(label, cluster) %>%  # do the same calcs for each box
    mutate(value2 = filter_lims(igkc))  %>% as_data_frame() %>%
    ggplot(aes(y = value2, x = cluster)) +
    geom_boxplot(na.rm = TRUE, outlier.shape = NA) + facet_wrap(~ label, scales="free_y")

```


```{r}
annos <- list("gsea" = gsea.annos, "seurat" = seurat.annos)
anno.nms <- names(annos)
for(anno.nm in anno.nms) {
  for(nm in names(annos[[anno.nm]])) {
  #  row.clustering <- ldply(row_order(hms[[nm]]), .fun = function(elem) data.frame(index=elem))
  #  colnames(row.clustering)[1] <- "row.cluster"
  #  anno.df <- lst.res[[nm]]$anno.df
  #  anno.df <- merge(anno.df, row.clustering, by=c("index"))
    anno.df <- annos[[anno.nm]][[nm]]
    cluster.cols <- grep(colnames(anno.df), pattern="SCT_snn_res|cluster", value=TRUE)
    for(cluster.col in cluster.cols) {
      plts <- make.cluster.plots(anno.df[, cluster.col], anno.df$orig.ident, anno.df$treated)
      sub.dir <- paste0(plots_dir, "/", nm)
      dir.create(sub.dir, recursive=TRUE)
      for(p.nm in names(plts)) {
        file <- paste0(sub.dir, "/", "cluster-frac-", anno.nm, "-", nm, "-clustering-", cluster.col, "-", p.nm, ".png")
        print(file)
        w <- 2 * 2.75
        if(p.nm == "treat.and.samples") { w <- 2.5 * 2.75 }
        png(file, width = w * 480, height = 2.75 * 480)
        print(plts[[p.nm]])
        d <- dev.off()
      }
    }
  }
}
```

```{r}
annos <- list("gsea" = gsea.annos, "seurat" = seurat.annos)
anno.nms <- names(annos)
for(anno.nm in anno.nms) {
  for(nm in names(annos[[anno.nm]])) {
    file <- paste0(analysis_dir, "/", "cluster-anno-", anno.nm, "-", nm, ".tsv")
    write.table(file = file, annos[[anno.nm]][[nm]], sep="\t", row.names=FALSE, col.names=TRUE, quote=FALSE)
    print(file)
    
  }
}
```


```{r}
tiff("heatmap-all.tiff", width = 2 * 480, height = 2 * 480)
sample_cols = carto_pal(length(samples), "Safe")
names(sample_cols) <- names(samples)
treated_cols <- c("Treated" = "blue", "Untreated" = "black")

hm <- Heatmap(as.matrix(all.mat), use_raster=TRUE, raster_device="tiff", row_km=10, column_km=12) + rowAnnotation(sample = sample.labels, treated = treated.labels, col = list(sample = sample_cols, treated = treated_cols))
hm <- draw(hm)
d <- dev.off()

```


```{r}

sample.labels <- Reduce(c, llply(samples, function(sm) rep(sm, dims[[sm]])))
treated.labels <- Reduce(c, llply(samples, function(sm) rep(patient.df[sm,"treated"], dims[[sm]])))
batch.labels <- Reduce(c, llply(samples, function(sm) rep(patient.df[sm,"label"], dims[[sm]])))

umap.res <- umap(all.mat[, hvfs], scale=TRUE)
df1 <- data.frame(umap1 = umap.res[,1], umap2 = umap.res[,2], sample.labels = sample.labels, treated.labels = treated.labels, batch.labels = batch.labels, index = 1:nrow(all.mat))
df1 <- merge(df1, anno.df[, c("index", "row.cluster")])
g1 <- ggplot(data = df1, aes(x = umap1, y = umap2, colour = sample.labels)) + geom_point() + facet_wrap(treated.labels ~ sample.labels)
g1.all <- ggplot(data = df1, aes(x = umap1, y = umap2, colour = sample.labels)) + geom_point() 
g1.all <- ggplot(data = df1, aes(x = umap1, y = umap2, colour = sample.labels)) + geom_point() + facet_wrap(~row.cluster)
g1.all <- ggplot(data = df1, aes(x = umap1, y = umap2, colour = batch.labels)) + geom_point() + facet_wrap(~batch.labels)

df1 <- data.frame(umap1 = umap.res[,1], umap2 = umap.res[,2], sample.labels = sample.labels, treated.labels = treated.labels)
#df1 <- subset(df1, treated.labels=="Untreated")
g1 <- ggplot(data = df1, aes(x = umap1, y = umap2, colour = sample.labels)) + geom_point() + facet_wrap(treated.labels~sample.labels)
g1.all <- ggplot(data = df1, aes(x = umap1, y = umap2, colour = sample.labels)) + geom_point() + facet_wrap(~treated.labels)

df2 <- data.frame(umap1 = umap.obj[["umap"]]@cell.embeddings[,1], umap2 = umap.obj[["umap"]]@cell.embeddings[,2], sample.labels = sample.labels, treated.labels = treated.labels)
g2 <- ggplot(data = df2, aes(x = umap1, y = umap2, colour = sample.labels)) + geom_point() + facet_wrap(treated.labels ~ sample.labels)
g2.all <- ggplot(data = df2, aes(x = umap1, y = umap2, colour = sample.labels)) + geom_point() + facet_wrap(~treated.labels)

annos <- c(rep("JP1127", dm), rep("2171", dm))
annos <- sample.labels


tiff("heatmap.tiff", width = 2 * 480, height = 2 * 480)
sample_cols = carto_pal(length(samples), "Safe")
names(sample_cols) <- names(samples)
treated_cols <- c("Treated" = "blue", "Untreated" = "black")

hm <- Heatmap(as.matrix(all.mat[,hvfs]), use_raster=TRUE, raster_device="tiff", row_km=10, column_km=12) + rowAnnotation(sample = sample.labels, treated = treated.labels, col = list(sample = sample_cols, treated = treated_cols))
hm <- draw(hm)
d <- dev.off()

row.clustering <- ldply(row_order(hm), .fun = function(elem) data.frame(index=elem))
colnames(row.clustering)[1] <- "row.cluster"
col.clustering <- ldply(column_order(hm), .fun = function(elem) data.frame(index=elem))
colnames(col.clustering)[1] <- "col.cluster"
anno.df <- data.frame(treated = treated.labels, sample = all.mat$orig.ident, spot = all.mat$spot, index = 1:length(treated.labels))
anno.df <- merge(anno.df, row.clustering)
table(anno.df$sample, anno.df$cluster)
table(anno.df$treated, anno.df$cluster)


g <- plot.cluster.fraction.by.annotation(umap.obj2[[]]$SCT_snn_res.0.7, umap.obj2[[]]$orig.ident, cols=sample_cols)

g.all.samples <- plot.cluster.fraction.by.annotation(anno.df$row.cluster, anno.df$sample, cols=sample_cols)

sub.anno.df <- subset(anno.df, treated == "Treated")
g.treated.samples <- plot.cluster.fraction.by.annotation(sub.anno.df$row.cluster, sub.anno.df$sample, cols=sample_cols)

sub.anno.df <- subset(anno.df, treated == "Untreated")
g.untreated.samples <- plot.cluster.fraction.by.annotation(sub.anno.df$row.cluster, sub.anno.df$sample, cols=sample_cols)

g.treatment <- plot.cluster.fraction.by.annotation(anno.df$row.cluster, anno.df$treated, cols=treated_cols)

g1 <- plot_grid(g.treatment, plot_grid(g.treated.samples, g.untreated.samples,ncol=1),ncol=2)
g2 <- plot_grid(g.all.samples, plot_grid(g.treated.samples, g.untreated.samples,ncol=1),ncol=2)
g3 <- plot_grid(g.treatment, g.all.samples, plot_grid(g.treated.samples, g.untreated.samples,ncol=1),ncol=3)

  
tbl <- reshape2::dcast(as.data.frame(table(sub.anno.df$treated, sub.anno.df$row.cluster)), formula=Var1~Var2)
tbl <- reshape2::dcast(as.data.frame(table(sub.anno.df$sample, sub.anno.df$row.cluster)), formula=Var1~Var2)
tbl <- reshape2::dcast(as.data.frame(table(umap.obj2[[]]$orig.ident, umap.obj2[[]]$SCT_snn_res.0.7)), formula=Var1~Var2)
rownames(tbl) <- tbl$Var1
tbl <- tbl[,!(colnames(tbl) %in% c("Var1"))]
tbl$Total <- rowSums(tbl)
per.tbl <- t(apply(tbl, 1, function(row) row / colSums(tbl)))
tbl <- rbind(tbl, Ratio = as.numeric(tbl["Treated",]) / as.numeric(tbl["Untreated",]))
tbl <- round(tbl,2)
#per.tbl <- round(per.tbl, 2)

tmp <- reshape2::melt(per.tbl)
colnames(tmp) <- c("Var1", "cluster", "fraction")
tmp$Var1 <- factor(tmp$Var1)
tmp$cluster <- as.character(tmp$cluster)
tmp$cluster <- factor(tmp$cluster, levels = c("Total", sort(as.numeric(unique(tmp$cluster)[unique(tmp$cluster) != "Total"]))))
entropies <- apply(per.tbl, 2, function(freqs) shannon.entropy(freqs))
entropy.df <- data.frame(cluster = names(entropies), entropy = as.numeric(entropies))
entropy.df$cluster <- factor(entropy.df$cluster, levels = levels(tmp$cluster))

g <- ggplot(data = tmp, aes(x = cluster, y = fraction, fill = Var1)) + geom_col()
sub <- subset(tmp, cluster=="Total")
sub <- sub[order(sub$Var1, decreasing=TRUE),]
for(frac in cumsum(sub$fraction)) {
  g <- g + geom_hline(yintercept = frac, linetype=2)
}


g <- g + ylab("Fraction of Spots") + xlab("Cluster") + labs(fill = NULL)
g <- g + theme(text = element_text(size=20))
g <- g + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

g <- ggplot(data = subset(mt.melted, orig.ident %in% mouse.ids), aes(x = orig.ident, y = value)) + facet_wrap(~ variable, scale="free_y") + geom_boxplot() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

g.ent <- ggplot(data = entropy.df, aes(x = cluster, y = entropy)) + geom_col() +
  ylab("H") +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.title.x = element_blank(), text = element_text(size = 20))

plot_grid(
  plot_grid(g.ent, g + theme(legend.position = "none"), ncol=1, align="v", rel_heights=c(1,9)),
  plot_grid(NULL, get_legend(g), ncol=1, rel_heights=c(1,9)), 
  rel_widths=c(7,3))

# Most clusters are sample specific
# Can we reduce the number of clusters?
table(umap.obj[[]]$seurat_clusters, umap.obj[[]]$orig.ident)
plts <- DimPlot(umap.obj, split.by="seurat_clusters", ncol=5, group.by="orig.ident")

rowSums(table(anno.df$treated, anno.df$cluster))
tiff("heatmap-treated.tiff")
Heatmap(as.matrix(all.mat[,names(sds)[order(sds, decreasing=TRUE)][1:50]]), use_raster=TRUE, raster_device="tiff") + rowAnnotation(treated = treated.labels, col = list(treated = treated_cols))
d <- dev.off()


smpl <- "SC2300228_JP9990"
obj <- filtered.objs[["SC2300228_JP9990"]]
#obj <- add.metadata.to.seurat.obj(obj, gsea.mats[[1]])
tmp <- subset(umap.obj2[[]], orig.ident=="SC2300228_JP9990")
rownames(tmp) <- gsub(rownames(tmp), pattern="_2_1", replacement="")
obj <- add.metadata.to.seurat.obj(obj, tmp)

table(umap.obj[[]]$seurat_clusters, umap.obj[[]]$orig.ident)

# Resolution of 0.1 has two major clusters in SC2300228_JP9990: upper right stromal region and everything else
# r = 0.4 has 3 major clusters: tumor (1), upper right stroma (urs) (11), and veins (17)
# r = 0.5 also ok -- has different mixing of stromal regions
# r = 0.6 also good: tumor (5), urs (11), veins (23)
# r = 0.7 also good: tumor (5), urs (11), veins (23)
# r = 0.8 might be best: tumor(8), veins (9 and 26), urs (22)
r <- 0.8
clustering <- paste0("SCT_snn_res.", r)
Idents(obj) <- clustering
nc <- length(unique(obj[[]][, clustering]))
SpatialDimPlot(obj, cells.highlight = CellsByIdentities(object = obj), facet.highlight = TRUE, ncol = ceiling(sqrt(nc)))

r <- 0.8
clustering <- paste0("SCT_snn_res.", r)
Idents(umap.obj2) <- clustering

table(umap.obj2[[]][, clustering], umap.obj2[[]]$orig.ident)

tbl <- table(umap.obj2[[]][, clustering], umap.obj2[[]]$orig.ident)
tbl[rownames(tbl) %in% c("8", "9", "22", "26"),]

SpatialDimPlot(umap.obj2, cells.highlight = CellsByIdentities(object = umap.obj2, ident=9), facet.highlight=TRUE, ncol = ceiling(sqrt(length(unique(umap.obj2[[]]$orig.ident)))))

ois <- unique(umap.obj2[[]]$orig.ident)
names(ois) <- ois

sub.objs <- 
  llply(ois,
        .fun = function(sm) subset(x = umap.obj2, subset = orig.ident == sm))

cluster.indx <- 8
plts <- SpatialDimPlot(umap.obj2, cells.highlight = CellsByIdentities(object = umap.obj2, ident=cluster.indx), combine=FALSE)
plts <- plts[unlist(lapply(ois, function(sm) any(Idents(sub.objs[[sm]]) == cluster.indx)))]
plot_grid(plotlist=plts, nrow=ceiling(sqrt(length(plts))))

plts <- 
  llply(ois,
        .fun = function(sm) {
          if(!(any(Idents(sub.objs[[sm]]) == 9))) { return(NULL) }
          SpatialDimPlot(sub.objs[[sm]], cells.highlight = CellsByIdentities(object = sub.objs[[sm]], ident=9), combine=FALSE)
        })

SpatialDimPlot(obj, group.by="SCT_snn_res.0.2")

obj <- filtered.objs[["SC2300228_JP9990"]]
#obj <- add.metadata.to.seurat.obj(obj, gsea.mats[[1]])
tmp <- subset(umap.obj[[]], orig.ident=="SC2300228_JP9990")
rownames(tmp) <- gsub(rownames(tmp), pattern="_2_1", replacement="")
obj <- add.metadata.to.seurat.obj(obj, tmp)



obj <- filtered.objs[[smpl]]
tmp <- subset(anno.df, sample==smpl)
rownames(tmp) <- tmp$spot
obj <- add.metadata.to.seurat.obj(obj, tmp)
p1<- SpatialDimPlot(obj, group.by="row.cluster", pt.size.factor = 1)
Idents(obj) <- "row.cluster"
SpatialDimPlot(obj, cells.highlight = CellsByIdentities(object = obj), facet.highlight = TRUE, ncol = 3)
table(anno.df$sample, anno.df$row.cluster)

meta.df <- anno.df[, c("sample", "spot", "row.cluster")]
colnames(meta.df) <- c("orig.ident", "spot", "row.cluster")
meta.df$spot.simple <- gsub(meta.df$spot, pattern="-1", replacement="")
o <- order(meta.df$spot.simple)
meta.df <- meta.df[o,]
stopifnot(!any(duplicated(meta.df[, c("orig.ident", "spot.simple")])))

meta.obj.df <- umap.obj2[[]]
meta.obj.df$spot <- rownames(meta.obj.df)
meta.obj.df$spot.simple <- unlist(lapply(meta.obj.df$spot, function(str) unlist(strsplit(str, split="-"))[1]))

norig <- nrow(meta.df)
meta.df <- meta.df[, !(colnames(meta.df) %in% c("spot"))]
meta.df <- merge(meta.df, meta.obj.df[, c("spot", "spot.simple", "orig.ident")])
stopifnot(norig == nrow(meta.df))
rownames(meta.df) <- meta.df$spot
meta.df <- meta.df[, !(colnames(meta.df) %in% c("spot"))]
umap.obj3 <- add.metadata.to.seurat.obj(umap.obj2, meta.df)

# Interesting gsea clusters:
# 9: vasculature
# 1: upper right stroma (interesting)
# 7: tumor (only shared with 9990 and 2171) -- mostly a treated feature
# 5: IGKC?
cluster.indx <- 5
Idents(umap.obj3) <- "row.cluster"
plts <- SpatialDimPlot(umap.obj3, cells.highlight = CellsByIdentities(object = umap.obj3, ident=cluster.indx), combine=FALSE)
plts <- plts[unlist(lapply(ois, function(sm) any(subset(meta.df, orig.ident == sm)$row.cluster == cluster.indx)))]
plot_grid(plotlist=plts, nrow=ceiling(sqrt(length(plts))))

p<- SpatialDimPlot(obj, group.by="seurat_clusters")
#p$mapping$alpha <- 25 # can set any number here
p$layers[[1]]$aes_params$alpha <- 0.5
p

p1<- SpatialDimPlot(obj, group.by="row.cluster", pt.size.factor = 1)
#p$mapping$alpha <- 25 # can set any number here
p1$layers[[1]]$aes_params$alpha <- 0.5
p1

p2<- SpatialDimPlot(obj, group.by="row.cluster")
#p$mapping$alpha <- 25 # can set any number here
p2$layers[[1]]$aes_params$alpha <- 1
p2

g1 + p1 + p2
g1 <- plot.hne(obj)
g1 + p

Idents(obj) <- "row.cluster"
SpatialDimPlot(obj, cells.highlight = CellsByIdentities(object = obj, idents = 1:10), facet.highlight = TRUE, ncol = 3)

# to do
# 2. make plot of proportion of sample vs cluster
#    2a. for gsea
#    2b. for sct
# 1. plot clusters on h&e (also separate plot for each cluster)
#    1a. for gsea -- does it correspond to stroma?
#.   1b. for sct
# 3. try to get smaller number of clusters with sct
# 4. need bulk 
# 5. plot gsea cluster for stroma across samples (use interactive plot)
# 5. are gsea clusters
# 1. umap of sct
# 2. cluster (10) heatmap?
# 3. cluster (10?) umap?
# 4. heatmap treated vs non-treated
# 5. heatmap dendrogram of labels

png("heatmap.png")
Heatmap(as.matrix(all.mat[,names(sds)[order(sds, decreasing=TRUE)][1:50]]), use_raster=TRUE, raster_device="png") + rowAnnotation(sample = annos)
d <- dev.off()
```



```{r}
nms <- names(filtered.objs)[1:8]
names(nms) <- nms
cnt.mdl.fits <-
  llply(nms,
        .fun = function(nm) {
          nm.dir <- paste0(analysis_dir, "/count-model-fits/", nm)
          dir.create(nm.dir, recursive=TRUE)
          print(nm)
          cntmat <- GetAssayData(filtered.objs[[nm]], assay="Spatial", slot="counts")
          exposure <- log(colSums(cntmat))
          genes <- rownames(cntmat)
          mxs <- rowMaxs(cntmat)
          names(mxs) <- genes
          mns <- rowMins(cntmat)
          names(mns) <- genes
          
          cnts0 <- rowSums(cntmat==0)
          cnts1 <- rowSums(cntmat==1)
          cnts2 <- rowSums(cntmat>1)
          flag <- (cnts0 > 10) & (cnts1 == 0) & (cnts2 > 10)
          flag <- (cnts0 > 40) & (cnts2 > 10)
          #mxs <- mxs[mns == 0]
          mxs <- mxs[flag]
          
          mxs <- mxs[!grepl(names(mxs), pattern="^RP[L|S]") & !grepl(names(mxs), pattern="^MT")]
          mxs <- mxs[order(mxs, decreasing=TRUE)]
          top.genes <- names(mxs)[1:20]
          top.genes <- unique(c(top.genes, "EPCAM", "IGKC", "COL1A1"))
          top.genes <- top.genes[top.genes %in% rownames(cntmat)]
          names(top.genes) <- top.genes
          print(top.genes)
          gene.fits <- 
            llply(top.genes,
                  .parallel = FALSE,
                  .fun = function(gene) {
                    # print(gene)
                    rds.file <- paste0(nm.dir, "/", "model-fit-", nm, "-", gene, ".rds")
                    if(!file.exists(rds.file)) {
                      y <- cntmat[gene,]
                      gexpr <- data.frame(y=y, exposure=exposure)
                      model_fit <- fit_count_models(gexpr)
                      saveRDS(model_fit, file = rds.file)
                    }
                    readRDS(rds.file)
                  })
          
        })
```

```{r}
cmp.mdl.fits <-
  llply(nms,
        .fun = function(nm) {

          model.fits.dir <- paste0(analysis_dir, "/count-model-fits/", nm)
          fit.files <- list.files(model.fits.dir)
          top.genes <- gsub(x = fit.files, pattern=paste0("model-fit-", nm, "-"), replacement="")
          top.genes <- gsub(x = top.genes, pattern=".rds", replacement="")
          
          nm.dir <- paste0(analysis_dir, "/compare-model-fits/", nm)
          dir.create(nm.dir, recursive=TRUE)
          
          names(top.genes) <- top.genes
          print(top.genes)
          gene.comps <- 
            llply(top.genes,
                  .parallel = FALSE,
                  .fun = function(gene) {
                    print(gene)
                    rds.file <- paste0(nm.dir, "/", "compare-fit-", nm, "-", gene, ".rds")
                    if(!file.exists(rds.file)) {
                      model.rds.file <- paste0(model.fits.dir, "/", "model-fit-", nm, "-", gene, ".rds")
                      stopifnot(file.exists(model.rds.file))
                      model_fit <- readRDS(model.rds.file)
                      # model_fit <- cnt.mdl.fits[[nm]][[gene]]
                      model_compare <- compare_count_models(model_fit)
                      saveRDS(model_compare, file = rds.file)
                    }
                    readRDS(rds.file)
                  })
        })
```

```{r}
gene.summaries <-
  ldply(cmp.mdl.fits,
        .fun = function(sample.fits) {
          ret <- ldply(sample.fits,
                       .fun = function(gene.fit) {
                         data.frame(model.num = select_model(gene.fit, margin=1))
                       })
          colnames(ret)[1] <- "gene"
          ret
        })
colnames(gene.summaries)[1] <- "sample"
# ?select_model defines the following:
trans.df <- data.frame(model.num = c(1,2,3,4), model.name = c("P", "NB", "ZIP", "ZINB"))
gene.summaries <- merge(gene.summaries, trans.df)
```


```{r}
stop("stop")
```

```{r}
p_load(matrixStats)
nms <- names(filtered.objs)
names(nms) <- nms
cnt.mdl.fits <-
  llply(nms,
        .fun = function(nm) {
          nm.dir <- paste0(analysis_dir, "/count-model-fits/", nm)
          dir.create(nm.dir, recursive=TRUE)
          print(nm)
          cntmat <- GetAssayData(filtered.objs[[nm]], assay="Spatial", slot="counts")
          exposure <- log(colSums(cntmat))
          genes <- rownames(cntmat)
          mxs <- rowMaxs(cntmat)
          names(mxs) <- genes
          mns <- rowMins(cntmat)
          names(mns) <- genes
          
          cnts0 <- rowSums(cntmat==0)
          cnts1 <- rowSums(cntmat==1)
          cnts2 <- rowSums(cntmat>1)
          flag <- (cnts0 > 10) & (cnts1 == 0) & (cnts2 > 10)
          flag <- (cnts0 > 40) & (cnts2 > 10)

          
          #mxs <- mxs[mns == 0]
          mxs <- mxs[flag]
          mxs <- mxs[!grepl(names(mxs), pattern="^RP[L|S]") & !grepl(names(mxs), pattern="^MT")]
          mxs <- mxs[order(mxs, decreasing=TRUE)]
          top.genes <- names(mxs)[1:20]
          
          names(top.genes) <- top.genes
          print(top.genes)
          
        })
```


```{r}
stop("stop")
```

```{r}
p_load(matrixStats)
nms <- names(filtered.objs)[1:8]
names(nms) <- nms
cnt.mdl.fits <-
  llply(nms,
        .fun = function(nm) {
          nm.dir <- paste0(analysis_dir, "/count-model-fits/", nm)
          dir.create(nm.dir, recursive=TRUE)
          print(nm)
          cntmat <- GetAssayData(filtered.objs[[nm]], assay="Spatial", slot="counts")
          exposure <- log(colSums(cntmat))
          genes <- rownames(cntmat)
          mxs <- rowMaxs(cntmat)
          names(mxs) <- genes
          mns <- rowMins(cntmat)
          names(mns) <- genes
          
          cnts0 <- rowSums(cntmat==0)
          cnts1 <- rowSums(cntmat==1)
          cnts2 <- rowSums(cntmat>1)
          flag <- (cnts0 > 10) & (cnts1 == 0) & (cnts2 > 10)
          flag <- (cnts0 > 40) & (cnts2 > 10)

          
          #mxs <- mxs[mns == 0]
          mxs <- mxs[flag]
          mxs <- mxs[!grepl(names(mxs), pattern="^RP[L|S]") & !grepl(names(mxs), pattern="^MT")]
          mxs <- mxs[order(mxs, decreasing=TRUE)]
          top.genes <- names(mxs)[1:20]
          top.genes <- unique(c(top.genes, "IGKC"))
          top.genes <- top.genes[top.genes %in% rownames(cntmat)]
          
          names(top.genes) <- top.genes
          print(top.genes)
          
          gene.fits <- 
            llply(top.genes,
                  .parallel = FALSE,
                  .fun = function(gene) {
                    # print(gene)
                    rds.file <- paste0(nm.dir, "/", "model-fit-", nm, "-", gene, ".rds")
                    if(!file.exists(rds.file)) {
                      y <- cntmat[gene,]
                      gexpr <- data.frame(y=y, exposure=exposure)
                      model_fit <- suppressMessages(fit_count_models(gexpr))
                      saveRDS(model_fit, file = rds.file)
                    }
                    readRDS(rds.file)
                  })
          
        })
```

```{r}
cmp.mdl.fits <-
  llply(nms,
        .fun = function(nm) {

          model.fits.dir <- paste0(analysis_dir, "/count-model-fits/", nm)
          fit.files <- list.files(model.fits.dir)
          top.genes <- gsub(x = fit.files, pattern=paste0("model-fit-", nm, "-"), replacement="")
          top.genes <- gsub(x = top.genes, pattern=".rds", replacement="")
          
          nm.dir <- paste0(analysis_dir, "/compare-model-fits/", nm)
          dir.create(nm.dir, recursive=TRUE)
          
          names(top.genes) <- top.genes
          print(top.genes)
          gene.comps <- 
            llply(top.genes,
                  .parallel = FALSE,
                  .fun = function(gene) {
                    print(gene)
                    rds.file <- paste0(nm.dir, "/", "compare-fit-", nm, "-", gene, ".rds")
                    if(!file.exists(rds.file)) {
                      model_fit <- cnt.mdl.fits[[nm]][[gene]]
                      model_compare <- suppressMessages(compare_count_models(model_fit))
                      saveRDS(model_compare, file = rds.file)
                    }
                    readRDS(rds.file)
                  })
        })
```

```{r}
stop("stop")
```

```{r}
gene.summaries <-
  ldply(cmp.mdl.fits,
        .fun = function(sample.fits) {
          ret <- ldply(sample.fits,
                       .fun = function(gene.fit) {
                         data.frame(model.num = select_model(gene.fit, margin=1))
                       })
          colnames(ret)[1] <- "gene"
          ret
        })
colnames(gene.summaries)[1] <- "sample"
# ?select_model defines the following:
trans.df <- data.frame(model.num = c(1,2,3,4), model.name = c("P", "NB", "ZIP", "ZINB"))
gene.summaries <- merge(gene.summaries, trans.df)
```

```{r}
stop("stop")
```


```{r}
ff.obj <- filtered.objs[[1]]
ff.umi <- GetAssayData(ff.obj, assay="Spatial", slot="counts")
```


```{r}

cntmat <- GetAssayData(filtered.objs[[1]], assay="Spatial", slot="counts")
gsymb <- rownames(cntmat)
exposure <- log(colSums(cntmat))
gg <- "EPCAM"
y <- cntmat[gg,]
gexpr <- data.frame(y=y, exposure=exposure)
model_fit <- fit_count_models(gexpr)
elpd_loo <- compare_count_models(model_fit)
select_model(elpd_loo, margin=1)
```


```{r}
indices <- 1:nrow(patient.df)
names(indices) <- patient.df$sample
p_load(ggcorrplot)
l_ply(indices,
       .fun = function(i) {
           sample.name <- patient.df[i, "sample"]
           treatment.status <- patient.df[i, "treated"]
           obj <- filtered.objs[[sample.name]]
           DefaultAssay(obj) <- "Spatial"
           genes <- c("IGKC", "FTH1", "EEF1A1", "RPLP1", "MT-CO2", "GAPDH", "ACTB")
           
           g <- plot.features(obj, features = genes, include.hne=TRUE, include.umi.cnts=TRUE, slot="counts")
           
           file.name <- paste0(paste0("top-genes-spatial-cor-", treatment.status, "-", sample.name))
           title <- paste0(sample.name, " (", treatment.status, ")")
           g <- add.title.to.plot(g, title, rel_heights = c(0.05, 1))
           
           png(paste0(plots_dir, "/", file.name, ".png"))
           print(g)
           d <- dev.off()
           
           cnts <- GetAssayData(obj, assay="Spatial", slot="counts")[genes,]
           vec <- data.frame(vec = obj[[]]$nCount_Spatial)
           names(vec) <- "UMIs"
           cnts <- rbind(cnts, t(vec))
           cr <- cor(as.matrix(t(cnts)))
           g <- ggcorrplot(cr, tl.cex=20) + theme(text = element_text(size=20))
           
           file.name <- paste0(paste0("top-genes-cor-heatmap-", treatment.status, "-", sample.name))
           title <- paste0(sample.name, " (", treatment.status, ")")
           g <- add.title.to.plot(g, title, rel_heights = c(0.05, 1))
           
           png(paste0(plots_dir, "/", file.name, ".png"))
           print(g)
           d <- dev.off()
           
       })
```



```{r}

```


```{r}
# Plot Epi, stromal, and immune deconvolution
sub.dir <- paste0(plots_dir, "/spatial-deconvolve/")
dir.create(sub.dir, recursive=TRUE)
for(i in 1:nrow(patient.df)) {
  sample <- patient.df[i, "sample"]
  treated <- patient.df[i, "treated"]
  g <- plot.features(filtered.objs[[sample]], include.hne = TRUE, include.umi.cnts = TRUE, features=c("Epithelial", "Stromal", "Immune"), legend.limits = list(c(0,1),c(0,1),c(0,1)))
  g <- g + ggtitle(paste0(sample, " (", treated, ")")) + 
    theme(plot.title = element_text(hjust = 0.5, size = 20))
  file <- paste0(sub.dir, "/spatial-deconvolve-", sample, "-", treated, ".png")
  print(file)
  png(file, width = 1.4 * 480, height = 325)
  print(g)
  d <- dev.off()
}
```

```{r}
# Plot cytokeratins
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3127435/
# TNBC tumor subtypes display differential expression of both basal-like cytokeratins (KRT5, KRT6A, KRT6B, KRT14, KRT16, KRT17, KRT23, and KRT81) and luminal cytokeratins (KRT7, KRT8, KRT18, and KRT19)
luminal.cytos <- c("KRT7", "KRT8", "KRT18", "KRT19")
basal.cytos <- c("KRT5", "KRT6A", "KRT6B", "KRT14", "KRT16", "KRT17", "KRT23", "KRT81")


sub.dir <- paste0(plots_dir, "/cytokeratins/")
dir.create(sub.dir, recursive=TRUE)
for(i in 1:nrow(patient.df)) {
  sample <- patient.df[i, "sample"]
  treated <- patient.df[i, "treated"]
  obj <- filtered.objs[[sample]]
  DefaultAssay(obj) <- "Spatial"
  g.luminal <- plot.features(obj, features=luminal.cytos, slot="counts", include.umi.cnts=TRUE, include.hne=TRUE, feature.names=paste0(luminal.cytos, "\nRaw\nCounts"))
  g.luminal <- g.luminal + ggtitle(paste0("Luminal Cytokeratins (", treated, " Sample: ", sample, ")")) +
    theme(plot.title = element_text(hjust = 0.5, size=20))
  g.basal <- plot.features(obj, features=basal.cytos, feature.names=paste0(basal.cytos, "\nRaw\nCounts"))
  g.basal <- g.basal + ggtitle(paste0("Basal Cytokeratins (", treated, " Sample: ", sample, ")")) +
    theme(plot.title = element_text(hjust = 0.5, size=20))
  g <- plot_grid(g.luminal, g.basal, nrow=2, rel_heights=c(2,3))
  file <- paste0(sub.dir, "/cytokeratin-", sample, "-", treated, ".png")
  print(file)
  # png(file, width = 3 * 480, height = 350)
  png(file, width = 1.5 * 480, height = 1.75 * 480)
  print(g)
  d <- dev.off()
}
``` 


```{r}
# MISTy analysis
p_load(mistyR)
p_load(future)

# data manipulation
p_load(dplyr)
p_load(purrr)
p_load(distances)


plan(multisession)
p_load(tidyverse)
setwd("/home/whitebr/local/gsl-2.5/lib/")

```

```{r}
# Modified from STDeconvolve, just to return the fit m
my.getOverdispersedGenes <-
function (counts, gam.k = 5, alpha = 0.05, plot = FALSE, use.unadjusted.pvals = FALSE, 
    do.par = TRUE, max.adjusted.variance = 1000, min.adjusted.variance = 0.001, 
    verbose = TRUE, details = FALSE) 
{
    if (!any(class(counts) %in% c("dgCMatrix", "dgTMatrix"))) {
        if (verbose) {
            message("Converting to sparse matrix ...")
        }
        counts <- Matrix::Matrix(counts, sparse = TRUE)
    }
    mat <- Matrix::t(counts)
    if (verbose) {
        message("Calculating variance fit ...")
    }
    dfm <- log(Matrix::colMeans(mat))
    dfv <- log(apply(mat, 2, var))
    names(dfm) <- names(dfv) <- colnames(mat)
    df <- data.frame(m = dfm, v = dfv)
    vi <- which(is.finite(dfv))
    if (length(vi) < gam.k * 1.5) {
        gam.k = 1
    }
    if (gam.k < 2) {
        if (verbose) {
            message("Using lm ...")
        }
        m <- lm(v ~ m, data = df[vi, ])
    }
    else {
        if (verbose) {
            message(paste0("Using gam with k=", gam.k, "..."))
        }
        fm <- as.formula(sprintf("v ~ s(m, k = %s)", gam.k))
        m <- mgcv::gam(fm, data = df[vi, ])
    }
    df$res <- -Inf
    df$res[vi] <- resid(m, type = "response")
    n.cells <- ncol(mat)
    n.obs <- nrow(mat)
    df$lp <- as.numeric(pf(exp(df$res), n.obs, n.obs, lower.tail = FALSE, 
        log.p = TRUE))
    df$lpa <- STdeconvolve:::bh.adjust(df$lp, log = TRUE)
    df$qv <- as.numeric(qchisq(df$lp, n.cells - 1, lower.tail = FALSE, 
        log.p = TRUE)/n.cells)
    if (use.unadjusted.pvals) {
        ods <- which(df$lp < log(alpha))
    }
    else {
        ods <- which(df$lpa < log(alpha))
    }
    if (verbose) {
        message(paste0(length(ods), " overdispersed genes ... "))
    }
    df$gsf <- geneScaleFactors <- sqrt(pmax(min.adjusted.variance, 
        pmin(max.adjusted.variance, df$qv))/exp(df$v))
    df$gsf[!is.finite(df$gsf)] <- 0
    if (plot) {
        if (do.par) {
            par(mfrow = c(1, 2), mar = c(3.5, 3.5, 2, 0.5), mgp = c(2, 
                0.65, 0), cex = 1)
        }
        graphics::smoothScatter(df$m, df$v, main = "", xlab = "log10[ magnitude ]", 
            ylab = "log10[ variance ]")
        grid <- seq(min(df$m[vi]), max(df$m[vi]), length.out = 1000)
        graphics::lines(grid, predict(m, newdata = data.frame(m = grid)), 
            col = "blue")
        if (length(ods) > 0) {
            graphics::points(df$m[ods], df$v[ods], pch = ".", 
                col = 2, cex = 1)
        }
        graphics::smoothScatter(df$m[vi], df$qv[vi], xlab = "log10[ magnitude ]", 
            ylab = "", main = "adjusted")
        graphics::abline(h = 1, lty = 2, col = 8)
        if (is.finite(max.adjusted.variance)) {
            graphics::abline(h = max.adjusted.variance, lty = 2, 
                col = 1)
        }
        graphics::points(df$m[ods], df$qv[ods], col = 2, pch = ".")
    }
    norm.mat <- counts * df$gsf
    if (!details) {
        return(colnames(mat)[ods])
    }
    else {
        return(list(mat = norm.mat, ods = colnames(mat)[ods], 
            df = df, m = m))
    }
}
```

```{r}
ggplot_smooth_scatter <- function(data, mapping, pwr = 0.25, n = 200){
      p <- ggplot(data = data, mapping = mapping) + 
        stat_density2d(aes(fill=..density..^pwr), geom="tile", contour = FALSE, n = n) +
        scale_fill_continuous("", low = "white", high = "dodgerblue4")
##        scale_fill_gradientn(colours=rainbow(100))
      p
}

```


```{r}
cols <- llply(filtered.objs, .fun = function(obj) rowSums(GetAssayData(obj, slot="counts", assay="Spatial")))
pb <- do.call(cbind, cols)
pb <- pb[rowSums(pb) > 0,]
pb <- pb[, patient.df$sample]
library(edgeR)
cpm.pb <- edgeR::cpm(pb, log=FALSE)
```

```{r}
# Plot results with STDeconvolve getOverdispersedGenes
bar <- my.getOverdispersedGenes(as.matrix(cpm.pb), plot=FALSE, details=TRUE)
df <- bar$df
g <- ggplot_smooth_scatter(df, aes(x = m, y = v))
g <- g + geom_point(data = df[bar$ods,], aes(x = m, y = v))
vi <- which(is.finite(df$v))
grid <- seq(min(df$m[vi]), max(df$m[vi]), length.out = 1000)
g <- g + geom_line(data = data.frame(x = grid, y = predict(bar$m, newdata = data.frame(m = grid))), aes(x = x, y = y))
g <- g + xlab("Log Mean Counts") + ylab("Log Variance Counts")
```
```{r}
# Always calculate the variable genes using only one sample per patietn.
# Do it with and without a batch variable
pb.one.sample <- pb[, one.sample.per.patient.batch.2.bias.df$sample]
cpm.pb.one.sample <- edgeR::cpm(pb.one.sample, log=FALSE)
d <- DGEList(counts=pb.one.sample)
d <- estimateCommonDisp(d)
meanvar <- plotMeanVar(d, show.raw.vars = TRUE, NBline=TRUE)
common.dispersion <- d$common.dispersion
nb.var <- meanvar$means + (meanvar$means^2) * common.dispersion
diff.var <- meanvar$vars - nb.var
diff.var <- diff.var[order(diff.var, decreasing=TRUE)]
# diff.var <- diff.var[diff.var > 0]
# table(names(diff.var)[1:100] %in% bar$ods)

d <- DGEList(counts=pb.one.sample, group=as.character(one.sample.per.patient.batch.2.bias.df$label))
d <- estimateCommonDisp(d)
meanvar <- plotMeanVar(d, show.raw.vars = TRUE, NBline=TRUE)
common.dispersion <- d$common.dispersion
nb.var <- meanvar$means + (meanvar$means^2) * common.dispersion
diff.var.batch <- meanvar$vars - nb.var
diff.var.batch <- diff.var.batch[order(diff.var.batch, decreasing=TRUE)]
```

```{r}
#stop("stop")
```


```{r}
run.df <- expand.grid(top.genes = c("batch", "no-batch"), n.top = c(nrow(pb), 100, 200, 500, 1000, 2000), samples=c("all", "one-per-patient"), batch=c("harmony", "no-harmony"))

# Harmony has a step with k=10 clusters harcoded. Need to remove if we are using one-sample-per-patient
run.df <- subset(run.df, !((samples == "one-per-patient") & (batch == "harmony")))
red.dims <-
  llply(1:nrow(run.df),
        .parallel = FALSE,
        .fun = function(i) {
          print(i)
          # i <- 25
          top.genes <- run.df[i, "top.genes"]
          n.top <- run.df[i, "n.top"]
          samples <- run.df[i, "samples"]
          batch <- run.df[i, "batch"]
          n.top <- min(n.top, nrow(pb))
          file.name <- paste0("top-genes-", top.genes, "-n-top-", n.top, "-samples-", samples, "-batch-", batch)
          rds.file <- paste0(analysis_dir, "/", file.name, ".rds")
          if(file.exists(rds.file)) { return(readRDS(rds.file)) }
          print(file.name)
          
          gns <- names(diff.var)[1:n.top]
          if(top.genes == "batch") { gns <- names(diff.var.batch)[1:n.top] }
          mat <- cpm.pb[gns,]
          meta.df <- patient.df
          if(samples == "one-per-patient") { 
            meta.df <- one.sample.per.patient.batch.2.bias.df
            mat <- cpm.pb.one.sample[gns,] 
          }
          mat <- mat[rowSums(mat) > 0, ]
          if(batch == "harmony") {
            mat <- HarmonyMatrix(as.matrix(mat), meta.df, "label", do_pca=FALSE)
          }
          # Set n_neighbors small because of small dataset size
          umap.res <- umap(t(mat), scale=TRUE, n_neighbors = 4)
          colnames(umap.res) <- paste0("umap", 1:ncol(umap.res))
          umap.res <- merge(umap.res, meta.df, by = "row.names")
          ret <- list("umap.res" = umap.res, genes = gns, top.genes = top.genes, n.top = n.top, samples = samples, batch = batch)
          saveRDS(ret, file = rds.file)
          ret
        })

```


```{r}
geom.text.vs.theme.ratio <- 14/5
for(i in 1:length(red.dims)) {
  print(i)
obj <- red.dims[[i]]
df <- obj[["umap.res"]]
old.layout <- TRUE
title <- "UMAP of "
if(obj$batch == "harmony") { title <- paste0(title, "Harmony-corrected CPMs\n(")} else { title <- paste0(title, "uncorrected CPMs\n(")}
if(obj$n.top == nrow(pb)) { 
  title <- paste0(title, "all genes)") 
} else { 
  title <- paste0(title, obj$n.top, " most variable genes, selected")
  if(obj$top.genes == "batch") { title <- paste0(title, " following ")} else { title <- paste0(title, " without ")}
  title <- paste0(title, "batch correction)")
}
if(old.layout) { title <- paste0("Batch: ", obj$batch, "; n.top: ", obj$n.top, " (", obj$top.genes, ")") }
pt.sz <- 2
if(old.layout) { pt.sz <- 1 }
p_load(ggrepel)
g1 <- ggplot(data = df, aes(x = umap1, y = umap2, colour = treated)) + geom_point(size = pt.sz)
if(old.layout) {
  g1 <- g1 + geom_text_repel(data = df, aes(x = umap1, y = umap2, label = treated))
}
if(!old.layout) {
  g1 <- g1 + geom_text_repel(data = df, aes(x = umap1, y = umap2, label = treated), size = 5, show.legend = FALSE)
  g1 <- g1 + theme(text = element_text(size = 20), plot.title = element_text(hjust = 0.5)) + labs(colour = "Status")
  g1 <- g1 + ggtitle("Labeled by Status")
}

g2 <- ggplot(data = df, aes(x = umap1, y = umap2, colour = treated)) + geom_point(size = pt.sz)
if(old.layout) {
  g2 <- g2 + geom_text_repel(data = df, aes(x = umap1, y = umap2, label = patient))
}
if(!old.layout) {
  g2 <- g2 + geom_text_repel(data = df, aes(x = umap1, y = umap2, label = patient), size = 5, show.legend = FALSE)
  g2 <- g2 + theme(text = element_text(size = 20), plot.title = element_text(hjust = 0.5)) + labs(colour = "Status")
  g2 <- g2 + ggtitle("Labeled by Patient ID")
}

g3 <- ggplot(data = df, aes(x = umap1, y = umap2, colour = treated)) + geom_point(size = pt.sz)
if(old.layout) {
  g3 <- g3 + geom_text_repel(data = df, aes(x = umap1, y = umap2, label = label))
}
if(!old.layout) {
  g3 <- g3 + geom_text_repel(data = df, aes(x = umap1, y = umap2, label = label), size = 5, show.legend = FALSE)
  g3 <- g3 + theme(text = element_text(size = 20), plot.title = element_text(hjust = 0.5)) + labs(colour = "Status")
  g3 <- g3 + ggtitle("Labeled by Batch")
}

if(old.layout) {
  g.tot <- plot_grid(g1, g2, g3, nrow=2)
} else {
  g.tot <- plot_grid(g2, g3, nrow=1)
}
#grid.arrange(g1,g2,g3,nrow=2)

g.tot <- add.title.to.plot(g.tot, title, rel_heights=c(0.2, 1), size = 25)
file.name <- paste0("umap-batch-", obj$batch, "-n-top-", obj$n.top, "-", obj$top.genes, "-", obj$samples)
if(old.layout) {
  file.name <- paste0(file.name, "-old")
  png(paste0(plots_dir, "/", file.name, ".png"))
} else {
  png(paste0(plots_dir, "/", file.name, ".png"), width =  2 * 480)
}
print(g.tot)
d <- dev.off()
}
```


```{r}
library(uwot)
top.genes <- names(diff.var)[1:100]
# NB: not using PCA, since we have so few samples (nPCs <= # samples)
umap.pb <- umap(t(cpm.pb[top.genes,]), scale=TRUE)
plot(umap.pb[,1], umap.pb[,2])
text(umap.pb[,1], umap.pb[,2], patient.df[colnames(pb),"label"])
text(umap.pb[,1], umap.pb[,2], patient.df[colnames(pb),"treated"])
#text(umap.pb[,1], umap.pb[,2], colames(pb))
```

```{r}
foo <- HarmonyMatrix(as.matrix(cpm.pb[top.genes,]), patient.df, "batch.var", do_pca=FALSE)
umap.pb <- umap(t(foo), scale=TRUE)
plot(umap.pb[,1], umap.pb[,2])
```


```{r}
#stop("stop")
```

```{r}
p_load(moments)
p_load(qvalue)
tryCatch(source("https://raw.githubusercontent.com/saketkc/scRNA_NB_comparison/master/code/01_run_glm.R"),
         error = function(e) print(e))
```
```{r}
source("/home/whitebr/cancer-cube-st-pilot-ffpe-ff/fit-utils.R")
```


```{r}
if(FALSE) {
#sample.name <- "SC2200259_9990"
sample.name <- "SC2200260_9990"
for(sample.name in names(filtered.objs)) {
  # sample.name <- "SC2300228_JP9990"
  print(sample.name)
obj <- filtered.objs[[sample.name]]
rctd.df <- format.rctd.output_(rctds[[sample.name]])
rctd.df <- rctd.df[, !(colnames(rctd.df) %in% c("x", "y"))]
expr <- GetAssayData(obj, assay="SCT", slot="counts")

colnames(rctd.df) <- make.names(colnames(rctd.df))
colnames(rctd.df) <- gsub(colnames(rctd.df), pattern="_", replacement=".")
common <- intersect(colnames(expr), rownames(rctd.df))
expr <- expr[, common]
rctd.df <- rctd.df[common, ]
obj <- obj[, common]
obj[["SCT"]] <- CreateAssayObject(data = rbind(expr, t(rctd.df)))

#slide.markers <- c("IGKC", colnames(rctd.df))
slide.markers <- colnames(rctd.df)
pos <- obj[[]][,c("row","col")]
expr <- GetAssayData(obj, assay="SCT", slot="data")
expr <- expr[rownames(expr) %in% slide.markers,] %>% t() %>%
    as_tibble(rownames = NA)
# expr <- extract_seurat_data(obj, "SCT", pos)
misty.views <- create_initial_view(expr)
#misty.views <- misty.views %>% add_juxtaview(pos, neighbor.thr = 3)
#names(misty.views)[length(misty.views)] <- "juxtaview.igkc_3"
#misty.views[[length(misty.views)]]$abbrev <- "juxta.igkc_3"
misty.views <- misty.views %>% add_paraview(pos, l = 9, zoi = 1)
names(misty.views)[length(misty.views)] <- "paraview.ct_9"
misty.views[[length(misty.views)]]$abbrev <- "para.ct_9"
res <- run_misty(misty.views, results.folder = paste0(analysis_dir, "misty-cell-type-only-", sample.name))
#%>% collect_results()
}
}
```

```{r}
net <- get_progeny(organism = 'human', top = 100)

common.genes <- Reduce(intersect, lapply(filtered.objs, function(obj) rownames(obj)))

net.sub <- subset(net, target %in% common.genes)

# Get ligands from omnipath
icn <- import_intercell_network()
icn.ligand <- subset(icn, category_intercell_source == "ligand")
# Find the highest confident 100 ligands 
hc.ligands <-
  ddply(as.data.frame(icn.ligand[, c("source_genesymbol", "consensus_score_intercell_source")]),
        .variables = c("source_genesymbol"),
        .fun = function(df) {
          data.frame(score = max(df$consensus_score_intercell_source))
        })
hc.ligands <- hc.ligands[order(hc.ligands$score, decreasing=TRUE),]
colnames(hc.ligands) <- c("gene", "score")
hc.ligands <- subset(hc.ligands, gene %in% common.genes)

net.sub.no.ligands <- subset(net.sub, !(target %in% hc.ligands$gene))

#p_load(sparseMatrixStats)
avg.max.lig.expr <- 
  ldply(filtered.objs,
        .fun = function(obj) {
          print("here")
          # vec <- apply(as.matrix(GetAssayData(obj, assay="Spatial", slot="counts")),1,max)[hc.ligands$gene]
          # vec <- rowMaxs(GetAssayData(obj, assay="Spatial", slot="counts"))[hc.ligands$gene]
          vec <- apply(as.matrix(GetAssayData(obj, assay="Spatial", slot="counts")[hc.ligands$gene,]),1,max)
        })
colnames(avg.max.lig.expr)[1] <- "sample"
rownames(avg.max.lig.expr) <- avg.max.lig.expr$sample
avg.max.lig.expr <- avg.max.lig.expr[, !(colnames(avg.max.lig.expr) %in% c("sample"))]
sms <- colSums(avg.max.lig.expr)
sms <- sms[order(sms, decreasing=TRUE)]
top.ligands <- names(sms)[1:100]
```

```{r}
cpms <-
  llply(filtered.objs,
        .fun = function(obj) {
          mat <- GetAssayData(obj, assay="Spatial", slot="counts")
          norm.mat <- edgeR::cpm(as.matrix(mat), log=FALSE)
          norm.mat
        })
```

```{r}
l.cpms <-
  llply(filtered.objs,
        .fun = function(obj) {
          mat <- GetAssayData(obj, assay="Spatial", slot="counts")
          norm.mat <- edgeR::cpm(as.matrix(mat), log=TRUE)
          norm.mat
        })
```

```{r}
nms <- names(filtered.objs)
names(nms) <- nms
tmm.cpms <-
    llply(nms,
        .fun = function(nm) {
          print(nm)
          obj <- filtered.objs[[nm]]
          rds.file <- paste0(analysis_dir, "/", "tmm-cpm-", nm, ".rds")
          if(file.exists(rds.file)) { return(readRDS(rds.file)) }
          cnt.mat <- GetAssayData(obj, assay="Spatial", slot="counts")
          ## DGEList is very slow
          #y <- DGEList(counts=cnt.mat)
          #y <- calcNormFactors(y)
          #edgeR::cpm(y, log=FALSE)
          tmm <- edgeR::calcNormFactors(cnt.mat)
          cpm.tmm <- edgeR::cpm(cnt.mat, lib.size = tmm * colSums(cnt.mat))
          saveRDS(cpm.tmm, file = rds.file)
          cpm.tmm
        })
```


```{r}
all.sample.acts <-
  llply(cpms,
        .fun = function(expr) {
          sample_acts <- run_wmean(mat=expr, net=net.sub.no.ligands, .source='source', .target='target',
                  .mor='weight', times = 2, minsize = 5)
        })
```

```{r}
#stop("stop")
```


```{r}
spot.sep <- get.visium.spot.distance.separation(filtered.objs[[1]])
nn.unit.spot.sep <- max(spot.sep[3:4])

# Run misty pipeline for inferring:
# pathways ~ ligands (intra)
#          ~ ligands (juxta)
#          ~ ligands (para)
#          ~ cell type (intra)
#          ~ cell type (juxta)
#          ~ cell type (para)
sample.name <- names(filtered.objs)[1]
for(sample.name in names(filtered.objs)) {
  print(sample.name)

  results.folder <- paste0(analysis_dir, "misty-path-vs-ligand-and-cell-type-", sample.name)
  
  if(file.exists(results.folder)) { next }
  
  rctd.df <- format.rctd.output_(rctds[[sample.name]])
  rctd.df <- rctd.df[, !(colnames(rctd.df) %in% c("x","y"))]
  colnames(rctd.df) <- make.names(colnames(rctd.df))
  
  sample_acts <- subset(all.sample.acts[[sample.name]], statistic == "wmean")[, c("source", "condition", "score")]
  act.mat <- dcast(sample_acts, condition ~ source)
  rownames(act.mat) <- act.mat$condition
  act.mat <- act.mat[, !(colnames(act.mat) %in% c("condition"))]
  colnames(act.mat) <- make.names(colnames(act.mat))

  expr <- cpms[[sample.name]]
  
  obj <- filtered.objs[[sample.name]]
  common.spots <- intersect(rownames(act.mat), colnames(expr))
  act.mat <- act.mat[common.spots,]
  rctd.df <- rctd.df[common.spots,]
  obj <- obj[, common.spots]
  expr <- expr[, common.spots]
  
  exclude <- apply(rctd.df, 1, function(row) any(is.na(row)))
  
  act.mat <- act.mat[!exclude,]
  rctd.df <- rctd.df[!exclude,]
  expr <- expr[, !exclude]
  obj <- obj[, !exclude]
  
  pos <- obj[[]][,c("row","col")]

  #tmp <- rbind(expr[rownames(expr) %in% top.ligands,], t(rctd.df))
  tmp <- expr[rownames(expr) %in% top.ligands,]
  rownames(tmp) <- make.names(rownames(tmp))
  ligand.expr <- tmp %>% t() %>% as_tibble(rownames = NA)
  act.expr <- act.mat %>% as_tibble(rownames = NA)
  cell.type.freq <- rctd.df %>% as_tibble(rownames = NA)
  
  # target is pathway expression
  misty.views <- create_initial_view(act.expr)
  
  # intraview, juxtaview, and paraview for ligands
  # intra
  dummy.views <- create_initial_view(ligand.expr)
  data.red <- dummy.views[["intraview"]]$data
  misty.views <- misty.views %>% add_views(create_view("intraview.lig", data.red, "intra.lig"))
  
  # juxtaview
  dummy.views <- dummy.views %>% add_juxtaview(pos, neighbor.thr = 1 + nn.unit.spot.sep)
  suffix <- 1 + nn.unit.spot.sep
  data.red <- dummy.views[[paste0("juxtaview.", suffix)]]$data
  misty.views <- misty.views %>% add_views(create_view(paste0("juxtaview.lig_", suffix), data.red, paste0("juxta.lig_", suffix)))
  
  # paraview
  # NB: paraview excludes the intraview and juxta view (with zoi = 3, i.e., 1 + spot.sep, should exclude first ring)
  dummy.views <- dummy.views %>% add_paraview(pos, l = nn.unit.spot.sep, zoi = 1 + nn.unit.spot.sep)
  suffix <- nn.unit.spot.sep
  data.red <- dummy.views[[paste0("paraview.", suffix)]]$data
  misty.views <- misty.views %>% add_views(create_view(paste0("paraview.lig_", suffix), data.red, paste0("para.lig_", suffix)))

  # intraview, juxtaview, and paraview for cell types
  # intra
  dummy.views <- create_initial_view(cell.type.freq)
  data.red <- dummy.views[["intraview"]]$data
  misty.views <- misty.views %>% add_views(create_view("intraview.ct", data.red, "intra.ct"))

  # juxtaview
  dummy.views <- dummy.views %>% add_juxtaview(pos, neighbor.thr = 1 + nn.unit.spot.sep)
  suffix <- 1 + nn.unit.spot.sep
  data.red <- dummy.views[[paste0("juxtaview.", suffix)]]$data
  misty.views <- misty.views %>% add_views(create_view(paste0("juxtaview.ct_", suffix), data.red, paste0("juxta.ct_", suffix)))
  
  # paraview
  # NB: paraview excludes the intraview and juxta view (with zoi = 3, i.e., 1 + spot.sep, should exclude first ring)
  dummy.views <- dummy.views %>% add_paraview(pos, l = nn.unit.spot.sep, zoi = 1 + nn.unit.spot.sep)
  suffix <- nn.unit.spot.sep
  data.red <- dummy.views[[paste0("paraview.", suffix)]]$data
  misty.views <- misty.views %>% add_views(create_view(paste0("paraview.ct_", suffix), data.red, paste0("para.ct_", suffix)))

  res <- run_misty(misty.views, results.folder = results.folder)
#%>% collect_results()
}
```

```{r}
# Run misty pipeline for inferring:
# cell type ~ cell type (intra)
#           ~ cell type (juxta)
#           ~ cell type (para)
sample.name <- names(filtered.objs)[1]
for(sample.name in names(filtered.objs)) {
  print(sample.name)

  results.folder <- paste0(analysis_dir, "misty-cell-type-vs-cell-type-", sample.name)
 
  if(file.exists(results.folder)) { next }
   
  rctd.df <- format.rctd.output_(rctds[[sample.name]])
  rctd.df <- rctd.df[, !(colnames(rctd.df) %in% c("x","y"))]
  colnames(rctd.df) <- make.names(colnames(rctd.df))
  
  sample_acts <- subset(all.sample.acts[[sample.name]], statistic == "wmean")[, c("source", "condition", "score")]
  act.mat <- dcast(sample_acts, condition ~ source)
  rownames(act.mat) <- act.mat$condition
  act.mat <- act.mat[, !(colnames(act.mat) %in% c("condition"))]
  colnames(act.mat) <- make.names(colnames(act.mat))

  expr <- cpms[[sample.name]]
  
  obj <- filtered.objs[[sample.name]]
  common.spots <- intersect(rownames(act.mat), colnames(expr))
  act.mat <- act.mat[common.spots,]
  rctd.df <- rctd.df[common.spots,]
  obj <- obj[, common.spots]
  expr <- expr[, common.spots]
  
  exclude <- apply(rctd.df, 1, function(row) any(is.na(row)))
  
  act.mat <- act.mat[!exclude,]
  rctd.df <- rctd.df[!exclude,]
  expr <- expr[, !exclude]
  obj <- obj[, !exclude]
  
  pos <- obj[[]][,c("row","col")]

  #tmp <- rbind(expr[rownames(expr) %in% top.ligands,], t(rctd.df))
  tmp <- expr[rownames(expr) %in% top.ligands,]
  rownames(tmp) <- make.names(rownames(tmp))
  ligand.expr <- tmp %>% t() %>% as_tibble(rownames = NA)
  act.expr <- act.mat %>% as_tibble(rownames = NA)
  cell.type.freq <- rctd.df %>% as_tibble(rownames = NA)
  
  # target is cell type frequency
  
  # intraview
  misty.views <- create_initial_view(cell.type.freq)
  
  # juxtaview
  misty.views <- misty.views %>% add_juxtaview(pos, neighbor.thr = 1 + nn.unit.spot.sep)
  
  # paraview
  # NB: paraview excludes the intraview and juxta view (with zoi = 3, i.e., 1 + spot.sep, should exclude first ring)
  misty.views <- misty.views %>% add_paraview(pos, l = nn.unit.spot.sep, zoi = 1 + nn.unit.spot.sep)
  res <- run_misty(misty.views, results.folder = results.folder)
#%>% collect_results()
}
```

```{r}
#stop("stop")
```

```{r}
treated.samples <- subset(one.sample.per.patient.batch.2.bias.df, treated == "Treated")$sample
untreated.samples <- subset(one.sample.per.patient.batch.2.bias.df, treated == "Untreated")$sample

```

```{r}
merge.misty.results <- function(misty1.res, misty2.res, suffix1, suffix2) {
  m <- merge(as.data.frame(misty1.res$importances.aggregated),
             as.data.frame(misty2.res$importances.aggregated),
           by = c("view", "Predictor", "Target"), suffixes = c(suffix1, suffix2))
  m$imp.diff <- m$Importance.treated - m$Importance.untreated
  m <- m[order(abs(m$imp.diff), decreasing=TRUE),]
  # m <- subset(m, nsamples.untreated == length(untreated.samples) & nsamples.treated == length(treated.samples))
  return(m)
}
```


```{r}
# Collect cell type ~ cell type results
treated.misty.dirs <- paste0(analysis_dir, "misty-cell-type-vs-cell-type-", treated.samples)
untreated.misty.dirs <- paste0(analysis_dir, "misty-cell-type-vs-cell-type-", untreated.samples)
misty.treated.ct.res <- collect_results(treated.misty.dirs)
misty.untreated.ct.res <- collect_results(untreated.misty.dirs)
misty.treated.ct.individual.res <- lapply(treated.misty.dirs, function(dir) collect_results(dir))
misty.untreated.ct.individual.res <- lapply(untreated.misty.dirs, function(dir) collect_results(dir))

lst <- list("treated" = misty.treated.ct.individual.res, "untreated" = misty.untreated.ct.individual.res)
all.ct.res <-
  ldply(lst, 
        .fun = function(sub.list) {
          ret <- 
            ldply(sub.list,
                  .fun = function(misty.res) {
                    misty.res$importances[, c("view", "Predictor", "Target", "Importance")]
                  })
          colnames(ret)[1] <- "sample"
          ret
        })
colnames(all.ct.res)[1] <- "status"
```

```{r}
# TO DO:
# 1. Plot hypoxia
# 2. Plot Plasma cells vs cycling epi
misty.treated.ct.res %>% plot_interaction_heatmap(view="intra")
g <- plot.distributions.vs.cell.type(all.cors, response.var = "cor", facet.var="comp", dependent.var="type", use.log=FALSE, use.violin=FALSE,label.var="p")
g <- g + ylab("Pearson Correlation\n(Across Spots)") + xlab("Sample Type")
png(paste0(plots_dir, "/main-cell-type-correlation-distributions.png"))
print(g)
d <- dev.off()

rctd.df <- format.rctd.output(rctds[[1]])
rctd.df <- rctd.df[, !(colnames(rctd.df) %in% c("x", "y"))]
cell.types <- make.names(colnames(rctd.df))
all.treated.cell.type.props <- 
  ldply(treated.samples,
        .fun = function(s) reshape2::melt(filtered.objs[[s]][[]][, cell.types]))
colnames(all.treated.cell.type.props) <- c("sample", "cell.type", "proportion")
all.treated.cell.type.props$type <- "Treated"
all.untreated.cell.type.props <- 
  ldply(untreated.samples,
        .fun = function(s) reshape2::melt(filtered.objs[[s]][[]][, cell.types]))
colnames(all.untreated.cell.type.props) <- c("sample", "cell.type", "proportion")
all.untreated.cell.type.props$type <- "Untreated"
all.cell.type.props <- rbind(all.treated.cell.type.props, all.untreated.cell.type.props)

ggplot(data = subset(all.cell.type.props, cell.type="Plasma_Cells"), aes(x = sample, y = proportion, fill = type)) + geom_boxplot(outlier.shape=NA)
```

```{r}
# See https://stackoverflow.com/questions/59140960/remove-outliers-and-reduce-ylim-appropriately-for-each-facet-in-ggplot2
# filtering function - turns outliers into NAs to be removed
filter_lims <- function(x){
  l <- boxplot.stats(x)$stats[1]
  u <- boxplot.stats(x)$stats[5]

  for (i in 1:length(x)){
    x[i] <- ifelse(x[i]>l & x[i]<u, x[i], NA)
  }
  return(x)
}

g <- 
  subset(all.cell.type.props, cell.type=="Stromal") %>% 
    group_by(sample, cell.type) %>%  # do the same calcs for each box
    mutate(value2 = filter_lims(proportion))  %>% as_data_frame() %>%
    ggplot(aes(y = value2, x = tidytext::reorder_within(sample, value2, cell.type, function(x) median(x, na.rm=TRUE)), fill = type)) +
    geom_boxplot(na.rm = TRUE, outlier.shape = NA) +
    labs(fill = "Status") + ylab("Cell Type Fraction") + xlab("Patient") + theme(axis.text.x = element_blank(), text = element_text(size = text.sz))
```


```{r}
# Collect path ~ lig + cell type results
treated.misty.dirs <- paste0(analysis_dir, "misty-path-vs-ligand-and-cell-type-", treated.samples)
untreated.misty.dirs <- paste0(analysis_dir, "misty-path-vs-ligand-and-cell-type-", untreated.samples)
names(treated.misty.dirs) <- treated.samples
names(untreated.misty.dirs) <- untreated.samples
misty.treated.path.res <- collect_results(treated.misty.dirs)
misty.untreated.path.res <- collect_results(untreated.misty.dirs)
misty.treated.path.individual.res <- llply(treated.misty.dirs, .fun = function(dir) collect_results(dir))
misty.untreated.path.individual.res <- llply(untreated.misty.dirs, .fun = function(dir) collect_results(dir))
lst <- list("treated" = misty.treated.path.individual.res, "untreated" = misty.untreated.path.individual.res)
all.path.res <-
  ldply(lst, 
        .fun = function(sub.list) {
          ret <- 
            ldply(sub.list,
                  .fun = function(misty.res) {
                    misty.res$importances[, c("view", "Predictor", "Target", "Importance")]
                  })
          colnames(ret)[1] <- "sample"
          ret
        })
colnames(all.path.res)[1] <- "status"
# g <- ggplot(data = subset(all.path.res, view == "intra.ct" & Target == "VEGF" & Predictor == "Plasma_Cells"), aes(x = status, y = Importance)) + geom_boxplot() + geom_point()

df <- subset(all.path.res, view == "intra.ct" & Target == "VEGF" & Predictor == "Plasma_Cells")
stat.test <- df %>% t_test(Importance ~ status)
stat.test <- stat.test %>% add_xy_position(x = "status")
g <- ggboxplot(data = df, x = "status", y = "Importance", add = "point") + xlab("Status")
g <- g + stat_pvalue_manual(stat.test, label = "p", tip.length = 0.01)
g <- g + ggtitle("VEGF ~ Plasma_Cells")  + theme(plot.title = element_text(hjust = 0.5), text = element_text(size = 20))
png(paste0(plots_dir, "/misty-vegf-vs-plasma-box.png"))
print(g)
d <- dev.off()

df <- subset(all.path.res, view == "intra.lig" & Target == "Hypoxia" & Predictor == "VEGFA")
stat.test <- df %>% t_test(Importance ~ status)
stat.test <- stat.test %>% add_xy_position(x = "status")
g <- ggboxplot(data = df, x = "status", y = "Importance", add = "point") + xlab("Status")
g <- g + stat_pvalue_manual(stat.test, label = "p", tip.length = 0.01)
g <- g + ggtitle("Hypoxia ~ VEGFA") + theme(plot.title = element_text(hjust = 0.5), text = element_text(size = 20))
png(paste0(plots_dir, "/misty-hypoxia-vs-vegfa-box.png"))
print(g)
d <- dev.off()

```

```{r}
misty.path.res <- merge.misty.results(misty.treated.path.res, misty.untreated.path.res, ".treated", ".untreated")
```

```{r}
nms <- names(filtered.objs)
names(nms) <- nms
new.objs <-
  llply(nms,
        .parallel = FALSE,
        .fun = function(nm) {
          obj <- filtered.objs[[nm]]
          obj[["CPM"]] <- CreateAssayObject(data = cpms[[nm]])
          obj[["LCPM"]] <- CreateAssayObject(data = l.cpms[[nm]])
          sample_acts <- subset(all.sample.acts[[nm]], statistic == "wmean")[, c("source", "condition", "score")]
          act.mat <- reshape2::dcast(sample_acts, condition ~ source, value.var = "score")
          rownames(act.mat) <- act.mat$condition
          act.mat <- act.mat[, !(colnames(act.mat) %in% c("condition"))]
          colnames(act.mat) <- make.names(colnames(act.mat))
          obj <- add.metadata.to.seurat.obj(obj, act.mat)
          obj
        })
```

```{r}
indices <- 1:nrow(patient.df)
names(indices) <- patient.df$sample
plts <-
  llply(indices,
        .fun = function(i) {
          sample.name <- patient.df[i, "sample"]
          treatment.status <- patient.df[i, "treated"]
          obj <- new.objs[[sample.name]]
          DefaultAssay(obj) <- "CPM"
          # add title with treatment status
          # save with treatment status first
          feat1 <- "VEGFA"
          feat2 <- "Hypoxia"
          feat1 <- "Plasma_Cells"
          feat2 <- "VEGF"
          glist <- plot.features_(obj, features=c(feat1, feat2), slot="data", include.hne = TRUE, include.umi.cnts = TRUE)
          file.name <- paste0(paste0(feat1, "-", feat2, "-", treatment.status, "-", sample.name))
          # df <- data.frame(VEGF = obj[[]]$VEGF, Plasma_Cells = obj[[]]$Plasma_Cells)
          df <- obj[[]]
          if(!(feat1 %in% colnames(df))) {
            vec <- as.numeric(GetAssayData(obj, assay="CPM", slot="data")[feat1,])
            names(vec) <- feat1
            df <- cbind(df, vec)
          }
          if(!(feat2 %in% colnames(df))) {
            vec <- as.numeric(GetAssayData(obj, assay="CPM", slot="data")[feat2,])
            names(vec) <- feat2
            df <- cbind(df, vec)
          }
          gs <- ggscatter(df, x = feat1, y = feat2, add = "reg.line", 
                          add.params = list(color = "blue", fill = "lightgray"), conf.int = TRUE)
          #gs <- gs + stat_cor(method = "pearson", size=10, aes(label = ..r.label..))      
          gs <- gs + ggtitle(paste0("r = ", round(cor(df[, feat1], df[,feat2], use="complete.obs"), digits=2)))
          g <- plot_grid(plotlist=c(glist, list(gs)),nrow=3)
          title <- paste0(sample.name, " (", treatment.status, ")")
          g <- add.title.to.plot(g, title, rel_heights = c(0.05, 1))
          png(paste0(plots_dir, "/", file.name, ".png"))
          print(g)
          d <- dev.off()
          g
        })
```

```{r}
png("foo.png")
g <- plot_grid(plotlist=plts[treated.samples])
print(g)
d <- dev.off()

png("bar.png")
g <- plot_grid(plotlist=plts[untreated.samples])
print(g)
d <- dev.off()

```

```{r}
my_plot_view_contributions <-
function (misty.results, trim = -Inf, trim.measure = c("gain.R2", 
    "multi.R2", "intra.R2", "gain.RMSE", "multi.RMSE", "intra.RMSE")) 
{
    trim.measure.type <- match.arg(trim.measure)
    assertthat::assert_that(("contributions.stats" %in% names(misty.results)), 
        msg = "The provided result list is malformed. Consider using collect_results().")
    assertthat::assert_that(("improvements.stats" %in% names(misty.results)), 
        msg = "The provided result list is malformed. Consider using collect_results().")
    inv <- sign((stringr::str_detect(trim.measure.type, "gain") | 
        stringr::str_detect(trim.measure.type, "RMSE", negate = TRUE)) - 
        0.5)
    targets <- misty.results$improvements.stats %>% dplyr::filter(measure == 
        trim.measure.type, inv * mean >= inv * trim) %>% dplyr::pull(target)
    assertthat::assert_that(assertthat::not_empty(targets), msg = "Invalid selection of trim measure and/or value.")
    plot.data <- misty.results$contributions.stats %>% dplyr::filter(target %in% 
        targets)
    results.plot <- ggplot2::ggplot(plot.data, ggplot2::aes(x = target, 
        y = fraction)) + ggplot2::geom_col(ggplot2::aes(group = view, 
        fill = view)) + ggplot2::scale_fill_brewer(palette = "Set2") + 
        ggplot2::theme_classic() + ggplot2::ylab("Contribution") + 
        ggplot2::xlab("Target") + ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, 
        hjust = 1))
    results.plot
}

my_plot_interaction_heatmap <-
function (misty.results, view, cutoff = 1, trim = -Inf, trim.measure = c("gain.R2", 
    "multi.R2", "intra.R2", "gain.RMSE", "multi.RMSE", "intra.RMSE"), 
    clean = FALSE) 
{
    trim.measure.type <- match.arg(trim.measure)
    assertthat::assert_that(("importances.aggregated" %in% names(misty.results)), 
        msg = "The provided result list is malformed. Consider using collect_results().")
    assertthat::assert_that(("improvements.stats" %in% names(misty.results)), 
        msg = "The provided result list is malformed. Consider using collect_results().")
    assertthat::assert_that((view %in% (misty.results$importances.aggregated %>% 
        dplyr::pull(view))), msg = "The selected view cannot be found in the results table.")
    inv <- sign((stringr::str_detect(trim.measure.type, "gain") | 
        stringr::str_detect(trim.measure.type, "RMSE", negate = TRUE)) - 
        0.5)
    targets <- misty.results$improvements.stats %>% dplyr::filter(measure == 
        trim.measure.type, inv * mean >= inv * trim) %>% dplyr::pull(target)
    plot.data <- misty.results$importances.aggregated %>% dplyr::filter(view == 
        !!view, Target %in% targets)
    if (clean) {
        clean.predictors <- plot.data %>% dplyr::mutate(Importance = Importance * 
            (Importance >= cutoff)) %>% dplyr::group_by(Predictor) %>% 
            dplyr::summarize(total = sum(Importance, na.rm = TRUE)) %>% 
            dplyr::filter(total > 0) %>% dplyr::pull(Predictor)
        clean.targets <- plot.data %>% dplyr::mutate(Importance = Importance * 
            (Importance >= cutoff)) %>% dplyr::group_by(Target) %>% 
            dplyr::summarize(total = sum(Importance, na.rm = TRUE)) %>% 
            dplyr::filter(total > 0) %>% dplyr::pull(Target)
        plot.data.clean <- plot.data %>% dplyr::filter(Predictor %in% 
            clean.predictors, Target %in% clean.targets)
    }
    else {
        plot.data.clean <- plot.data
    }
    set2.blue <- "#8DA0CB"
    results.plot <- ggplot2::ggplot(plot.data.clean, ggplot2::aes(x = Predictor, 
        y = Target)) + ggplot2::geom_tile(ggplot2::aes(fill = Importance)) + 
        ggplot2::scale_fill_gradient2(low = "white", mid = "white", 
            high = set2.blue, midpoint = cutoff) + ggplot2::theme_classic() + 
        ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, 
            hjust = 1)) + ggplot2::coord_equal() + ggplot2::ggtitle(view)
    results.plot
}

my_plot_improvement_stats <-
function (misty.results, measure = c("gain.R2", "multi.R2", "intra.R2", 
    "gain.RMSE", "multi.RMSE", "intra.RMSE"), trim = -Inf) 
{
    measure.type <- match.arg(measure)
    assertthat::assert_that(("improvements.stats" %in% names(misty.results)), 
        msg = "The provided result list is malformed. Consider using collect_results().")
    inv <- sign((stringr::str_detect(measure.type, "gain") | 
        stringr::str_detect(measure.type, "RMSE", negate = TRUE)) - 
        0.5)
    plot.data <- misty.results$improvements.stats %>% dplyr::filter(measure == 
        measure.type, inv * mean >= inv * trim)
    assertthat::assert_that(assertthat::not_empty(plot.data), 
        msg = "Invalid selection of measure and/or trim value.")
    set2.orange <- "#FC8D62"
    results.plot <- ggplot2::ggplot(plot.data, ggplot2::aes(x = stats::reorder(target, 
        -mean), y = mean)) + ggplot2::geom_pointrange(ggplot2::aes(ymin = mean - 
        sd, ymax = mean + sd)) + ggplot2::geom_point(color = set2.orange) + 
        ggplot2::theme_classic() + ggplot2::ylab(measure) + ggplot2::xlab("Target") + 
        ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, 
            hjust = 1))
    results.plot
}

```

```{r}
stop("stop")
```


```{r}
# To do
# - plot spatial across samples using a common set of limits (that can be automatically set)
# - plot 2 rows: vegfa (cpm) and hypoxia for a subset of samples, annotated by treated / untreated
# - organize with vegfa on top of hypoxia; add titles
# head(subset(all.path.res, Predictor == "Hypoxia" & Target == "VEGFA" & view == "intraview"),n=20)
# g1 <- ggscatter(subset(df, VEGFA < 1000), x = "VEGFA", y = "Hypoxia", add = "reg.line") + stat_cor(method = "pearson", size=10, aes(label = ..r.label..)) 
# df <- data.frame(VEGFA = as.numeric(GetAssayData(obj, assay="CPM", slot="data")["VEGFA",]), Hypoxia = obj[[]]$Hypoxia)
# misty.treated.path.res %>%  plot_improvement_stats("gain.R2")
g <- my_plot_improvement_stats(misty.treated.path.res) + theme(text = element_text(size = 20))
g <- g + ylab("Gain R2 (Treated)")
png(paste0(plots_dir, "/misty-treated-path-improvement-stats.png"))
print(g)
d <- dev.off()

# This shows plasma / vegf
# misty.treated.path.res %>%  plot_interaction_heatmap(view = "intra.ct")
g <- my_plot_interaction_heatmap(misty.treated.path.res, view = "intra.ct") + theme(text = element_text(size = 15), axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + ggtitle("Cell Type Intraview (Treated)")
png(paste0(plots_dir, "/misty-treated-path-intra-ct-heatmap.png"))
print(g)
d <- dev.off()

g <- my_plot_interaction_heatmap(misty.treated.path.res, view = "intra", clean=TRUE) + theme(text = element_text(size = 15), axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + ggtitle("Pathway Intraview (Treated)")
png(paste0(plots_dir, "/misty-treated-path-intra-path-heatmap.png"))
print(g)
d <- dev.off()

g <- my_plot_interaction_heatmap(misty.treated.path.res, view = "intra.lig", cutoff=1.5, clean=TRUE) + theme(text = element_text(size = 15), axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + ggtitle("Ligand Intraview (Treated)")
png(paste0(plots_dir, "/misty-treated-path-intra-lig-heatmap.png"))
print(g)
d <- dev.off()

# This shows vegf has significant contributions from other view
# misty.treated.path.res %>%  plot_view_contributions()
g <- my_plot_view_contributions(misty.treated.path.res) + theme(text = element_text(size = 20))
g <- g + ylab("Contribution (Treated)")
png(paste0(plots_dir, "/misty-treated-path-contributions.png"))
print(g)
d <- dev.off()
```


```{r}

# sample.name <- "SC2200260_9990"
top.ligands <- hc.ligands$gene[1:200]
for(sample.name in names(filtered.objs)) {
  # sample.name <- "SC2300228_JP9990"
  print(sample.name)
obj <- filtered.objs[[sample.name]]

# Use the log1p in data slot
expr <- GetAssayData(obj, assay="SCT", slot="data")

sample_acts <- run_wmean(mat=expr, net=net.sub.no.ligands, .source='source', .target='target',
                  .mor='weight', times = 2, minsize = 5)
sample_acts <- subset(sample_acts, statistic == "wmean")[, c("source", "condition", "score")]
act.mat <- dcast(sample_acts, condition ~ source)
rownames(act.mat) <- act.mat$condition
act.mat <- act.mat[, !(colnames(act.mat) %in% c("condition"))]
colnames(act.mat) <- make.names(colnames(act.mat))

common.spots <- intersect(rownames(act.mat), colnames(expr))
act.mat <- act.mat[common.spots,]
obj <- obj[, common.spots]
expr <- expr[, common.spots]
pos <- obj[[]][,c("row","col")]
obj <- add.metadata.to.seurat.obj(obj, act.mat)
#plot.features(obj, features=c("Hypoxia", "JAK.STAT", "TNFa", "TGFb"))
#plot.features(obj, features=c("JAK.STAT", "CCL5"))
#plot.features(obj, features=c("Hypoxia", "VEGFA"))
# res$importances.aggregated %>%  filter(view == "para.lig_9", Target == "Hypoxia") %>% arrange(-Importance)

ligand.expr <- expr[rownames(expr) %in% top.ligands,] %>% t() %>% as_tibble(rownames = NA)
act.expr <- act.mat %>% as_tibble(rownames = NA)

misty.views <- create_initial_view(act.expr)
# paraview for pathway activities
misty.views <- misty.views %>% add_paraview(pos, l = 9, zoi = 1)
names(misty.views)[length(misty.views)] <- "paraview.path_9"
misty.views[[length(misty.views)]]$abbrev <- "para.path_9"
# paraview for ligands
# misty.views <- misty.views %>% add_views(create_view("paraview.lig_9", ligand.expr, "para.lig_9"))
dummy.views <- create_initial_view(ligand.expr)
dummy.views <- dummy.views %>% add_paraview(pos, l = 9, zoi = 1)
data.red <- dummy.views[["paraview.9"]]$data
misty.views <- misty.views %>% add_views(create_view("paraview.lig_9", data.red, "para.lig_9"))
res <- run_misty(misty.views, results.folder = paste0(analysis_dir, "misty-cell-path-lig-indep-", sample.name))
#%>% collect_results()
}
```


```{r}
stop("stop")
```


```{r}
dirs <- list.dirs(analysis_dir)
dirs <- dirs[grepl(dirs, pattern="misty-cell-path-lig-indep")]
res <- collect_results(dirs)
```

```{r}
tmp <- patient.df
tmp$label <- factor(tmp$label, levels=c("Batch 2", "Batch 2-reseq", "Batch 1"))
tmp <- tmp[order(tmp$label),]
# Select one sample per patient, favoring batch 2
one.sample.per.patient.df <- tmp[!duplicated(tmp$patient),]
treated.samples <- subset(one.sample.per.patient.df, treated == "Treated")$sample
untreated.samples <- subset(one.sample.per.patient.df, treated == "Untreated")$sample
treated.misty.dirs <- paste0(analysis_dir, "misty-cell-path-lig-indep-", treated.samples)
untreated.misty.dirs <- paste0(analysis_dir, "misty-cell-path-lig-indep-", untreated.samples)
treated.misty.res <- collect_results(treated.misty.dirs)
untreated.misty.res <- collect_results(untreated.misty.dirs)
```

```{r}
# treated.misty.results <- lapply(treated.misty.dirs, function(dir) collect_results(dir))
```


```{r}
obs.with.acts <-
  llply(filtered.objs,
        .fun = function(obj) {
          expr <- GetAssayData(obj, assay="SCT", slot="data")
          sample_acts <- run_wmean(mat=expr, net=net.sub.no.ligands, .source='source', .target='target',
                                   .mor='weight', times = 2, minsize = 5)
          sample_acts <- subset(sample_acts, statistic == "wmean")[, c("source", "condition", "score")]
          act.mat <- dcast(sample_acts, condition ~ source)
          rownames(act.mat) <- act.mat$condition
          act.mat <- act.mat[, !(colnames(act.mat) %in% c("condition"))]
          colnames(act.mat) <- make.names(colnames(act.mat))
          
          common.spots <- intersect(rownames(act.mat), colnames(expr))
          act.mat <- act.mat[common.spots,]
          obj <- obj[, common.spots]
          expr <- expr[, common.spots]
          obj <- add.metadata.to.seurat.obj(obj, act.mat)
          obj
        })
```

```{r}
feature <- "Hypoxia"
feature <- "Epithelial"
feature <- "Immune"
feature <- "Stromal"
treated.plots <- lapply(treated.samples, function(s) plot.features(obs.with.acts[[s]], features=c(feature)) + ggtitle(s))
g.treated <- plot_grid(plotlist=treated.plots)
g.treated <- add.title.to.plot(g.treated, "Treated Samples", size=24, rel_heights=c(0.1,0.9))
untreated.plots <- lapply(untreated.samples, function(s) plot.features(obs.with.acts[[s]], features=c(feature)) + ggtitle(s))
g.untreated <- plot_grid(plotlist=untreated.plots)
g.untreated <- add.title.to.plot(g.untreated, "Untreated Samples", size=24, rel_heights=c(0.1,0.9))
g.tot <- plot_grid(g.treated, g.untreated, nrow=1)
png(paste0(plots_dir,tolower(feature), "-spatial.png"), width = 2*480, height = 480)
print(g.tot)
d <- dev.off()
```

```{r}
treated.plots <- lapply(treated.samples, function(s) ggpairs(obs.with.acts[[s]][[]][, c("Stromal", "Immune", "Epithelial")]) + ggtitle(s))
g.treated <- plot_grid(plotlist=treated.plots)
g.treated <- add.title.to.plot(g.treated, "Treated Samples", size=24, rel_heights=c(0.1,0.9))
untreated.plots <- lapply(untreated.samples, function(s) ggpairs(obs.with.acts[[s]][[]][, c("Stromal", "Immune", "Epithelial")]) + ggtitle(s))
g.untreated <- plot_grid(plotlist=untreated.plots)
g.untreated <- add.title.to.plot(g.untreated, "Untreated Samples", size=24, rel_heights=c(0.1,0.9))
g.tot <- plot_grid(g.treated, g.untreated, nrow=1)
```
```{r}
names(treated.samples) <- treated.samples
treated.cors <- ldply(treated.samples, 
                      .fun = function(s) {
                        m <- cor(obs.with.acts[[s]][[]][, c("Stromal", "Immune", "Epithelial")], use="pairwise.complete.obs")
                        m[upper.tri(m, diag=TRUE)] <- NA
                        na.omit(reshape2::melt(m))
                      })

colnames(treated.cors) <- c("sample", "cell.type1", "cell.type2", "cor")
treated.cors$type <- "Treated"

names(untreated.samples) <- untreated.samples
untreated.cors <- ldply(untreated.samples, 
                      .fun = function(s) {
                        m <- cor(obs.with.acts[[s]][[]][, c("Stromal", "Immune", "Epithelial")], use="pairwise.complete.obs")
                        m[upper.tri(m, diag=TRUE)] <- NA
                        na.omit(reshape2::melt(m))
                      })
colnames(untreated.cors) <- c("sample", "cell.type1", "cell.type2", "cor")
untreated.cors$type <- "Untreated"

all.cors <- rbind(treated.cors, untreated.cors)
all.cors <- all.cors[order(all.cors$cell.type1, all.cors$cell.type2, all.cors$cor),]

all.cors$comp <- paste0(all.cors$cell.type1, "-vs-", all.cors$cell.type2)
plot.distributions.vs.cell.type(all.cors, response.var = "cor", facet.var="comp", dependent.var="type")

ggplot(data = all.cors, aes(x = type, y = cor)) + facet_wrap(cell.type1~cell.type2, scales="free_y") + geom_boxplot()

stat.test <- df %>% t_test(Importance ~ status)
stat.test <- stat.test %>% add_xy_position(x = "status")
g <- ggboxplot(data = df, x = "status", y = "Importance", add = "point") + xlab("Status")
g <- g + stat_pvalue_manual(stat.test, label = "p", tip.length = 0.01)

# TO DO
# 1. Plot distribution of immune, stromal, and epi for all samples
# 2. Heatmap of fine-grained cell type interactions
# 3. plot entropy of cell types
g <- plot.distributions.vs.cell.type(all.cors, response.var = "cor", facet.var="comp", dependent.var="type", use.log=FALSE, use.violin=FALSE)

```


```{r}
pathway <- "Hypoxia"
#pathway <- "EGFR"
#pathway <- "Plasma_Cells"
#pathway <- "JAK.STAT"
#pathway <- "Trail"
# acts <- ldply(obs.with.acts, .fun = function(obj) obj[[]][, c(pathway), drop=FALSE])
acts <- ldply(new.objs, .fun = function(obj) obj[[]][, c(pathway), drop=FALSE])
colnames(acts) <- c("sample", "pathway")
acts <- subset(acts, sample %in% one.sample.per.patient.batch.2.bias.df$sample)
acts <- merge(acts, patient.df[, c("sample", "treated", "batch.var")])
#fit <- lm(pathway ~ treated + batch.var, data = acts)
#summary(fit)
# g <- ggplot(data = acts, aes(x = sample, y = pathway)) + facet_wrap(~ treated, scales = "free_x") + geom_boxplot()
mean.acts <- ddply(acts, .variable = c("sample"), .fun = function(df) data.frame(pathway = mean(na.omit(df$pathway))))
mean.acts <- merge(mean.acts, patient.df[, c("sample", "treated", "batch.var")])
mean.acts <- mean.acts[order(mean.acts$pathway, decreasing=TRUE),]
fit <- lm(pathway ~ treated + batch.var, data = mean.acts)
summary(fit)
acts$sample <- factor(acts$sample, levels=mean.acts$sample)
g <- ggplot(data = acts, aes(x = sample, y = pathway, fill = treated)) + geom_boxplot()
# g <- ggplot(data = acts, aes(x = sample, y = pathway, fill = treated)) + geom_violin()
g <- g + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```


```{r}
# TODO
# - how to handle replicates / batch? add as variables?
# - plot pathways across treated and untreated
# - plot scores, as well as spatial
# - plot major differences across both
# - plot cell types across treated and untreated
```

```{r}
all.filtered.objs <- Reduce(merge, filtered.objs)
Idents(all.filtered.objs) <- all.filtered.objs$orig.ident
```


```{r}
res %>% plot_improvement_stats("gain.R2")
res %>% plot_view_contributions()
res %>% plot_interaction_heatmap(view = "intra")
res$importances.aggregated %>%  filter(view == "para.lig_9", Target == "Hypoxia") %>% arrange(-Importance)
res %>% plot_interaction_heatmap(view = "intra.lig", clean = TRUE)
treated.misty.res$importances.aggregated %>% arrange(-Importance)
# treated.misty.res$importances.aggregated %>%  filter(view == "para.lig_9") %>% arrange(-Importance)
SpatialFeaturePlot(seurat.vs, features = c("IGKC", "Plasma.Cells"))
res %>% plot_interaction_heatmap(view = "para.igkc_10")
```

```{r}
m <- merge(as.data.frame(misty.untreated.path.res$importances.aggregated), as.data.frame(misty.treated.path.res$importances.aggregated),
           by = c("view", "Predictor", "Target"), suffixes = c(".untreated", ".treated"))
m$imp.diff <- abs(m$Importance.treated - m$Importance.untreated)
m <- m[order(abs(m$imp.diff), decreasing=TRUE),]
m <- subset(m, nsamples.untreated == length(untreated.samples) & nsamples.treated == length(treated.samples))
# head(m %>%  filter(Predictor == "Plasma_Cells") %>% arrange(abs(imp.diff), decreasing=TRUE))
# This shows vegfa / hypoxia relationship
# head(misty.path.res)
# This shows connection between plasma cells and vegf:
# head(misty.path.res %>%  filter(Target == "VEGF") %>% arrange(abs(imp.diff), decreasing=TRUE),n=10)
# This shows top interactions with plasma cells
# head(misty.path.res %>%  filter(Predictor == "Plasma_Cells") %>% arrange(abs(imp.diff), decreasing=TRUE))
```


```{r}
stop("stop")
```

```{r}
source("/home/whitebr/cancer-cube-st-pilot-ffpe-ff/misty-utils.R")
```


```{r}
mat <- GetAssayData(filtered.objs[[1]], assay="Spatial", slot="counts")
rs <- data.frame(gene = rownames(mat), cnt = as.numeric(rowSums(mat)))
rs <- rs[order(rs$cnt, decreasing=TRUE),]
```




```{r}
if(FALSE){
for(indx in 1:length(filtered.objs)) {
#indx <- 1
obj <- filtered.objs[[indx]]
obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = "^MT-")
obj[["percent.ribo"]] <- PercentageFeatureSet(obj, pattern = "^RPL|^RPS")
lst <- plot.features_(obj, features=c("percent.mt", "percent.ribo"), feature.names = c("% MT", "% Ribo"), include.hne=TRUE, include.umi.cnts=TRUE)
g1 <- ggscatter(obj[[]], x = "nCount_Spatial", y = "percent.ribo",
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE # Add confidence interval
   )
g1 <- g1 + stat_cor(method = "pearson", size=10, aes(label = ..rr.label..)) 
g1 <- g1 + xlab("# UMIs") + ylab("% Ribosomal UMIs") + theme(text = element_text(size = 20))
g2 <- ggscatter(obj[[]], x = "nCount_Spatial", y = "percent.mt",
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE # Add confidence interval
   )
g2 <- g2 + stat_cor(method = "pearson", size=10, aes(label = ..rr.label..)) 
g2 <- g2 + xlab("# UMIs") + ylab("% Mitochondrial UMIs") + theme(text = element_text(size = 20))
g <- plot_grid(plotlist = c(lst, list(g2), list(g1)),nrow=3)
sample <- names(filtered.objs)[indx]
g <- add.title.to.plot(g, sample, rel_heights=c(0.05,1))
cat(paste0("Cor(ribo, read cnt): ", cor(obj[[]]$percent.ribo, obj[[]]$nCount_Spatial), "\n"))
cat(paste0("Cor(MT, read cnt): ", cor(obj[[]]$percent.mt, obj[[]]$nCount_Spatial), "\n"))
png(paste0("mt-ribo-spatial-", sample, ".png"), width = 2 * 480, height = 3 * 480)
print(g)
d <- dev.off()
}
}

```


```{r}

# UMI: gene x cell / sample count matrix
# See https://github.com/const-ae/transformGamPoi-Paper/blob/master/benchmark/src/transformations/transformation_helper.R
log1p.sf.norm <- function(UMI) {
  # Apply the definition of size factor in Eqn 3 of
  # Comparison of Transformations for Single-Cell RNA-Seq Data (PMID: 37037999)
  # i.e., see transformGamPoi-Paper/notebooks/plot_size_factor_effect_on_dim_reduction.Rmd
  size_factors <- colSums2(UMI)
  size_factors <- size_factors / mean(size_factors)
  transformGamPoi::shifted_log_transform(UMI, pseudo_count = 1, size_factors = size_factors)
}

calculate.cpm.tmm <- function(cnt.mat, ...) {
  tmm <- edgeR::calcNormFactors(cnt.mat)
  cpm.tmm <- edgeR::cpm(cnt.mat, lib.size = tmm * colSums(cnt.mat), ...)
  cpm.tmm
}

tmm.cpm.norm <- function(UMI) calculate.cpm.tmm(UMI)


sctransform.norm.cnts <- function(UMI) {
  obj <- CreateSeuratObject(UMI, assay="RNA")
  obj <- apply.sctransform_(obj, assay="RNA")
  GetAssayData(obj,assay="SCT",slot="counts")
}

sctransform.norm.log1p <- function(UMI) {
  obj <- CreateSeuratObject(UMI, assay="RNA")
  obj <- apply.sctransform_(obj, assay="RNA")
  GetAssayData(obj,assay="SCT",slot="data")
}

wilcoxon.de.test <- function(mat, conditions, cond1, cond2, min.pct = 0.7) {
    flag <- conditions %in% c(cond1, cond2)
    cond1.flag <- conditions == cond1
    genes <- rownames(mat)
    pct.1 <- as.numeric(rowMeans(mat[,cond1.flag]>0))
    cond2.flag <- conditions == cond2
    pct.2 <- as.numeric(rowMeans(mat[,cond2.flag]>0))
    if(min.pct > 0) {
      flag <- pct.1 > min.pct
      pct.1 <- pct.1[flag]
      pct.2 <- pct.2[flag]
      genes <- genes[flag]
    }
    names(genes) <- genes
    res <-
      ldply(genes,
            .parallel = TRUE,
            .fun = function(gene) {
              # alternative = greater -> cond1 > cond2
              wt <- wilcox.test(x = as.numeric(mat[gene,cond1.flag]),
                                y = as.numeric(mat[gene,cond2.flag]),
                                alternative = "greater")
              data.frame(p.val = wt$p.value)
            })
    colnames(res)[1] <- "gene"
    res <- cbind(res, pct.1 = pct.1, pct.2 = pct.2, pct.diff = pct.1 - pct.2)
    o <- order(res$pct.diff, decreasing=TRUE)
    res <- res[o,]
    res
}

# See https://github.com/csoneson/conquer_comparison/blob/master/scripts/apply_MASTcpmDetRate.R
mast.de.test <- function(mat, conditions, cond1, cond2, min.pct = 0.7) {
  names(conditions) <- colnames(mat)
    stopifnot(all(names(conditions) == colnames(mat)))
    flag <- conditions %in% c(cond1, cond2)
    conds <- conditions[flag]
    mat <- mat[, flag]
    cond1.flag <- conds == cond1
    cond2.flag <- conds == cond2
    genes <- rownames(mat)
    pct <- data.frame(gene = genes, pct.1 = as.numeric(rowMeans(mat[,cond1.flag]>0)),
                      pct.2 = as.numeric(rowMeans(mat[,cond2.flag]>0)))
    if(min.pct > 0) {
      flag <- pct$pct.1 > min.pct
      pct <- pct[flag,]
      genes <- genes[flag]
    }
    mat <- mat[genes,]
    names(genes) <- genes
    grp <- conds
    cdr <- scale(colMeans(mat > 0))
    sca <- FromMatrix(exprsArray = as.matrix(mat), 
                      cData = data.frame(wellKey = names(grp), 
                                         grp = grp, cdr = cdr),
                      check_sanity = FALSE)
    zlmdata <- zlm(~cdr + grp, sca, parallel=TRUE)
    mast <- lrTest(zlmdata, "grp", parallel=TRUE)
    res <- data.frame(gene = names(mast[, "hurdle", "Pr(>Chisq)"]), p.val=as.numeric(mast[, "hurdle", "Pr(>Chisq)"]))
    res <- merge(res, pct)
    res$pct.diff <- res$pct.1 - res$pct.2
    o <- order(res$pct.diff, decreasing=TRUE)
    res <- res[o,]
    res
}
# norm.methods = log1p.sf, tmm.cpm.norm, sctransform.norm.cnts, sctransform.norm.log1p
test.de.consistency <- function(norm.mat, conditions, de.method = wilcoxon.de.test, num.iterations = 10) {
  #norm.mat <- norm.method(UMI)
  
  uniq.conditions <- unique(conditions)
  # cond1.indices <- 1:(length(uniq.conditions)-1)
  cond1.indices <- 1:(length(uniq.conditions))
  names(cond1.indices) <- uniq.conditions[cond1.indices]
  
  cond.df <- data.frame(cell = names(conditions), cond = conditions)
  
  iters<- 1:num.iterations
  names(iters) <- iters
  outer.ret <-
    ldply(cond1.indices, .parallel = FALSE,
          .fun = function(i) {
            cat(paste0("Find markers for cell type ", i, " of ", length(uniq.conditions), ": ", uniq.conditions[i], "\n"))
            inner.ret <- 
              ldply(iters,
                    .parallel = FALSE,
                    .fun = function(iter) {
                      set.seed(iter)
                      stratified <- cond.df %>% group_by(cond) %>% sample_frac(size=0.5)
                      flag <- names(conditions) %in% stratified$cell
                  
                      # 1-vs-rest
                      cond1 <- as.character(uniq.conditions[i])
                      dummy.conditions <- as.character(conditions)
                      dummy.conditions[dummy.conditions != cond1] <- "other"
                      cond2 <- "other"
                  
                      mat1 <- norm.mat[,flag]
                      conds1 <- dummy.conditions[flag]
                      mat2 <- norm.mat[,!flag]
                      conds2 <- dummy.conditions[!flag]
                  
                      res1 <- de.method(mat1, conds1, cond1, cond2)
                      gc()
                      res2 <- de.method(mat2, conds2, cond1, cond2)
                      gc()
                  
                      res1 <- res1[order(res1$p.val, decreasing=FALSE),]
                      res2 <- res2[order(res2$p.val, decreasing=FALSE),]
                      res1 <- subset(res1, p.val < 0.05 & pct.diff > 0)
                      res2 <- subset(res2, p.val < 0.05 & pct.diff > 0)
                      n.res1 <- head(res1, n=min(20, nrow(res1)))
                      n.res2 <- head(res2, n=min(20, nrow(res2)))
                      data.frame(frac.overlap = length(intersect(n.res1$gene, n.res2$gene)) / nrow(n.res1))
                    })
            colnames(inner.ret)[1] <- "iter"
            inner.ret
        })
  colnames(outer.ret)[1] <- "condition"
  outer.ret
}
    
```


```{r}
test.de.consistency.wrapper <- function(norm.mats, conditions, de.methods, num.iterations = 10) {
  #norm.mat <- norm.method(UMI)
  
  uniq.conditions <- unique(conditions)
  # cond1.indices <- 1:(length(uniq.conditions)-1)
  cond1.indices <- 1:(length(uniq.conditions))
  names(cond1.indices) <- uniq.conditions[cond1.indices]
  
  cond.df <- data.frame(cell = names(conditions), cond = conditions)
  
  iters<- 1:num.iterations
  names(iters) <- iters
  outer.ret <-
    ldply(cond1.indices, .parallel = FALSE,
          .fun = function(i) {
            cat(paste0("Find markers for cell type ", i, " of ", length(uniq.conditions), ": ", uniq.conditions[i], "\n"))
            inner.ret <- 
              ldply(iters,
                    .parallel = FALSE,
                    .fun = function(iter) {
                      set.seed(iter)
                      stratified <- cond.df %>% group_by(cond) %>% sample_frac(size=0.5)
                      flag <- names(conditions) %in% stratified$cell
                  
                      # 1-vs-rest
                      cond1 <- as.character(uniq.conditions[i])
                      dummy.conditions <- as.character(conditions)
                      dummy.conditions[dummy.conditions != cond1] <- "other"
                      cond2 <- "other"

                      norm.names <- names(norm.mats)
                      names(norm.names) <- norm.names
                      norm.rets <-
                        ldply(norm.names,
                              .parallel = FALSE,
                              .fun = function(norm.name) {
                                
                                #print(norm.name)
                                norm.mat <- norm.mats[[norm.name]]
                                        
                                mat1 <- norm.mat[,flag]
                                conds1 <- dummy.conditions[flag]
                                mat2 <- norm.mat[,!flag]
                                conds2 <- dummy.conditions[!flag]
                            
                                method.names <- names(de.methods)
                                names(method.names) <- method.names
                                method.rets <- 
                                  ldply(method.names,
                                        .parallel = FALSE,
                                        .fun = function(method.name) {
                                          cat(paste0(method.name, ": ", norm.name, " (iter ", iter, ")\n"))
                                          de.method <- de.methods[[method.name]]
                                
                                          res1 <- de.method(mat1, conds1, cond1, cond2)
                                          gc()
                                          res2 <- de.method(mat2, conds2, cond1, cond2)
                                          gc()
                                      
                                          res1 <- res1[order(res1$p.val, decreasing=FALSE),]
                                          res2 <- res2[order(res2$p.val, decreasing=FALSE),]
                                          res1 <- subset(res1, p.val < 0.05 & pct.diff > 0)
                                          res2 <- subset(res2, p.val < 0.05 & pct.diff > 0)
                                          n.res1 <- head(res1, n=min(20, nrow(res1)))
                                          n.res2 <- head(res2, n=min(20, nrow(res2)))
                                          data.frame(frac.overlap = length(intersect(n.res1$gene, n.res2$gene)) / nrow(n.res1))
                                        })
                                colnames(method.rets)[1] <- "de.method"
                                method.rets
                              })
                      colnames(norm.rets)[1] <- "norm"
                      norm.rets
                    })
            colnames(inner.ret)[1] <- "iter"
            inner.ret
        })
  colnames(outer.ret)[1] <- "condition"
  outer.ret
}
```

```{r}
find.markers.wrapper <- function(norm.mats, conditions, de.methods) {
  #norm.mat <- norm.method(UMI)
  
  uniq.conditions <- unique(conditions)
  # cond1.indices <- 1:(length(uniq.conditions)-1)
  cond1.indices <- 1:(length(uniq.conditions))
  names(cond1.indices) <- uniq.conditions[cond1.indices]
  cond2.indices <- cond1.indices
  
  cond.df <- data.frame(cell = names(conditions), cond = conditions)
  
  outer.ret <-
    ldply(cond1.indices, .parallel = FALSE,
          .fun = function(i) {
            cond1 <- as.character(uniq.conditions[i])
            inner.ret <- 
              ldply(cond2.indices,
                    .parallel = FALSE,
                    .fun = function(j) {
                      cat(paste0("Find markers for cell type ", i, " of ", length(uniq.conditions), " vs ", j, ": ", uniq.conditions[i], " vs ", uniq.conditions[j], "\n"))
                      cond2 <- as.character(uniq.conditions[j])
                      norm.names <- names(norm.mats)
                      names(norm.names) <- norm.names
                      norm.rets <-
                        ldply(norm.names,
                              .parallel = FALSE,
                              .fun = function(norm.name) {
                                
                                #print(norm.name)
                                norm.mat <- norm.mats[[norm.name]]
                                        
                                method.names <- names(de.methods)
                                names(method.names) <- method.names
                                method.rets <- 
                                  ldply(method.names,
                                        .parallel = FALSE,
                                        .fun = function(method.name) {
                                          cat(paste0(method.name, ": ", norm.name, "\n"))
                                          de.method <- de.methods[[method.name]]
                                
                                          res <- de.method(mat, conditions, cond1, cond2)
                                          gc()
                                          res
                                        })
                                colnames(method.rets)[1] <- "de.method"
                                method.rets
                              })
                      colnames(norm.rets)[1] <- "norm"
                      norm.rets
                    })
            colnames(inner.ret)[1] <- "cond2"
            inner.ret
        })
  colnames(outer.ret)[1] <- "cond1"
  outer.ret
}
```




```{r}
if(FALSE) {
flag <- tnbc.cell.types %in% c("B_Cells", "CD4+ T-cells", "CD8+ T-cells", "iCAFs", "myCAFs", "imPVL")
# flag <- tnbc.cell.types %in% c("B_Cells", "CD8+ T-cells", "iCAFs")
conditions <- as.character(tnbc.cell.types)[flag]
mat <- tnbc.cnts[, flag]
names(conditions) <- colnames(mat)
mat <- mat[rowSums(mat) > 0,]
#norm.mat <- log1p.sf.norm(mat)
}
```

```{r}
if(FALSE) {
norm.mats <- list()
norm.mats[["log1p.sf"]] = log1p.sf.norm(mat)
norm.mats[["tmm.cpm"]] = tmm.cpm.norm(mat)
#norm.mats[["seurat.counts"]] = sctransform.norm.cnts(mat)
#norm.mats[["seurat.log1p"]] = sctransform.norm.log1p(mat)
obj <- CreateSeuratObject(mat, assay="RNA")
obj <- apply.sctransform_(obj, assay="RNA")
norm.mats[["seurat.counts"]] = GetAssayData(obj,assay="SCT",slot="counts")
norm.mats[["seurat.log1p"]] = GetAssayData(obj,assay="SCT",slot="data")
}
```

```{r}
if(FALSE) {
mat <- tnbc.cnts
mat <- mat[rowSums(mat) > 0,]
all.norm.mats <- list()
all.norm.mats[["log1p.sf"]] = log1p.sf.norm(mat)
gc()
all.norm.mats[["tmm.cpm"]] = tmm.cpm.norm(mat)
gc()
obj <- CreateSeuratObject(mat, assay="RNA")
obj <- apply.sctransform_(obj, assay="RNA")
gc()
all.norm.mats[["seurat.counts"]] = GetAssayData(obj,assay="SCT",slot="counts")
gc()
all.norm.mats[["seurat.log1p"]] = GetAssayData(obj,assay="SCT",slot="data")
gc()
rm(obj)
rm(mat)
gc()
}
```


```{r}
de.methods <- list()
de.methods[["mast"]] <- mast.de.test
de.methods[["wilcoxon"]] <- wilcoxon.de.test
```

```{r}
#foo <- find.markers.wrapper(norm.mats, as.character(all.norm.mats), de.methods["wilcoxon"])
```


```{r}
#stop("Done")
```


```{r}
#wilcoxon.res <- test.de.consistency.wrapper(norm.mats, conditions, de.methods["wilcoxon"], num.iterations=10)
#save(wilcoxon.res, file="wilcoxon.res.Rdata")
```


```{r}
if(FALSE) {
mast.res <- test.de.consistency.wrapper(norm.mats[c("seurat.log1p", "log1p.sf")], conditions, de.methods["mast"], num.iterations=10)
save(mast.res, file="mast.res.Rdata")
cat("Done\n")
stop("Done")
}
```


```{r}
if(FALSE) {
de.nms <- names(de.methods)
names(de.nms) <- de.nms
norm.nms <- names(norm.mats)
names(norm.nms) <- norm.nms
all.res <-
  ldply(de.nms,
        .parallel = FALSE,
        .fun = function(de.method.name) {
          de.method <- de.methods[[de.method.name]]
          print(de.method.name)
          ret <- 
            ldply(norm.nms,
                  .parallel = FALSE,
                  .fun = function(norm.name) {
                    print(norm.name)
                    norm.mat <- norm.mats[[norm.name]]
                    de.res <- test.de.consistency(norm.mat, conditions, de.method = de.method, num.iterations = 1)
                    gc()
                    de.res
                  })
          colnames(ret)[1] <- "norm"
          ret
                  
        })
colnames(all.res)[1] <- "de.method"
save(all.res, file="all.res.Rdata")
cat("Done!")
}
```


```{r}
#stop("stop")
```


```{r}
#de.wilcox <- test.de.consistency(norm.mat, conditions, de.method = wilcoxon.de.test, num.iterations = 5)
```

```{r}
#de.mast <- test.de.consistency(norm.mat, conditions, de.method = mast.de.test, num.iterations = 5)
```

```{r}
```

```{r}
plot.mean.var <- function(cnt.mat) {
sce <- SingleCellExperiment(assays=list(counts=cnt.mat))
tmp <- logNormCounts(sce)
#lcnts <- assay(tmp, "logcounts")
dec <- modelGeneVar(tmp)

fit.pbmc <- metadata(dec)
plot(fit.pbmc$mean, fit.pbmc$var, xlab="Mean of log-expression",
    ylab="Variance of log-expression")
curve(fit.pbmc$trend(x), col="dodgerblue", add=TRUE, lwd=2)
return(fit.pbmc)  
}
```

```{r}
calculate.tmm.and.scran.library.sizes <- function(cnt.mat) {
  sce <- SingleCellExperiment(assays=list(counts=cnt.mat))
  # size factors: Normalized expression values are computed by dividing the counts for each cell by the size factor for that cell. 
  lcnts <- logNormCounts(sce)
  scran.sf <- sizeFactors(lcnts)
  # calcNormFactors: lib.size * norm.factors where lib.size contains the original library sizes and norm.factors is the vector of scaling factors computed by this function. 
  tmm <- edgeR::calcNormFactors(cnt.mat)
  list("scran.sf" = scran.sf, "tmm.sf" = tmm)
}
```

```{r}
#ret <- calculate.tmm.and.scran.library.sizes(GetAssayData(filtered.objs[[1]], assay="Spatial", slot="count"))
```


```{r}
calculate.fracs.top.n <- function(cnt.mat) {
  cols <- colnames(cnt.mat)
  names(cols) <- cols
  ret <- ldply(cols,
               .parallel = TRUE,
               .fun = function(col) {
                 vec <- cnt.mat[,col]
                 vec <- vec[order(vec, decreasing=TRUE)]
                 cs <- cumsum(vec)
                 tot <- sum(vec)
                 ns <- c(1,5,10,20,50,100)
                 nms <- paste0("frac.", ns)
                 ret <- cs[ns]/tot
                 names(ret) <- nms
                 df <- t(as.data.frame(ret))
                 rownames(df) <- NULL
                 df
                })
  colnames(ret)[1] <- "id"
  ret
}

# Exclude all zeroes
# foo <- apply(cnt.mat, 2, rank)
# rm <- rowMeans(foo)
# rm <- rm[order(rm, decreasing=TRUE)]
```


```{r}
if(FALSE) {
cnt.mat <- GetAssayData(filtered.objs[[1]], assay="Spatial", slot="count")
sce <- SingleCellExperiment(assays=list(counts=cnt.mat))
tmp <- logNormCounts(sce)
lcnts <- assay(tmp, "logcounts")
dec <- modelGeneVar(tmp)

fit.pbmc <- metadata(dec)
plot(fit.pbmc$mean, fit.pbmc$var, xlab="Mean of log-expression",
    ylab="Variance of log-expression")
curve(fit.pbmc$trend(x), col="dodgerblue", add=TRUE, lwd=2)
# plot(density(cnt.mat["MALAT1",]/colSums(cnt.mat)))
}
# To do
# Plot TMM vs scran normalization -- library size vs norm
# Plot TMM density
# Plot scran norm density
# Plot mean-var
# Plot entropy?
# Plot frac of genes by top n=5, 10, 20, 50, 100
```


```{r}
# Use edgeR with cell detection rate as a covariate. This was a top-performing method
# in a recent study (though by the authors)
# See https://www.nature.com/articles/nmeth.4612
# See the code where upon which the below is based
# https://github.com/csoneson/conquer_comparison/blob/master/scripts/apply_edgeRQLFDetRate.R
# NB: cond1 will be the reference.
# This means that those genes with _negative_ logFC will be positive markers for cond1.
# conditions: vector of cell-level conditions/labels
find.markers.edgeRQLFDetRate <- function(raw.counts, conditions, cond1, cond2) {
  flag <- conditions %in% c(cond1, cond2)
  L.count <- raw.counts[, flag]
  L.condt <- factor(conditions[flag], levels = c(cond1, cond2))
  dge <- DGEList(L.count, group = L.condt)
  dge <- calcNormFactors(dge)
  cdr <- scale(colMeans(L.count > 0))
  design <- model.matrix(~ cdr + L.condt)
  dge <- estimateDisp(dge, design = design)
  fit <- glmQLFit(dge, design = design)
  qlf <- glmQLFTest(fit)
  tt <- topTags(qlf, n = Inf)
  cond1.flag <- conditions == cond1
  pct.1 <- as.numeric(rowMeans(raw.counts[rownames(tt$table),cond1.flag]>0))
  cond2.flag <- conditions == cond2
  pct.2 <- as.numeric(rowMeans(raw.counts[rownames(tt$table),cond2.flag]>0))
  tt$table <- cbind(tt$table, pct.1=pct.1, pct.2=pct.2)
  tt
}

find.all.markers <- function(raw.counts, conditions, rds.output.file.prefix = NULL) {
  uniq.conditions <- unique(conditions)
  cond1.indices <- 1:(length(uniq.conditions)-1)
  names(cond1.indices) <- uniq.conditions[cond1.indices]
  llply(cond1.indices, .parallel = FALSE,
        .fun = function(i) {
          cat(paste0("Find markers for cell type ", i, " of ", length(uniq.conditions), ": ", uniq.conditions[i], "\n"))
          cond2.indices <- (i+1):length(uniq.conditions)
          names(cond2.indices) <- uniq.conditions[cond2.indices]
          llply(cond2.indices, .parallel = FALSE,
                .fun = function(j) {
                  cat(paste0("Find markers for cell type ", uniq.conditions[i], 
                             " (", i , " of ", length(uniq.conditions), ") vs ",
                             uniq.conditions[j], " (", j , " of ", length(uniq.conditions), ")\n"))

                  rds.output.file <- NULL
                  if(!is.null(rds.output.file.prefix)) {
                    rds.output.file <- paste0(rds.output.file.prefix, make.names(uniq.conditions[i]), "-vs-", make.names(uniq.conditions[j]), ".rds")
                    if(file.exists(rds.output.file)) {
                      res <- readRDS(rds.output.file)
                      gc()
                      return(res)
                    }
                  }
                  res <- find.markers(raw.counts, conditions, cond1 = uniq.conditions[i], cond2 = uniq.conditions[j])
                  if(!is.null(rds.output.file)) {
                    saveRDS(res, rds.output.file)
                  }
                  gc()
                  return(res)
                })
        })
}
```

```{r}
if(FALSE) {
flag <- as.character(tnbc.cell.types) %in% c("iCAFs", "myCAFs", "B_Cells")
# tt <- find.markers(raw.counts = tnbc.cnts, conditions = as.character(tnbc.cell.types), cond1 = "myCAFs", cond2 = "B_Cells")
# tnbc.markers <- find.all.markers(tnbc.cnts[,flag], as.character(tnbc.cell.types)[flag])
dir.create(paste0(analysis_dir, "/wu-scrnaseq-markers/"), showWarnings = FALSE, recursive = TRUE)
tnbc.markers <- find.all.markers(tnbc.cnts, as.character(tnbc.cell.types), rds.output.file.prefix = paste0(analysis_dir, "/wu-scrnaseq-markers/wu-scrnaseq-markers-"))
}
```


```{r}
#stop("stop")
```


```{r}
if(FALSE) {
cpm.pb <- read.table("cpm-pb.tsv", sep="\t", header=TRUE)
patient.df <- read.table("patient-df.tsv", sep="\t", header=TRUE)
patient.df$label <- factor(patient.df$label)
patient.df$batch.var <- factor(patient.df$batch.var)
# foo <- HarmonyMatrix(as.matrix(cpm.pb[rowSums(cpm.pb) > 0,]), patient.df, "batch.var", do_pca=TRUE, npcs=10)
foo <- HarmonyMatrix(as.matrix(cpm.pb[odg,]), patient.df, "batch.var", do_pca=TRUE, npcs=10)
plot(foo[,1],foo[,2])
text(foo[,1], foo[,2], patient.df$label)
}

```


```{r}


apply.sctransform <- function(objs, use.v2 = TRUE) {
  objs <-
    llply(objs,
          .fun = function(obj) {
            apply.sctransform_(obj, use.v2 = use.v2)
          })
  objs
}
```


Configure variables that point to location of images and directories where analyses and plots will be stored.


```{r}
# Read in the filtered and unfiltered matrices and append the tissue positions information to the metadata:
#filtered.objs <- create.visium.seurat.objects(spaceranger_dirs, filter.spots = TRUE)
#unfiltered.objs <- create.visium.seurat.objects(spaceranger_dirs, filter.spots = FALSE)
```

```{r}
# Perform normalization of counts using SCTransform (which fits a negative binomial to the count data)
# This adds a new assay "SCT" to the returned Seurat object. That assay has slots "counts" (the corrected counts),
# "data" (log1p(counts)), and "scale.data" (the "pearson residuals").
# These would be accessible via GetAssayData(filtered.objs[[1]], slot = "data", assay = "SCT")
# Running with default parameters (the most interesting of which look to be variable.features.n and/or variable.features.rv.th)
# filtered.objs <- apply.sctransform(filtered.objs)
```

```{r}
if(FALSE) {
cols <- llply(filtered.objs, .fun = function(obj) rowSums(GetAssayData(obj, slot="data", assay="Spatial")))
pb <- do.call(cbind, cols)
pb <- pb[rowSums(pb) > 0,]
library(edgeR)
cpm.pb <- cpm(pb)
library(uwot)
rs <- rowSums(as.matrix(cpm.pb))
expr.genes <- names(rs)[log(rs) > 3]
umap.pb <- umap(t(cpm.pb[expr.genes,]), scale=TRUE)
# foo <- HarmonyMatrix(as.matrix(cpm.pb[rowSums(cpm.pb) > 0,]), patient.df, "label", do_pca=TRUE, npcs=8)
cpm.pb <- read.table("cpm-pb.tsv", sep="\t", header=TRUE)
patient.df <- read.table("patient-df.tsv", sep="\t", header=TRUE)
patient.df$label <- factor(patient.df$label)
rownames(patient.df) <- patient.df$sample

write.table(file="cpm-pb.tsv", cpm.pb, row.names=TRUE, col.names=TRUE, sep="\t", quote=FALSE)
write.table(file="patient-df.tsv", patient.df, row.names=TRUE, col.names=TRUE, sep="\t", quote=FALSE)
plot(umap.pb[,1], umap.pb[,2])
text(umap.pb[,1], umap.pb[,2], patient.df[colnames(pb),"label"])
text(umap.pb[,1], umap.pb[,2], colames(pb))
# TO DO
# - note findvariablefeatures functions
# - getOverdispersedGenes
# - note that I calculated variance in log10; STdeconolve calculates log variance, what does edgeR do
# - compute all markers for TNBC data -- use this in downstream analysis
# - harmonize based on sequencing batch
# - for example pseudo bulk
#   - fit a gaussian -> expressed genes
#   see plotmm: https://rdrr.io/cran/plotmm/man/plot_mix_comps_normal.html
#   - look at overdispersed
# - take union of all overdispersed
# - do pca with labels
# - do harmony with labels
# - how do we generalize "expressed" for spots?
odg <- getOverdispersedGenes(GetAssayData(filtered.objs[[1]], assay="Spatial")[expr.genes,], plot=TRUE)
bar <- getOverdispersedGenes(as.matrix(cpm.pb)[expr.genes,], plot=TRUE)
umap.pb <- umap(t(cpm.pb[odg,]), scale=TRUE)
}
```


```{r}
indx <- 100
vec <- GetAssayData(filtered.objs[[1]], slot="data", assay="Spatial")[,indx]
tbl <- table(vec)
df <- data.frame(cnt = as.numeric(names(tbl)), freq = cumsum(as.numeric(tbl))/sum(tbl))
plot(df$cnt[df$cnt<50], df$freq[df$cnt<50])
tbl1 <- table(vec[vec>0])
plot(tbl1)
```






```{r}
plot.gene.pop.correlation <- function(objs, rctds, sample.name, gene, pop) {
  mat <- GetAssayData(objs[[sample.name]], slot = "data", assay = "SCT")
  mat <- cpm(mat, log = TRUE)
  expr.df <- data.frame(gene = as.numeric(mat[gene,]), spot = colnames(mat))
  rctd.tbl <- format.rctd.output_(rctds[[sample.name]], normalize=FALSE)
  rctd.df <- data.frame(pop = rctd.tbl[, pop], spot = rownames(rctd.tbl))
  expr.df <- merge(expr.df, rctd.df)
  return(expr.df)
}
```


```{r}
gene <- "CDKN2A"
```


```{r}
# stop("stop")
```


```{r}
# To do
# Basic QC: reads, umis
# Plot bio/tech replicates
# Cluster bio/tech replicates (w/o batch correction)
# Deconvolve
# Took at senescence markers
# Check for off by 1 in get.per.spot.saturation.stats
# get.per.spot.saturation.stats
```

```{r}
align.metrics <- get.all.per.spot.alignment.metrics(spaceranger_dirs, prefix = analysis_dir)
```


```{r}
indices <- 1:nrow(patient.df)
names(indices) <- patient.df$sample
top.gs <- llply(indices, 
                .parallel = FALSE, 
                .fun = function(i) {
                  sample <- patient.df[i, "sample"]
                  short.sample <- patient.df[i, "short.sample"]
                  patient <- patient.df[i, "patient"]
                  status <- patient.df[i, "treated"]
                  label <- patient.df[i, "label"]
                  title <- paste0(status, " patient: ", patient, "\n(", short.sample, "; ", label, ")")
                  g <- plot.top.genes(as.matrix(GetAssayData(filtered.objs[[sample]], assay="Spatial", slot="counts")))
                  g <- g + ggtitle(title)
                })
```

```{r}
pts <- c("1127","1330A","1863B")
g <- plot_grid(plotlist=top.gs[patient.df$sample[patient.df$patient %in% pts]])
png(paste0("top-genes-", paste(pts,collapse="-"), ".png"), width = 2*480, height=2*480)
print(g)
d <- dev.off()

pts <- c("2171", "4401B")
g <- plot_grid(plotlist=top.gs[patient.df$sample[patient.df$patient %in% pts]])
png(paste0("top-genes-", paste(pts,collapse="-"), ".png"), width = 2*480, height=2*480)
print(g)
d <- dev.off()

pts <- c("4700")
g <- plot_grid(plotlist=top.gs[patient.df$sample[patient.df$patient %in% pts]])
png(paste0("top-genes-", paste(pts,collapse="-"), ".png"), width = 2*480, height=2*480)
print(g)
d <- dev.off()

pts <- c("9990")
g <- plot_grid(plotlist=top.gs[patient.df$sample[patient.df$patient %in% pts]])
png(paste0("top-genes-", paste(pts,collapse="-"), ".png"), width = 2*480, height=2*480)
print(g)
d <- dev.off()

pts <- c("6110","6970","7031")
g <- plot_grid(plotlist=top.gs[patient.df$sample[patient.df$patient %in% pts]])
png(paste0("top-genes-", paste(pts,collapse="-"), ".png"), width = 2*480, height=2*480)
print(g)
d <- dev.off()

# plot.features(filtered.objs[["SC2200259_9990"]], features=c("IGKC","MT-CO2"),include.hne=TRUE)
# plot.features(filtered.objs[["SC2300234_JP4401B"]], features=c("IGKC","CD19", "CD8B", "GZMB"))
# plot.features(filtered.objs[["SC2300231_JP1863B"]], features=c("IGKC","CD19", "CD8B"))
# plot.features(filtered.objs[[sample.name]], features=c("IGKC","EEF1A1", "GAPDH", "TUBB", "FTH1"),include.hne=TRUE,include.umi.cnts=TRUE)

obj <- filtered.objs[["SC2300231_JP1863B"]]
mat <- GetAssayData(obj, assay="Spatial", slot="counts")
# norm.mat <- log1p.sf.norm(as.matrix(mat))
norm.mat <- edgeR::cpm(as.matrix(mat), log=FALSE)
ret <- MCPcounter.estimate(expression=norm.mat, featuresType="HUGO_symbols")
obj <- add.metadata.to.seurat.obj(obj, t(ret))

p_load(TNBC.CMS)
cms <- predictCMS(norm.mat)
df.cms <- data.frame(cms = as.character(cms))
rownames(df.cms) <- colnames(norm.mat)
obj <- add.metadata.to.seurat.obj(obj, df.cms)
plot.features(obj, features=c("B.lineage"))
plot.features(obj, features=c("CD19", "CD79A", "MS4A1"))
plot.features(obj, features=c("CD19", "CD79A", "MS4A1", "BANK1", "CD22", "CR2", "FCRL2", "PAX5"))
plot.features(obj, features=c("CD19", "CD79A", "MS4A1", "IGKC", "B.lineage", "CD8B"))

# In veins
indx <- 10
plot.features(filtered.objs[[indx]], features=c("IGKC"), include.umi.cnts=TRUE)

indx <- 12
plot.features(filtered.objs[[indx]], features=c("IGKC", "Epithelial"), include.umi.cnts=TRUE)

indx <- 15
plot.features(filtered.objs[[indx]], features=c("IGKC", "Epithelial"), include.umi.cnts=TRUE)

indx <- 17
plot.features(filtered.objs[[indx]], features=c("IGKC", "Epithelial"), include.umi.cnts=TRUE)
plot.features(filtered.objs[[indx]], features=c("IGKC", "Epithelial", "EPCAM"), include.umi.cnts=TRUE)
plot(log(mat.cpm["EPCAM",]),log(mat.cpm["IGKC",]))
```


```{r}
stop("stop")
```




```{r}
plot.features(filtered.objs[[11]], features=c("nCount_Spatial"),include.hne=TRUE)
```




```{r}
gs <-
  dlply(patient.df,
        .variables = c("patient"),
        .fun = function(df) {
          df <- df[order(df$label),]
          plts <- 
            llply(1:nrow(df),
                  .fun = function(indx) {
                    print(df[indx,"sample"])
                    # g <- plot.features(unfiltered.objs[[df[indx,"sample"]]], features=c("nCount_Spatial"), feature.names = c("nUMIs"), include.hne=TRUE)
                    g <- plot.features(unfiltered.objs[[df[indx,"sample"]]], features=NULL, include.umi.cnts = TRUE, include.hne=TRUE)
                    g <- add.title.to.plot(g, paste0("Patient: ", df[indx, "patient"], " Sample: ", df[indx, "short.sample"], "\n", df[indx, "label"]), size=24, rel_heights=c(0.1,0.4))
                    g
                  })
          # plot_grid(plotlist = plts, nrow=length(plts))
          nr <- min(2, length(plts))
          g <- plot_grid(plotlist = plts, nrow=nr)
          nm <- df[1, "patient"]
          nc <- ceiling(length(plts) / nr)
          png(paste0(plots_dir, "/", nm, "-nUMIs.png"), height = nr * 250, width = nc * 480)
          print(g)
          d <- dev.off()

        })
if(FALSE) {
l_ply(names(gs),
      .fun = function(nm) {
        png(paste0(plots_dir, "/", nm, "-nUMIs.png"), width = 2 * 480, height = 2 * 480)
        print(gs[[nm]])
        d <- dev.off()
      })
}
```

```{r}
tbl <- acast(patient.df, patient ~ label)
tbl <- tbl[order(tbl[,1], tbl[,2], tbl[,3], decreasing=TRUE),]
expt.design <- as.data.frame(tbl)
expt.design <- apply(expt.design, 2, as.character)
expt.design <- cbind("Patient" = rownames(tbl), expt.design)
expt.design[expt.design == "0"] <- ""
png(paste0(plots_dir, "/tnbc-expt-design.png"), height = 0.5 * 480)
grid.table(expt.design)
d <- dev.off()


library(gridExtra)
library(grid)
library(gtable)

table <- tableGrob(expt.design)

h <- grobHeight(table)
w <- grobWidth(table)
title <- textGrob("Num Samples", y=unit(0.5,"npc") + 1*h, 
                  vjust=0, gp=gpar(fontsize=15))

gt <- gTree(children=gList(table, title))
png(paste0(plots_dir, "/tnbc-expt-design.png"), height = 0.6 * 480)
grid.newpage()
grid.draw(gt)
d <- dev.off()

```



```{r}
json.path = "/projects/compsci/jgeorge/whitebr/tnbc/hov/SC2200259_9990/json/SC2200259-pyramid-fake.json"
json.type.info.path <- "/projects/chuang-lab/USERS/whitebr/hover_net/type_info.json"
tbl <- extract.cell.info.from.hovernet.output(json.path)[["df"]]
cell.info.tbl <- extract.hovernet.cell.info(json.type.info.path)
stbl <- merge(tbl, cell.info.tbl, by.x="type", by.y="id")
```


```{r}
suppressPackageStartupMessages(p_load(reticulate))
get.wsi.dimensions <- function(wsi.file) {
  openslide <- import("openslide")
  slide <- openslide$OpenSlide(wsi.file)
  dims <- unlist(slide$dimensions)
  return(dims)
}
```

```{r}
# get.wsi.dimensions("/projects/compsci/jgeorge/whitebr/tnbc/SC2200259_9990/img/SC2200259.tiff")
# get.wsi.dimensions("/projects/compsci/jgeorge/whitebr/tnbc/SC2200259_9990/img/hov/SC2200259-pyramid-fake.svs")
```


```{r}
# Map the centroids to spot row/columns
```


```{r}
# plot.features(filtered.objs[["SC2200259_9990"]], features=c("PTPRC"), include.hne=TRUE)
```



```{r}
stop("stop")
```

```{r}
# This is a plot for my R21
sample <- "SC2200259_9990" 
obj <- filtered.objs[[sample]]
DefaultAssay(obj) <- "Spatial"

#g0 <- plot.hne(obj)
#g2 <- plot.spatial(obj, features = c("EPCAM"), legend.name = "EPCAM", rescale.legend = FALSE) + theme(legend.text = element_text(size=10))
g <- plot.features(obj, features=c("EPCAM"), include.hne=TRUE)
png(paste0(plots_dir,"epcam-hne.png"),height=1*480, width=1*480)
print(g)
d <- dev.off()

```


```{r}
# Plot reads per spot (across samples)
cnt.tbl <- ldply(filtered.objs, .fun = function(obj) obj[[]][, c("nCount_Spatial"), drop=FALSE])
colnames(cnt.tbl)[1] <- "sample"
breaks <- 2^seq(from=log2(32), to=log2(131072), by=2)
g <- ggplot(data = cnt.tbl, aes(x = sample, y = nCount_Spatial)) + ylab("nUMIs") + geom_violin() + scale_y_continuous(trans='log2', breaks=breaks) + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1), text = element_text(size = 20))
png(paste0(plots_dir,"nUMIs-vs-sample.png"),height=1*480, width=2*480)
print(g)
d <- dev.off()
```


```{r}


# Find mixed spots including the two co-localized cell types A and B.
# Such spots should have fractional A content >= min.cell.type.a and similarly for B and
# a max fractional content of other cell types of max.other (i.e., A + B >= 1 - max.other)
# df is assumed created by format.rctd.output
find.mixed.spots <- function(df, cell.type.a, cell.type.b, min.cell.type.a = 0.3, min.cell.type.b = 0.3, max.other = 0.1) {
  flag.a <- df[, cell.type.a] >= min.cell.type.a
  flag.b <- df[, cell.type.b] >= min.cell.type.b
  flag.other <- 
    unlist(apply(df[, c(cell.type.a, cell.type.b)], 1,
           function(row) sum(row) >= (1 - max.other)))
  # print(table(flag.a))
  # print(table(flag.b))
  # print(table(flag.other))
  df[flag.a & flag.b & flag.other, , drop = FALSE]
}

# df.mixed <- find.mixed.spots(df, "iCAFs", "Epithelial", min.cell.type.a = 0.3, min.cell.type.b = 0.3, max.other = 0.25)

# For each spot having cell type A (at a proportion >= min.cell.type.A), find neighboring
# spots within a (square) radius having cell type B (at a proportion >= min.cell.type.b)
find.neighboring.spots <- function(df, cell.type.a, cell.type.b, min.cell.type.a = 0.3, min.cell.type.b = 0.3, radius = 2, exclude.spot.with.a = FALSE) {
  flag.a <- df[, cell.type.a] >= min.cell.type.a
  df.a <- df[flag.a, , drop = FALSE]  
  flag.b <- df[, cell.type.b] >= min.cell.type.b
  df.b <- df[flag.b, , drop = FALSE]  
  neighborhood <- as.data.frame(expand.grid(seq(-radius,radius),seq(-radius,radius)))
  colnames(neighborhood) <- c("x", "y")
  if(exclude.spot.with.a) {
    neighborhood <- subset(neighborhood, !((x == 0) & (y == 0)))
  }
  df.neighborhood <-
    apply(df.a[, c("x", "y")], 1, function(row) {
      data.frame(x = as.numeric(row[1]) + neighborhood$x, y = as.numeric(row[2]) + neighborhood$y)
    })
  df.neighborhood <- unique(do.call("rbind", df.neighborhood))
  df.neighborhood.b <- merge(df.neighborhood, df.b)
  m <- merge(df.a, df.neighborhood.b)
  return(m)
}

# find.neighboring.spots(df, "Epithelial", "myCAFs")
for(nm in names(rctds)) {
  df <- format.rctd.output(rctds[[nm]])
  print(nm)
  print(colSums(df[,1:20]))
  cat("\n")
}
indx <- 3
df <- format.rctd.output(rctds[[indx]])
obj <- filtered.objs[[indx]]
rctd <- rctds[[indx]]
mat <- Seurat::GetAssayData(obj, assay="Spatial")
common.spots <- intersect(rownames(df),colnames(mat))
mat <- mat[, common.spots]
df <- df[common.spots,]
library(edgeR)
colsms <- colSums(as.matrix(mat))
l.cpms <- cpm(as.matrix(mat), log = TRUE)
cpms <- cpm(as.matrix(mat), log = FALSE)
# plot(df[, c("Epithelial_Basal")] * df[, c("iCAFs")])
# plot(cpms["FGFR2",] + cpms["MYC",], df[, c("Epithelial_Basal")] * df[, c("iCAFs")])
plot(df[, c("Epithelial_Basal")] * df[, c("iCAFs")], cpms["FGFR2",] + cpms["FGF7",])
# scale by umis?
plot(df[, c("Epithelial_Basal_Cycling")] * df[, c("iCAFs")], cpms["FGFR2",] + cpms["FGF7",])
plot(pmin(df[, c("Epithelial_Basal_Cycling")], df[, c("iCAFs")]), cpms["BMP7",] + cpms["BMPR1B",])
plot(density(pmin(df[, c("Epithelial_Basal_Cycling")], df[, c("iCAFs")])))

# questions:
# impute?
# normalize by counts?
# spatial correlation?
# product / sum / min
# plot spatially
# what is depth of these ligands / receptors in published data
```

```{r}
l_ply(datasets, .parallel = FALSE,
        .fun = function(nm) {
          print(nm)
          md.df <- format.rctd.output(rctds[[nm]])
          md.df <- md.df[, !(colnames(md.df) %in% c("x", "y"))]
          write.table(md.df, file = paste0(analysis_dir, "/", nm, "-rctd.tsv"), row.names = TRUE, col.names = TRUE, quote = FALSE, sep = "\t")
        })
```





```{r}

sample.name <- "SC2200259_9990"
obj <- filtered.objs[[sample.name]]
# rctd.df <- format.rctd.output(rctds[[sample.name]])
rctd.df <- format.rctd.output_(rctds[[sample.name]])
rctd.df <- rctd.df[, !(colnames(rctd.df) %in% c("x", "y"))]
# obj <- add.metadata.to.seurat.obj(obj, rctd.df)
if(FALSE) {
p_load(sctransform)
sct.data <- vst(GetAssayData(object = obj, slot = "counts", assay = "Spatial"), verbosity = 0)
expr <- sct.data$y
}
fit.p <- my.GetFit(GetAssayData(obj, assay="Spatial"), type="negbin")
expr <- GetAssayData(obj, assay="SCT", slot="counts")

colnames(rctd.df) <- make.names(colnames(rctd.df))
colnames(rctd.df) <- gsub(colnames(rctd.df), pattern="_", replacement=".")
obj[["SCT"]] <- CreateAssayObject(data = rbind(expr, t(rctd.df)))

seurat.vs <- obj

# Filtering genes that are expressed in at least 5% of spots

gene.expression <- GetAssayData(seurat.vs, assay = "SCT")
coverage <- rowSums(gene.expression > 0) / ncol(gene.expression)
slide.markers <- names(which(coverage >= 0.05))

slide.markers <- c("IGKC", colnames(rctd.df))

# Define assay for each view
view.assays <- list(
  "main" = "SCT",
  "juxta.igkc" = "SCT"
)

# Define features for each view
view.features <- list(
  "main" = slide.markers,
  "juxta.igkc" = slide.markers
)

# Define spatial context for each view
view.types <- list(
  "main" = "intra",
  "juxta.igkc" = "juxta"
)

# Define additional parameters (l in the case of paraview; neighbor.thr in the case of juxtaview)
view.params <- list(
  "main" = NULL,
  "juxta.igkc" = 3
)

misty.out <- "vignette_model_seurat"

misty.results <- run_misty_seurat(
  visium.slide = seurat.vs,
  view.assays = view.assays,
  view.features = view.features,
  view.types = view.types,
  view.params = view.params,
  spot.ids = NULL, # Using the whole slide
  out.alias = misty.out
)

res <-  collect_results(misty.results)
```
```{r}

res %>% plot_improvement_stats("gain.R2")
res %>% plot_view_contributions()
res %>% plot_interaction_heatmap(view = "intra")
res$importances.aggregated %>% 
  filter(view == "intra", Target == "IGKC") %>%
  arrange(-Importance)
SpatialFeaturePlot(seurat.vs, features = c("IGKC", "Plasma.Cells"))
res %>% plot_interaction_heatmap(view = "para.igkc_10")
SpatialFeaturePlot(seurat.vs, features = c("IGKC", "Endothelial"))
SpatialFeaturePlot(seurat.vs, features = c("Plasma.Cells", "Endothelial"))
SpatialFeaturePlot(seurat.vs, features = c("iCAFs", "Myoepithelial"))
# plot.features(filtered.objs[["SC2200259_9990"]], features=c("IGKC","CD8..T.cells", "B_Cells", "Plasma_Cells"),include.hne=TRUE)
```






```{r}
if(FALSE) {
  g <- plot.biotypes.across.samples(filtered.objs)
  png(paste0(plots_dir,"read-proportion-biotype-vs-sample.png"),height=1*480, width=2*480)
  print(g)
  d <- dev.off()
}
```

```{r}
deltas = get.visium.spot.distance.separation(filtered.objs[["SC2200259_9990"]])
dx <- deltas[1]
dy <- deltas[2]
```

```{r}
scale <- 2
stbl$col <- unlist(lapply(stbl$centroid.x, function(x) (floor(x * scale / dx ) + 1 - 15)))
stbl$row <- unlist(lapply(stbl$centroid.y, function(y) (floor(y * scale / dy ) + 1 - 9)))
all.cell.types <- unique(stbl$label)
stbl$pos.id <- paste0(stbl$row, "-", stbl$col)

cnt.tbl <- acast(stbl[, c("pos.id", "label")], pos.id ~ label)
pct.tbl <- t(apply(cnt.tbl, 1, function(row) row / sum(row)))
cnt.tbl <- cbind(cnt.tbl, total = rowSums(cnt.tbl))
colnames(pct.tbl) <- paste0(colnames(pct.tbl), ".frac")
all.tbl <- rbind(reshape2::melt(cnt.tbl), reshape2::melt(pct.tbl))
colnames(all.tbl) <- c("pos.id", "label", "value")
mat <- ddply(all.tbl, .variables = c("pos.id"), .fun = function(df) { vec <- df$value; names(vec) <- df$label; vec})
mat$pos.id <- as.character(mat$pos.id)
mat$row <- unlist(lapply(mat$pos.id, function(str) as.numeric(strsplit(str, split="-")[[1]][1])))
mat$col <- unlist(lapply(mat$pos.id, function(str) as.numeric(strsplit(str, split="-")[[1]][2])))


```


```{r}
#g <- create.feature.strip.plot(obj, features = c("Epithelial", "Myeloid", "CD14", "CD2", "LY75"), order.by = c("Epithelial", "Myeloid"))
#g$g
#g <- create.feature.strip.plot(obj, features = c("Epithelial", "Myeloid", "TLR4", "CD163", "SIGLEC1"), order.by = c("Epithelial", "Myeloid"))
```

```{r}
# From Karolina:
# CD8, CD103 (ITGAE), and CXCL13 (T cells) are essential for treatment response
# CD8+CD103+ T cells derived from chemokines might orchestrate response to therapy
# sCD14+ (stromal macrophages): CD14+CD2+LY75+ high macrophages have improved survival relative to low 
# iCD14+ (intratumoral macrophages): CD14+TLR4+CD163+SIGLEC
genes <- unique(c("CD8A", "CD14", "CD2", "LY75", "TLR4", "CD163", "SIGLEC1", "PTPRC", "CD3E", "CD8A", "ITGAE", "CXCL13"))
for(obj in filtered.objs) {
  g <- plot.gene.expression.distribution.relative.to.quantiles(obj, genes)
  sample <- obj[[]]$orig.ident[1]
  # g <- add.title.to.plot(g, sample)
  png(paste0(plots_dir, "/", sample, "-myeloid-gene-histograms.png"))
  print(g)
  d <- dev.off()
}
```

```{r}
# Output Myeloid cell genes of interest to Karolina
l_ply(datasets,
      .fun = function(dataset) {
        file <- paste0(plots_dir, "/", "myeloid-genes-", dataset, ".png")
        png(file, width = 2 * 480, height = 1 * 480)
        # g <- plot.features(filtered.objs[[dataset]], features = c("Epithelial", "CD8..T.cells", "Myeloid", "CD14", "CD2", "LY75", "TLR4", "CD163", "SIGLEC1"), include.hne = TRUE, include.umi.cnts = TRUE, include.feature.cnts = TRUE)
        # sCD14+ (stromal macrophages): CD14+CD2+LY75+ high macrophages have improved survival relative to low 
        # iCD14+ (intratumoral macrophages): CD14+TLR4+CD163+SIGLEC
        g <- plot.features(filtered.objs[[dataset]], features = c("Epithelial", "CD8..T.cells", "CD8A", "Myeloid", "CD14", "CD2", "LY75", "TLR4", "CD163", "SIGLEC1"), feature.names = c("Epithelial Fraction", "CD8 T Fraction", "CD8A", "Myeloid Fraction", "CD14 (monocytes)", "CD2 (sCD14+)", "LY75 (sCD14+)", "TLR4 (iCD14+)", "CD163 (iCD14+)", "SIGLEC1 (iCD14+)"), include.hne = TRUE, include.umi.cnts = TRUE, include.feature.cnts = FALSE)
        g <- add.title.to.plot(g, dataset)
        print(g)
        d <- dev.off()
      })
```

```{r}
# Output T cell genes of interest to Karolina
l_ply(datasets,
      .fun = function(dataset) {
        file <- paste0(plots_dir, "/", "cd8-t-cell-genes-", dataset, ".png")
        png(file, width = 2 * 480, height = 1 * 480)
        # ITGAE = CD103
        g <- plot.features(filtered.objs[[dataset]], features = c("Epithelial", "CD8..T.cells", "PTPRC", "CD3E", "CD8A", "ITGAE", "CXCL13", "Myeloid"), feature.names = c("Epitethial Fraction", "CD8 T Fraction", "CD45 (pan-immune)", "CD3E (T cell)", "CD8A", "CD103", "CXCL13", "Myeloid Fraction"), include.hne = TRUE, include.umi.cnts = TRUE, include.feature.cnts = FALSE)
        g <- add.title.to.plot(g, dataset)
        print(g)
        d <- dev.off()
      })
```





```{r}
# To do:
# 1. Cluster within each replicate
# 2. Limit to epithelial clusters.
# 3. Find markers of epi
# 4. Do fgsea on msidb.
# See here: https://crazyhottommy.github.io/scRNA-seq-workshop-Fall-2019/scRNAseq_workshop_3.html

# 1. Define signature for pathways (ssGSEA?)
# 2. Overlap for some pathways -- in particular, immune related. Also show immune and epi plots.

```


```{r}
biological.replicates <-
  list("9990" = c("SC2200259_9990", "SC2200260_9990"),
       "7031" = c("SC2200261_7031", "SC2200262_7031"),
       "4700" = c("SC2200263_4700", "SC2200264_4700"),
       "2171" = c("SC2200265_2171", "SC2200266_2171"))
```



```{r}
# Redo the above analysis restricted to epithelial cells. From a density plot, choose
# a cutoff of >0.6 to label epithelial cells.
epi.objs <-
  llply(filtered.objs,
        .fun = function(obj) {
          subset(x=obj, Epithelial > 0.8)
        })

# plot.features(epi.objs[[indx-1]], features=c("Epithelial"), include.hne=TRUE)
```

```{r}
bio.names <- c("9990", "4700", "2171")
nms <- names(biological.replicates[bio.names])
names(nms) <- nms
epi.only.bio.objs <-
  llply(nms,
        .fun = function(bio.repl) {
          tech.replicates <- biological.replicates[[bio.repl]]
          objs <- epi.objs[names(epi.objs) %in% tech.replicates]
          all.objs <- Reduce(merge, objs)
          Idents(all.objs) <- all.objs$orig.ident
          
          meta <- all.objs[[]]
          meta$row.name <- rownames(meta)
          meta$patient <- bio.repl
          rownames(meta) <- meta$row.name
          meta <- meta[, !(colnames(meta) %in% c("row.name"))]
          all.objs <- add.metadata.to.seurat.obj(all.objs, meta)
          
          all.objs <- apply.sctransform_(all.objs, use.v2 = TRUE)
          
          all.objs <- run.pca.umap(all.objs)
        })

epi.only.marker.tbls <-
  llply(epi.only.bio.objs,
        .fun = function(obj) {
          FindAllMarkers(obj, slot = "scale.data", assay = "SCT")
        })

suppressPackageStartupMessages(p_load(msigdbr))
suppressPackageStartupMessages(p_load(fgsea))

# Do gene set enrichment analysis against the hallmark gene sets from msigdb
m_df <- msigdbr(species = "Homo sapiens", category = "H")
fgsea_sets <- m_df %>% split(x = .$gene_symbol, f = .$gs_name)


hallmark.epi.only.res <-
  ldply(epi.only.marker.tbls,
        .fun = function(tbl) {
          ddply(tbl, .variables = c("cluster"),
                .fun = function(df) {
                  genes <- df %>% 
                    arrange(dplyr::desc(avg_diff), dplyr::desc(p_val)) %>%
                    dplyr::select(gene, avg_diff)
                  ranks <- tibble::deframe(genes)
                  fgseaRes <- fgsea(fgsea_sets, stats = ranks, nperm = 1000)
                  fgseaResTidy <- fgseaRes %>%
                    as_tibble() %>%
                    arrange(dplyr::desc(NES))
                  
                  res <- fgseaResTidy %>%
                    dplyr::select(-leadingEdge, -ES, -nMoreExtreme) %>% 
                    arrange(padj)
                  as.data.frame(res)
                })
        })
colnames(hallmark.epi.only.res)[1] <- "patient"

```

```{r}
bio.names <- c("9990", "4700", "2171")
for(bio.name in bio.names) {
  rep1 <- biological.replicates[[bio.name]][1]
  rep2 <- biological.replicates[[bio.name]][2]

  p1 <- plot.hne(epi.objs[[rep1]])
  p1 <- p1 + ggtitle(rep1)
  p2 <- plot.hne(epi.objs[[rep2]])
  p2 <- p2 + ggtitle(rep2)
  
  p.top <- plot_grid(p1,p2,nrow=1)
  
  p3 <- SpatialFeaturePlot(epi.objs[[rep1]], features=c("Epithelial"))
  p4 <- SpatialFeaturePlot(epi.objs[[rep2]], features=c("Epithelial"))

  p.bottom <- plot_grid(p3, p4, nrow=1)
  g <- plot_grid(p.top, p.bottom, nrow=2)
  
  png(paste0(plots_dir, "/hne-vs-epi-pt-", bio.name, ".png"))
  print(g)
  d <- dev.off()
}
```

```{r}
all.epi.only.bio.objs <- merge.sctransform.pca.umap(epi.only.bio.objs)
```

```{r}
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
gg <- DimPlot(all.epi.only.bio.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette)
gg <- gg + ggtitle("")
png(paste0(plots_dir, "/epi-only-umap.png"))
print(gg)
d <- dev.off()
```


```{r}
bio.names <- c("9990", "4700", "2171")
for(bio.name in bio.names) {

  rep1 <- biological.replicates[[bio.name]][1]
  rep2 <- biological.replicates[[bio.name]][2]
  p1 <- plot.hne(epi.objs[[rep1]])
  p1 <- p1 + ggtitle(rep1)
  p2 <- plot.hne(epi.objs[[rep2]])
  p2 <- p2 + ggtitle(rep2)

  p.top <- plot_grid(p1,p2,nrow=1)

  p.bottom <- SpatialDimPlot(epi.only.bio.objs[[bio.name]])
  g <- plot_grid(p.top, p.bottom, nrow=2)
  png(paste0(plots_dir, "/hne-vs-cluster-pt-", bio.name, ".png"))
  print(g)
  d <- dev.off()
}
```


```{r}
hallmark.epi.only.res$id <- paste0(hallmark.epi.only.res$patient, "-", hallmark.epi.only.res$cluster)
# Only plot pathways that are significant in _some_ cluster
sig.pathways <- unique(subset(hallmark.epi.only.res, padj < 0.05)$pathway)
tmp <- subset(hallmark.epi.only.res, pathway %in% sig.pathways)
mat <- reshape2::dcast(tmp[, c("pathway", "id", "NES")], pathway ~ id)
rownames(mat) <- gsub(mat$pathway, pattern="HALLMARK_", replacement="")
mat <- mat[, !(colnames(mat) %in% c("pathway"))]
mat[is.na(mat)] <- 0
sig.mat <- reshape2::dcast(tmp[, c("pathway", "id", "padj")], pathway ~ id)
rownames(sig.mat) <- gsub(sig.mat$pathway, pattern="HALLMARK_", replacement="")
sig.mat <- sig.mat[, !(colnames(sig.mat) %in% c("pathway"))]
sig.mat[is.na(sig.mat)] <- 1
col_fun = colorRamp2(c(0, 5, 10), c("blue", "white", "red"))
col.pt.ids <- unlist(lapply(colnames(mat), function(str) unlist(strsplit(str, split="-"))[1]))
colnames(mat) <- NULL
uniq.pts <- rev(unique(col.pt.ids))
pt_cols = viridis::viridis(n = length(uniq.pts),option = 'C')
names(pt_cols) <- uniq.pts

cell_fun = function(j, i, x, y, w, h, fill) {
  txt <- stars.pval(sig.mat[i,j])
  if(txt == ".") { txt <- ""}
  grid.text(txt, x, y - h/4)
}

png(paste0(plots_dir, "/epi-only-cluster-0.8-hallmark.png"), width = 2 * 480, height = 1  * 480)
Heatmap(as.matrix(mat), cell_fun = cell_fun, heatmap_legend_param = list(title = "NES"),
        row_names_gp = gpar(fontsize = 10), column_km = 2, row_km = 3,
        top_annotation = HeatmapAnnotation(patient = col.pt.ids, col = list(patient = pt_cols)))
d <- dev.off()
```
```{r}
obj <- filtered.objs[[1]]
obj <- epi.only.bio.objs[[2]]
# fgsea_sets$HALLMARK_INTERFERON_GAMMA_RESPONSE

sets <- 
  list("HALLMARK_APOPTOSIS" = "APOPTOSIS",
       "HALLMARK_INFLAMMATORY_RESPONSE" = "INFLAMMATORY_RESPONSE",
       "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" = "EMT",
       "HALLMARK_E2F_TARGETS" = "E2F_TARGETS",
       "HALLMARK_COAGULATION" = "COAGULATION",
       "HALLMARK_HYPOXIA" = "HYPOXIA",
       "HALLMARK_ANGIOGENESIS" = "ANGIOGENESIS",
       "HALLMARK_IL2_STAT5_SIGNALING" = "IL2_STAT5_SIGNALING",
       "HALLMARK_INTERFERON_ALPHA_RESPONSE" = "INTERFERON_ALPHA_RESPONSE",
       "HALLMARK_INTERFERON_GAMMA_RESPONSE" = "INTERFERON_GAMMA_RESPONSE",
       "HALLMARK_KRAS_SIGNALING_DN" = "KRAS_SIGNALING_DN",
       "HALLMARK_MTORC1_SIGNALING" = "MTORC1_SIGNALING",
       "HALLMARK_MYC_TARGETS_V1" = "MYC_TARGETS_V1",
       "HALLMARK_MYC_TARGETS_V2" = "MYC_TARGETS_V2",
       "HALLMARK_NOTCH_SIGNALING" = "NOTCH_SIGNALING")
sets <- rownames(mat)
names(sets) <- paste0("HALLMARK_", sets)
       

set.name <- "HALLMARK_APOPTOSIS"
short.set.name <- "APOP_PATH"
set.name <- "HALLMARK_INFLAMMATORY_RESPONSE"
short.set.name <- "INFLAM_PATH"
set.name <- "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION"
short.set.name <- "EMT_PATH"
set.name <- "HALLMARK_E2F_TARGETS"
short.set.name <- "E2F_PATH"
set.name <- "HALLMARK_COAGULATION"
short.set.name <- "COAG_PATH"
set.name <- "HALLMARK_HYPOXIA"
short.set.name <- "HYPOXIA_PATH"
set.name <- "HALLMARK_ANGIOGENESIS"
short.set.name <- "ANGIOGENESIS_PATH"

for(pt in names(epi.only.bio.objs)) {
  obj <- epi.only.bio.objs[[pt]]
  for(set.name in names(sets)) {
    short.set.name <- sets[[set.name]]
    set <- list(fgsea_sets[[set.name]][fgsea_sets[[set.name]] %in% rownames(obj)])
    obj <- AddModuleScore(obj, features = set, ctrl = 5, name = short.set.name, nbin=5)
    png(paste0(plots_dir, "/mod-score-", short.set.name, "-pt-", pt, ".png"))
    g <- SpatialFeaturePlot(obj, features=c(paste0(short.set.name, "1")))
    print(g)
    d <- dev.off()
  }
}

```


```{r}
# Exclude non-epi cells
epi.cell.cutoffs <- list("9990" = 0.75, "4700" = 0.75, "2171" = 0.75)
# Subset to clusters whose median RCTD epithelial proportion is
# above a threshold
nms <- names(epi.cell.cutoffs)
names(nms) <- nms
epi.objs <- 
  llply(nms,
        .fun = function(bio.repl) {
          obj <- bio.objs[[bio.repl]]
          med.epi.tbl <-
            ddply(obj[[]], .variables=c("seurat_clusters"), 
                  .fun = function(df) 
                    data.frame(med.epi = median(df$Epithelial)))
          med.epi.tbl <- 
            subset(med.epi.tbl, med.epi > epi.cutoffs[[bio.repl]])
          epi.bio.obj <- 
            subset(x = obj, subset = seurat_clusters %in% med.epi.tbl$seurat_clusters)
        })
  
```

```


```{r}
# Perform normalization, clustering across biological replicates
# Do this to separate out epithelial cells
nms <- names(biological.replicates)
names(nms) <- nms
bio.objs <-
  llply(nms,
        .fun = function(bio.repl) {
          tech.replicates <- biological.replicates[[bio.repl]]
          objs <- filtered.objs[names(filtered.objs) %in% tech.replicates]
          all.objs <- Reduce(merge, objs)
          Idents(all.objs) <- all.objs$orig.ident
          
          meta <- all.objs[[]]
          meta$row.name <- rownames(meta)
          meta$patient <- bio.repl
          rownames(meta) <- meta$row.name
          meta <- meta[, !(colnames(meta) %in% c("row.name"))]
          all.objs <- add.metadata.to.seurat.obj(all.objs, meta)
          
          all.objs <- apply.sctransform_(all.objs, use.v2 = TRUE)
          
          all.objs <- run.pca.umap(all.objs)
        })
```

```{r}
indx <- 1
gg <- DimPlot(bio.objs[[indx]], reduction = "umap", group.by = c("ident"))
gg <- FeaturePlot(bio.objs[[indx]], reduction = "umap", features = c("Epithelial"))
gg <- SpatialDimPlot(bio.objs[[indx]], group.by = c("seurat_clusters"))
VlnPlot(bio.objs[[indx]], features=c("Epithelial"), split.by=c("seurat_clusters")) + geom_boxplot() + geom_hline(yintercept = 0.6)
```


```{r}
merge.sctransform.pca.umap <- function(objs) {
  all.objs <- Reduce(merge, objs)
  Idents(all.objs) <- all.objs$orig.ident
  all.objs <- apply.sctransform_(all.objs, use.v2 = TRUE)
  all.objs <- run.pca.umap(all.objs)
  all.objs
}
```


```{r}
# We will exclude patient 7031, which has a high stromal content
epi.cutoffs <- list("9990" = 0.7, "4700" = 0.7, "2171" = 0.6)
# Subset to clusters whose median RCTD epithelial proportion is
# above a threshold
nms <- names(epi.cutoffs)
names(nms) <- nms
epi.bio.objs <- 
  llply(nms,
        .fun = function(bio.repl) {
          obj <- bio.objs[[bio.repl]]
          med.epi.tbl <-
            ddply(obj[[]], .variables=c("seurat_clusters"), 
                  .fun = function(df) 
                    data.frame(med.epi = median(df$Epithelial)))
          med.epi.tbl <- 
            subset(med.epi.tbl, med.epi > epi.cutoffs[[bio.repl]])
          epi.bio.obj <- 
            subset(x = obj, subset = seurat_clusters %in% med.epi.tbl$seurat_clusters)
        })
  
```

```{r}
epi.marker.tbls <-
  llply(epi.bio.objs,
        .fun = function(obj) {
          FindAllMarkers(obj, slot = "scale.data", assay = "SCT")
        })
```

```{r}
suppressPackageStartupMessages(p_load(msigdbr))
suppressPackageStartupMessages(p_load(fgsea))

# Do gene set enrichment analysis against the hallmark gene sets from msigdb
m_df <- msigdbr(species = "Homo sapiens", category = "H")
fgsea_sets <- m_df %>% split(x = .$gene_symbol, f = .$gs_name)


```

```{r}
hallmark.res <-
  ldply(epi.marker.tbls,
        .fun = function(tbl) {
          ddply(tbl, .variables = c("cluster"),
                .fun = function(df) {
                  genes <- df %>% 
                    arrange(dplyr::desc(avg_diff), dplyr::desc(p_val)) %>%
                    dplyr::select(gene, avg_diff)
                  ranks <- tibble::deframe(genes)
                  fgseaRes <- fgsea(fgsea_sets, stats = ranks, nperm = 1000)
                  fgseaResTidy <- fgseaRes %>%
                    as_tibble() %>%
                    arrange(dplyr::desc(NES))
                  
                  res <- fgseaResTidy %>%
                    dplyr::select(-leadingEdge, -ES, -nMoreExtreme) %>% 
                    arrange(padj)
                  as.data.frame(res)
                })
        })
colnames(hallmark.res)[1] <- "patient"
```

```{r}
hallmark.res$id <- paste0(hallmark.res$patient, "-", hallmark.res$cluster)
# Only plot pathways that are significant in _some_ cluster
sig.pathways <- unique(subset(hallmark.res, padj < 0.05)$pathway)
tmp <- subset(hallmark.res, pathway %in% sig.pathways)
mat <- reshape2::dcast(tmp[, c("pathway", "id", "NES")], pathway ~ id)
rownames(mat) <- gsub(mat$pathway, pattern="HALLMARK_", replacement="")
mat <- mat[, !(colnames(mat) %in% c("pathway"))]
sig.mat <- reshape2::dcast(tmp[, c("pathway", "id", "padj")], pathway ~ id)
rownames(sig.mat) <- gsub(sig.mat$pathway, pattern="HALLMARK_", replacement="")
sig.mat <- sig.mat[, !(colnames(sig.mat) %in% c("pathway"))]
```

```{r}
stop("stop")
```

```{r}
obj <- filtered.objs[[1]]
obj <- epi.bio.objs[[2]]
# fgsea_sets$HALLMARK_INTERFERON_GAMMA_RESPONSE
set <- list(fgsea_sets$HALLMARK_INTERFERON_GAMMA_RESPONSE[fgsea_sets$HALLMARK_INTERFERON_GAMMA_RESPONSE %in% rownames(obj)])
obj <- AddModuleScore(obj, features = set, ctrl = 5, name = "IFNG_PATH", nbin=5)
SpatialFeaturePlot(obj, features=c("IFNG_PATH1", "Epithelial"))

set <- list(fgsea_sets$HALLMARK_OXIDATIVE_PHOSPHORYLATION[fgsea_sets$HALLMARK_OXIDATIVE_PHOSPHORYLATION %in% rownames(obj)])

obj <- AddModuleScore(obj, features = set, ctrl = 5, name = "OXPHOS_PATH", nbin=5)
SpatialFeaturePlot(obj, features=c("OXPHOS_PATH1", "Epithelial"))




```


```{r}
col.pt.ids <- unlist(lapply(colnames(mat), function(str) unlist(strsplit(str, split="-"))[1]))
colnames(mat) <- NULL
uniq.pts <- rev(unique(col.pt.ids))
pt_cols = viridis::viridis(n = length(uniq.pts),option = 'C')
names(pt_cols) <- uniq.pts

cell_fun = function(j, i, x, y, w, h, fill) {
  txt <- stars.pval(sig.mat[i,j])
  if(txt == ".") { txt <- ""}
  grid.text(txt, x, y - h/4)
}

png(paste0(plots_dir, "/epi-cluster-hallmark.png"), width = 2 * 480, height = 1  * 480)
Heatmap(mat, cell_fun = cell_fun, heatmap_legend_param = list(title = "NES"),
        row_names_gp = gpar(fontsize = 10), column_km = 2, row_km = 3,
        top_annotation = HeatmapAnnotation(patient = col.pt.ids, col = list(patient = pt_cols)))
d <- dev.off()
```


```{r}
genes <-
  epi.marker.tbls[[1]] %>%
    dplyr::filter(cluster == "0") %>%
    arrange(dplyr::desc(avg_diff), dplyr::desc(p_val)) %>%
    dplyr::select(gene, avg_diff)

ranks <- tibble::deframe(genes)
```

```{r}
fgseaRes<- fgsea(fgsea_sets, stats = ranks, nperm = 1000)
```

```{r}
fgseaResTidy <- fgseaRes %>%
  as_tibble() %>%
  arrange(dplyr::desc(NES))


fgseaResTidy %>% 
  dplyr::select(-leadingEdge, -ES, -nMoreExtreme) %>% 
  arrange(padj) %>% 
  head()
```


```{r}
non.epi.bio.objs <- 
  llply(nms,
        .fun = function(bio.repl) {
          obj <- bio.objs[[bio.repl]]
          med.epi.tbl <-
            ddply(obj[[]], .variables=c("seurat_clusters"), 
                  .fun = function(df) 
                    data.frame(med.epi = median(df$Epithelial)))
          med.epi.tbl <- 
            subset(med.epi.tbl, med.epi < epi.cutoffs[[bio.repl]])
          non.epi.bio.obj <- 
            subset(x = obj, subset = seurat_clusters %in% med.epi.tbl$seurat_clusters)
        })
all.non.epi.bio.objs <- merge.sctransform.pca.umap(non.epi.bio.objs)
```


```{r}
all.epi.bio.objs <- merge.sctransform.pca.umap(epi.bio.objs)
```

```{r}
gg <- DimPlot(all.epi.bio.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette)
```

```{r}
gg <- DimPlot(all.non.epi.bio.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette)
```

```{r}
Idents(all.epi.bio.objs) <- "patient"
marker.tbl <- FindAllMarkers(all.epi.bio.objs, slot = "scale.data", assay = "SCT")
```

```{r}
Idents(all.non.epi.bio.objs) <- "patient"
non.epi.marker.tbl <- FindAllMarkers(all.non.epi.bio.objs, slot = "scale.data", assay = "SCT")
```

```{r}
Idents(all.non.epi.bio.objs) <- "orig.ident"
marker.tbl.2171 <- FindMarkers(all.non.epi.bio.objs, slot = "scale.data", assay = "SCT", ident.1 = "SC2200265_2171", ident.2 = "SC2200266_2171")
```


```{r}
obj <- all.epi.bio.objs

obj <- run.harmony.umap(obj, var = "patient")
gg <- DimPlot(obj, reduction = "harmony", group.by = c("orig.ident"), cols = cbbPalette)
```


```{r}
# Exclude any gene differentially expressed in the non-epithelial compartment
# from the variable epithelial genes and re-run PCA, etc. (which will use
# variable genes)
obj <- all.epi.bio.objs
#exclude <- non.epi.marker.tbl$gene
exclude <- c()
exclude <- unique(c(exclude,grep(rownames(obj), pattern="^MT-", value = TRUE)))
exclude <- unique(c(exclude,grep(rownames(obj), pattern="^RP[SL]", value = TRUE)))
obj <- obj[!(rownames(obj) %in% exclude),]
VariableFeatures(obj) <- VariableFeatures(obj)[!(VariableFeatures(obj) %in% exclude)]
# obj <- run.pca.umap(obj)
obj <- RunPCA(obj, npcs=20)
obj <- run.umap.on.pca(obj, dims=10:20)
gg <- DimPlot(obj, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette)
# gg <- DimPlot(obj, reduction = "pca", dims = c(3,4), group.by = c("orig.ident"), cols = cbbPalette)
# kruskal.test(weight ~ group, data = my_data)
```

```{r}
obj <- run.harmony.umap(obj, var = "patient")
gg <- DimPlot(obj, reduction = "harmony", group.by = c("orig.ident"), cols = cbbPalette)
```


```{r}
# To do:
# 1. Do non-epi?
# 2. kmeans of all.epi.bio.objs
# 3. What are markers of these different patient/clusters?
```


```{r}
# 2. UMAP -- color by sample. Is there a batch effect?
# 3. Subset to cancer. UMAP. Is there a batch effect?
# 4. Correct batch if necessary.
# 5. Cluster
```

```{r}
# Exclude 7031, which looks to have a lot of stromal
subset.objs <- filtered.objs[!grepl(names(filtered.objs), pattern="7031")]
all.subset.objs <- Reduce(merge, subset.objs)
Idents(all.subset.objs) <- all.subset.objs$orig.ident

VariableFeatures(all.subset.objs, assay="SCT") <- unique(unname(unlist(lapply(subset.objs, function(x) VariableFeatures(x, assay="SCT")))))
```




```{r}
all.subset.objs <- run.pca.umap(all.subset.objs)
```

```{r}
gg <- DimPlot(all.subset.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:6])
```

```{r}
all.subset.objs <- run.harmony.umap(all.subset.objs)
```

```{r}
gg <- DimPlot(all.subset.objs, reduction = "harmony", group.by = c("orig.ident"), cols = cbbPalette[1:6])
```


```{r}
all.filtered.objs <- Reduce(merge, filtered.objs)
Idents(all.filtered.objs) <- all.filtered.objs$orig.ident
DefaultAssay(all.filtered.objs) <- "SCT"
VariableFeatures(all.filtered.objs, assay="SCT") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="SCT")))))

```

```{r}
all.filtered.objs <- run.pca.umap(all.filtered.objs)
```

```{r}
objs.4700 <- subset(x = all.filtered.objs, subset = orig.ident %in% c("SC2200263_4700", "SC2200264_4700"))
gg <- DimPlot(objs.4700, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:2])
```

```{r}
gg <- FeaturePlot(all.filtered.objs, reduction = "umap", features = c("Stromal"))
```


```{r}
gg <- DimPlot(all.filtered.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8])
gg <- DimPlot(all.filtered.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8], split.by = c("orig.ident")) + facet_wrap(~ orig.ident)
gg <- FeaturePlot(objs.4700, reduction = "umap", features = c("Stromal"), split.by = c("orig.ident"))
gg <- FeaturePlot(all.filtered.objs, reduction = "umap", features = c("Epithelial"), split.by = c("orig.ident"), combine = F)
gg <- FeaturePlot(all.filtered.objs, reduction = "umap", features = c("Stromal"), split.by = c("orig.ident"), combine = F)
plot_grid(plotlist=gg, ncol=2)
```


```{r}
sc.all.filtered.objs <- all.filtered.objs
sc.all.filtered.objs <- apply.sctransform(list(sc.all.filtered.objs))[[1]]
sc.all.filtered.objs <- run.pca.umap(sc.all.filtered.objs)
```

```{r}
gg <- DimPlot(sc.all.filtered.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8])
```

```{r}
meta <- sc.all.filtered.objs[[]]
meta$row.name <- rownames(meta)
meta$patient <- unlist(lapply(meta$orig.ident, function(str) strsplit(str,split="_")[[1]][2]))
rownames(meta) <- meta$row.name
meta <- meta[, !(colnames(meta) %in% c("row.name"))]
sc.all.filtered.objs <- add.metadata.to.seurat.obj(sc.all.filtered.objs, meta)
```

```{r}
sc.all.filtered.objs <- run.harmony.umap(sc.all.filtered.objs, var = "patient")
```

```{r}
all.filtered.objs <- run.harmony.umap(all.filtered.objs, var = "patient")
```

```{r}
gg <- DimPlot(sc.all.filtered.objs, reduction = "harmony", group.by = c("orig.ident"), cols = cbbPalette[1:8])
```

```{r}
gg <- DimPlot(all.filtered.objs, reduction = "harmony", group.by = c("orig.ident"), cols = cbbPalette[1:8])
```


```{r}
meta <- all.filtered.objs[[]]
meta$row.name <- rownames(meta)
meta$patient <- unlist(lapply(meta$orig.ident, function(str) strsplit(str,split="_")[[1]][2]))
rownames(meta) <- meta$row.name
meta <- meta[, !(colnames(meta) %in% c("row.name"))]
all.filtered.objs <- add.metadata.to.seurat.obj(all.filtered.objs, meta)
```


```{r}
obj.sct <- all.filtered.objs
DefaultAssay(obj.sct) <- "SCT"
VariableFeatures(obj.sct, assay="SCT") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="SCT")))))
obj.sct <- RunPCA(obj.sct, verbose = FALSE)
ElbowPlot(obj.sct, ndims = 40)
mat <- Seurat::GetAssayData(obj.sct, assay = "SCT")
pca <- obj.sct[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(as.matrix(mat)))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance
cumVarExplained <- cumsum(varExplained)


```

```{r}
reduction <- "pca"
obj.sct <- FindNeighbors(obj.sct, reduction = reduction, dims = 1:20)
obj.sct <- FindClusters(obj.sct, verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = reduction, dims = 1:20)
```

```{r}
# There is a batch effect without harmony
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
gg <- DimPlot(obj.sct, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8])
```

```{r}
# Run harmony
obj.sct <- RunHarmony(obj.sct, group.by.vars = make.names("orig ident"))
```

```{r}
reduction <- "harmony"
obj.sct <- FindNeighbors(obj.sct, reduction = reduction, dims = 1:20)
obj.sct <- FindClusters(obj.sct, verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = reduction, dims = 1:20)
```
```{r}
# Immune cells are clustered together
gg <- FeaturePlot(obj.sct, reduction = "umap", features = c("Immune"))
```

```{r}
# Redo the above analysis restricted to epithelial cells. From a density plot, choose
# a cutoff of >0.6 to label epithelial cells.
epi.objs <-
  llply(filtered.objs,
        .fun = function(obj) {
          subset(x=obj, Epithelial > 0.7)
        })
```

```{r}
epi.objs <- apply.sctransform(epi.objs)
```
```{r}
sv.epi.objs <- epi.objs
```

```{r}
# Exclude some MALAT1, MT, RP, and IGH genes from matrix and variable genes and run PCA
epi.objs <-
  llply(epi.objs, 
        .fun = function(obj) {
          obj <- obj[!grepl("MALAT1", rownames(obj)), ]
          
          # Filter Mitocondrial
          obj <- obj[!grepl("^MT-", rownames(obj)), ]
          
          # Filter Ribossomal gene (optional if that is a problem on your data) data.filt
          obj <- obj[ ! grepl('^RP[SL]', rownames(obj)), ]
          
          obj <- obj[ ! grepl('^IGH', rownames(obj)), ]
          obj <- obj[ ! grepl('^IGK', rownames(obj)), ]
          obj <- obj[ ! grepl('^IGL', rownames(obj)), ]
          
          vf.all <- VariableFeatures(obj)

          exclude <- grepl(vf.all, pattern="^MT-")
          exclude <- exclude | grepl(vf.all, pattern="^IGH")
          exclude <- exclude | grepl(vf.all, pattern="^IGL")
          exclude <- exclude | grepl(vf.all, pattern="^IGK")
          exclude <- exclude | grepl(vf.all, pattern="^RP[SL]")
          exclude <- exclude | ("MALAT1" %in% vf.all)
          
          vf.use <- vf.all[!exclude]
          vf.use <- vf.use[vf.use %in% rownames(obj)]
          VariableFeatures(obj) <- vf.use

          n.pcs <- pmin(length(vf.use), round(0.15*ncol(obj)), round(0.15*nrow(obj)), 200)
          obj <- RunPCA(obj, verbose = FALSE, npcs=n.pcs, features=vf.use)
          obj
        })
```

```{r}
# Run PCA and UMAP on filtered
filtered.objs <-
  llply(filtered.objs, 
        .fun = function(obj) {
          reduction <- "pca"
          n.pcs <- pmin(round(0.15*ncol(obj)), round(0.15*nrow(obj)), 200)
          obj <- RunPCA(obj, verbose = FALSE, npcs=n.pcs, features=vf.use)
          n.pcs <- min(20, ncol(obj@reductions[[1]]@cell.embeddings))
          obj <- FindNeighbors(obj, reduction = reduction, dims = 1:n.pcs)
          obj <- FindClusters(obj, verbose = FALSE)
          obj <- RunUMAP(obj, reduction = reduction, dims = 1:n.pcs)
          obj
        })
```


```{r}
# Run UMAP on everything
epi.objs <-
  llply(epi.objs, 
        .fun = function(obj) {
          reduction <- "pca"
          n.pcs <- min(20, ncol(obj@reductions[[1]]@cell.embeddings))
          obj <- FindNeighbors(obj, reduction = reduction, dims = 1:n.pcs)
          obj <- FindClusters(obj, verbose = FALSE)
          obj <- RunUMAP(obj, reduction = reduction, dims = 1:n.pcs)
          obj
        })

```

```{r}
# Find all markers for all clusters in all samples
markers.tbl <-
  ldply(epi.objs, .parallel = FALSE,
        .fun = function(obj) {
          print(obj[[]]$orig.ident[1])
          FindAllMarkers(obj, assay = "SCT", slot = "scale.data")
        })
colnames(markers.tbl)[1] <- "orig.ident"
```

```{r}
my.dup <- function(x) duplicated(x, fromLast=TRUE) | duplicated(x, fromLast=FALSE)
```

```{r}
# Only keep significant markers that are specific to a cluster (within a sample)
sig.markers.tbl <- subset(markers.tbl, p_val_adj < 0.05)
sig.markers.tbl <-
  ddply(sig.markers.tbl, .variables = c("orig.ident"),
        .fun = function(df) {
          df[!my.dup(df$gene),,drop=FALSE]
          
        })
# Count the number of markers in each cluster
sig.markers.tbl <-
  ddply(sig.markers.tbl, .variables = c("orig.ident", "cluster"),
        .fun = function(df) {
          df$cnt <- nrow(df)
          df
        })


```

```{r}
overlaps <-
  ddply(sig.markers.tbl[, c("orig.ident", "cluster", "gene")], .variables = c("orig.ident", "cluster"),
        .fun = function(df1) {
          ret <- ddply(sig.markers.tbl[, c("orig.ident", "cluster", "gene")], .variables = c("orig.ident", "cluster"),
                .fun = function(df2) {
                  sample1 <- df1[1,"orig.ident"]
                  sample2 <- df2[1,"orig.ident"]
                  cluster1 <- df1[1, "cluster"]
                  cluster2 <- df2[1, "cluster"]
                  n1 <- nrow(df1)
                  n2 <- nrow(df2)
                  n.int <- length(intersect(df1$gene, df2$gene))
                  data.frame(
                    # sample1 = sample1, cluster1 = cluster1, 
                    # sample2 = sample2, cluster2 = cluster2,
                             n1 = n1, n2 = n2, n.intersect = n.int)
                    
                })
          colnames(ret) <- c("sample2", "cluster2", "n1", "n2", "n.intersect")
          ret
        })
colnames(overlaps)[1:2] <- c("sample1", "cluster1")
```


```{r}
overlaps <- overlaps[order(overlaps$sample1, overlaps$cluster1),]
overlaps <- subset(overlaps, n1 > 5 & n2 > 5)
overlaps$id1 <- paste0(overlaps$sample1, "-", overlaps$cluster1)
overlaps$id2 <- paste0(overlaps$sample2, "-", overlaps$cluster2)
lvls <- unique(overlaps$id1)
overlaps$id1 <- factor(overlaps$id1, levels=lvls)
overlaps$id2 <- factor(overlaps$id2, levels=lvls)
overlaps$frac1 <- overlaps$n.intersect / overlaps$n1
flag <- overlaps$id1 == overlaps$id2
# overlaps[flag, "frac1"] <- 0
g <- ggplot() + geom_tile(data = overlaps, aes(x = id1, y = id2, fill = frac1))
```

```{r}
foo <- ddply(overlaps, .variables = c("sample1", "cluster1"), 
      .fun =function(df) {
        ddply(df[, c("sample2", "cluster2", "frac1")], .variables = c("sample2"),
              .fun = function(df.in) {
                df.in[which.max(df.in$frac1)[1],,drop=F]
              })
        })
foo <- subset(foo, !((sample1 == sample2) & (cluster1 == cluster2)))
ddply(foo, .variables = c("sample1", "cluster1"), .fun = function(df) data.frame(min = min(df$frac1)))
# Consider sankey plot
```


```{r}
mat <- acast(overlaps[, c("id1", "id2", "frac1")], id1 ~ id2)
col.cluster <- unlist(lapply(colnames(mat), function(str) unlist(strsplit(str, split="-"))[2]))
col.ids <- unlist(lapply(colnames(mat), function(str) unlist(strsplit(str, split="-"))[1]))
col.sample.ids <- unlist(lapply(col.ids, function(str) unlist(strsplit(str, split="_"))[1]))
col.pt.ids <- unlist(lapply(col.ids, function(str) unlist(strsplit(str, split="_"))[2]))
rownames(mat) <- NULL
colnames(mat) <- NULL
# Heatmap(mat, cluster_rows = FALSE, cluster_columns = FALSE, row_split = col.pt.ids, column_split = col.pt.ids)
uniq.samples <- rev(unique(col.sample.ids))
uniq.pts <- rev(unique(col.pt.ids))
# Heatmap(mat, cluster_rows = FALSE, cluster_columns = FALSE, row_split = col.pt.ids, column_split = col.pt.ids, top_annotation = HeatmapAnnotation(sample = col.sample.ids, patient = col.pt.ids), right_annotation = rowAnnotation(sample = col.sample.ids, patient = col.pt.ids))
sample_cols = viridis::viridis(n = length(uniq.samples),option = 'C')
names(sample_cols) <- uniq.samples

Heatmap(mat, cluster_rows = FALSE, cluster_columns = FALSE, row_split = col.pt.ids, column_split = col.pt.ids, 
        top_annotation = HeatmapAnnotation(#patient = anno_block(gp = gpar(fill = 2:(2+length(uniq.pts)-1)), labels = uniq.pts, labels_gp = gpar(col = "white", fontsize=10)),
                                           sample = col.sample.ids, col = list(sample = sample_cols)),
        right_annotation = rowAnnotation(#patient = anno_block(gp = gpar(fill = 2:(2+length(uniq.pts)-1)), labels = uniq.pts, labels_gp = gpar(col = "white", fontsize=10)),
                                         sample = col.sample.ids, col = list(sample = sample_cols), show_legend=c(F,F,F)))
        
                                                                                                                                                                      

```


```{r}
# Plots:
# 1. all data (rough overlapping of stroma)
# 2. 4700 (shows no batch effect)



# 1. analyze/merge replicates together (without harmony) -> cluster
# 2. define cluster signatures (top genes -> GSVA or singleR or sum -> cpm -> correlation)
# 3. plot clusters spatially (confirm with cluster label)
# 4. median scale?
# 5. how many sequencing lanes? i.e., where are batch effects?
```


```{r}
exclude.b.cells <- rownames(subset(obj[[]], seurat_clusters == 8))
keep.cells <- rownames(subset(obj[[]], seurat_clusters != 8))
```


```{r}
obj <- epi.objs[[1]]

obj <- obj[!grepl("MALAT1", rownames(obj)), ]

# Filter Mitocondrial
obj <- obj[!grepl("^MT-", rownames(obj)), ]

# Filter Ribossomal gene (optional if that is a problem on your data) data.filt
obj <- obj[ ! grepl('^RP[SL]', rownames(obj)), ]

obj <- obj[ ! grepl('^IGH', rownames(obj)), ]
obj <- obj[ ! grepl('^IGK', rownames(obj)), ]
obj <- obj[ ! grepl('^IGL', rownames(obj)), ]

obj <- subset(obj, cells = keep.cells)

vf.all <- VariableFeatures(obj)


exclude <- grepl(vf.all, pattern="^MT-")
exclude <- exclude | grepl(vf.all, pattern="^IGH")
exclude <- exclude | grepl(vf.all, pattern="^IGL")
exclude <- exclude | grepl(vf.all, pattern="^IGK")
vf.use <- vf.all[!exclude]
vf.use <- vf.use[vf.use %in% rownames(obj)]
VariableFeatures(obj) <- vf.use

obj <- RunPCA(obj, verbose = FALSE, npcs=200, features=vf.use)

reduction <- "pca"
obj <- FindNeighbors(obj, reduction = reduction, dims = 1:20)
obj <- FindClusters(obj, verbose = FALSE)
obj <- RunUMAP(obj, reduction = reduction, dims = 1:20)
# gg <- DimPlot(obj, reduction = "umap")
gg <- DimPlot(obj, reduction = "umap", group.by = c("ident"), label=TRUE, label.size=8)
#               cols = cbbPalette, label.size=8)
# obj.markers <- FindAllMarkers(obj)
obj.markers <- FindAllMarkers(obj, slot="scale.data", assay="SCT")
# head(subset(obj.markers, cluster==0),n=20)

# SpatialDimPlot(obj, group.by=c("seurat_clusters"))
# tnbc.markers <- c("AZGP1", "KRT19", "RPS11", "SFRP1", "EPCAM", "TACSTD2", "MGP", "SFN", "GATA3", "S100A8", "CHI3L1", "KRT15", "KRT14", "NPY1R", "ASPN", "PEG3", "SCGB2A2")
# Markers of heterogeneity:
# https://pubmed.ncbi.nlm.nih.gov/28911002/
# "EGFR", "CCND1", "MYC"
```


```{r}
all.epi.objs <- Reduce(merge, epi.objs)
Idents(all.epi.objs) <- all.epi.objs$orig.ident
```
```{r}
obj.sct <- all.epi.objs

DefaultAssay(obj.sct) <- "SCT"
VariableFeatures(obj.sct, assay="SCT") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="SCT")))))

vf.all <- VariableFeatures(obj.sct)
exclude <- grepl(vf.all, pattern="^MT-")
exclude <- exclude | grepl(vf.all, pattern="^IGH")
exclude <- exclude | grepl(vf.all, pattern="^IGL")
exclude <- exclude | grepl(vf.all, pattern="^IGK")
vf.use <- vf.all[!exclude]

obj.sct <- RunPCA(obj.sct, verbose = FALSE, npcs=200, features=vf.use)
ElbowPlot(obj.sct, ndims = 40)
mat <- Seurat::GetAssayData(obj.sct, assay = "SCT")
pca <- obj.sct[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(as.matrix(mat[vf.use,])))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance
cumVarExplained <- cumsum(varExplained)

```

```{r}
reduction <- "pca"
obj.sct <- FindNeighbors(obj.sct, reduction = reduction, dims = 1:20)
obj.sct <- FindClusters(obj.sct, verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = reduction, dims = 1:20)

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
gg <- DimPlot(obj.sct, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8])
```

```{r}
obj.sct <- RunHarmony(obj.sct, group.by.vars = make.names("orig ident"))

reduction <- "harmony"
obj.sct <- FindNeighbors(obj.sct, reduction = reduction, dims = 1:20)
obj.sct <- FindClusters(obj.sct, verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = reduction, dims = 1:20)

gg <- DimPlot(obj.sct, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8])
```
```{r}
n.pcs <- 5
obj.sct <- FindNeighbors(obj.sct, reduction = reduction, dims = 1:n.pcs)
obj.sct <- FindClusters(obj.sct, resolution = 3, verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = reduction, dims = 1:n.pcs, n.neighbors=30L, min.dist=0.001, spread=3)

gg <- DimPlot(obj.sct, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8])
# gg <- FeaturePlot(obj.sct, reduction = "umap", features=c("Epithelial"))
```


```{r}
sample <- "SC2200259_9990" 
obj <- filtered.objs[[sample]]
meta <- obj[[]]
meta$row.name <- rownames(meta)
meta <- merge(meta[, c("row.name", "row", "col")], mat, by = c("row", "col"), all.x=TRUE)
rownames(meta) <- meta$row.name
meta <- meta[, !(colnames(meta) %in% c("row.name"))]
meta[is.na(meta)] <- 0
obj <- add.metadata.to.seurat.obj(obj, meta)
obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = "^MT-")
plot.features(obj, features="connec.frac")
# plot.features(obj, features=c("connec.frac", "COL1A1"), include.hne = TRUE)
# plot.features(obj, features=c("inflam.frac", "PTPRC"), include.hne = TRUE)
# plot.features(obj, features=c("neopla.frac", "EPCAM"), include.hne = TRUE)
# plot.features(obj, features=c("necros.frac", "total"), include.hne = TRUE)
# plot(obj[[]]$connec.frac, log(obj[[]]$nCount_Spatial))
# plot.features(obj, features=c("nCount_Spatial", "nFeature_Spatial", "COL1A1", "total", "connec.frac"), include.hne = TRUE)
g <- plot.features(obj, features=c("nCount_Spatial", "nFeature_Spatial", "COL1A1", "total", "connec.frac", "Stromal"), feature.names = c("nUMIs", "nGenes", "COL1A1", "Total Hovernet cells", "Fraction Stromal Cells (Hovernet)", "Fraction Stromal Cells (RCTD)"), include.hne = TRUE)
g <- add.title.to.plot(g, paste0("Stromal signals (", sample, ")"))
png(paste0(plots_dir, "/stromal-signals-", sample, ".png"), width = 2 * 480, height = 1  * 480)
print(g)
d <- dev.off()

g <- plot.features(obj, features = c("neopla.frac", "EPCAM"), feature.names = c("Fraction Neoplastic Cells (Hovernet)", "EPCAM"), include.hne = TRUE)
g <- add.title.to.plot(g, paste0("Tumor signals (", sample, ")"))
png(paste0(plots_dir, "/tumor-signals-", sample, ".png"), width = 2 * 480, height = 1  * 480)
print(g)
d <- dev.off()

g <- plot.features(obj, features = c("necros.frac", "percent.mt", "HMGB1", "nCount_Spatial", "nFeature_Spatial", "total"), feature.names = c("Fraction Necrotic Cells (Hovernet)", "Percent MT", "HMGB1", "nUMIs", "nGenes", "Total Hovernet cells"), include.hne = TRUE)
g <- add.title.to.plot(g, paste0("Necrosis signals (", sample, ")"))
png(paste0(plots_dir, "/necrosis-signals-", sample, ".png"), width = 2 * 480, height = 1  * 480)
print(g)
d <- dev.off()

g <- plot.features(obj, features = c("PTPRC", "inflam.frac", "CD3E", "T_Cells", "CD19", "B_Cells"), feature.names = c("CD45 (pan-immue)", "Fraction Immune Cells (Hovernet)",  "CD3E (T cell)", "Fraction T Cells (RCTD)", "CD19 (B cell)", "Fraction B Cells (RCTD)"), include.hne = TRUE, nrow=2)
g <- add.title.to.plot(g, paste0("Immune signals (", sample, ")"))
png(paste0(plots_dir, "/immune-signals-", sample, ".png"), width = 2 * 480, height = 1  * 480)
print(g)
d <- dev.off()
```

```{r}

# Make plots of hne, stroma vs tumor, and individual genes in CD14+ spots
#sample <- "SC2200259_9990" 
#obj <- filtered.objs[[sample]]

df <- obj[[]]
df$status <- "tumor"
df[df$neopla.frac < 0.5,"status"] <- "stroma"

#df$status <- "other"
#df[df$CD8..T.cells > 0.01,"status"] <- "CD8T"
#df[df$Myeloid > 0.01,"status"] <- "myeloid"

df$status <- factor(df$status)
obj <- AddMetaData(obj, df[, "status", drop=FALSE])

expr <- GetAssayData(obj, assay="Spatial", slot="counts")
md <- obj[[]]
common <- intersect(colnames(expr), rownames(md))
expr <- expr[, common]
md <- md[common,]
# sCD14+ (stromal macrophages): CD14+CD2+LY75+ high macrophages have improved survival relative to low 
# iCD14+ (intratumoral macrophages): CD14+TLR4+CD163+SIGLEC
genes <- c( "EPCAM", "PTPRC", "CD14", "CD163","CD2", "LY75", "TLR4", "SIGLEC1")
names(genes) <- genes
df <- merge(md, t(expr[genes, ]), by = "row.names")

flag <- df[,"CD14"] > 0
df <- df[flag, ]
g <- ggplot(data = df, aes(x = status, y = SIGLEC1)) + geom_violin()

g0 <- plot.hne(obj)
g1 <- SpatialPlot(obj, group.by=c("status")) + theme(legend.text = element_text(size=10)) + guides(fill = guide_legend(override.aes = list(size = 5)))
plts <- llply(genes, .fun = function(gene) ggplot(data = df, aes_string(x = "status", y = gene)) + geom_boxplot() + theme(text = element_text(size = 20)))

gtot <- plot_grid(plotlist=c(list(g0), list(g1), plts), nrow=2)
png(paste0(plots_dir, "/", sample, "-tumor-vs-stroma-expression.png"), width = 3 * 480, height = 2 * 480)
print(gtot)
d <- dev.off()

g <- ggplot(data = df, aes(x = status, y = nCount_Spatial)) + geom_violin() + xlab("region") + ylab("nUMIs") + theme(text = element_text(size = 20))
png(paste0(plots_dir, "/", sample, "-umis-vs-region.png"), width = 2 * 480, height = 1 * 480)
gtot <- plot_grid(g0, g1, g, nrow=1, labels = "AUTO")
print(gtot)
d <- dev.off()
```


```{r}
# This requires SCT be run
if(FALSE) {
plot(density(as.numeric(GetAssayData(obj,slot="data",assay="SCT")["EPCAM",])))
plot(density(as.numeric(GetAssayData(obj,slot="counts",assay="SCT")["EPCAM",])))
plot(density(as.numeric(GetAssayData(obj,slot="scale.data",assay="SCT")["EPCAM",])))
plot(density(obj[[]]$neopla.frac))
plot(hist(obj[[]]$Epithelial))

vals <- list(
  "raw counts" = as.numeric(GetAssayData(obj,slot="counts",assay="Spatial")["EPCAM",]),
  "SCT (counts)" = as.numeric(GetAssayData(obj,slot="counts",assay="SCT")["EPCAM",]),
  "SCT (data)" = as.numeric(GetAssayData(obj,slot="data",assay="SCT")["EPCAM",]),
  "SCT (scale.data)" = as.numeric(GetAssayData(obj,slot="scale.data",assay="SCT")["EPCAM",]),
  "RCTD Epithelial Fraction" = obj[[]]$Epithelial,
  "Hovernet Neoplastic Fraction" = obj[[]]$neopla.frac)

nms <- names(vals)
names(nms) <- nms
plts <- 
  llply(nms,
        .fun = function(nm) {
          g <- ggplot(data = data.frame(val = vals[[nm]]), aes(x = val)) + geom_histogram()
          g <- g + ggtitle(nm)
          g <- g + xlab("EPCAM")
          g
        })
  
             

df <- obj[[]]
#df$status <- 0
#df[df$neopla.frac < 0.5,"status"] <- 1
df$status <- "tumor"
#df[df$neopla.frac < 0.5,"status"] <- "stroma"
df[df$Epithelial < 0.5,"status"] <- "stroma"
df$status <- factor(df$status)
obj <- AddMetaData(obj, df[, "status", drop=FALSE])
# plot.features(obj, features=c("status"), include.hne=TRUE)
# g <- SpatialPlot(obj, group.by=c("status")) + theme(text = element_text(size=20))
g1 <- SpatialPlot(obj, group.by=c("status")) + theme(legend.text = element_text(size=10)) + guides(fill = guide_legend(override.aes = list(size = 5))) + labs(fill = "RCTD\nPrediction")
g1 <- g1 + ggtitle("Stroma = RCTD Epithelial < 0.5")

df$status <- "tumor"
df[df$neopla.frac < 0.5,"status"] <- "stroma"
df$status <- factor(df$status)
obj <- AddMetaData(obj, df[, "status", drop=FALSE])

g2 <- SpatialPlot(obj, group.by=c("status")) + theme(legend.text = element_text(size=10)) + guides(fill = guide_legend(override.aes = list(size = 5)))
g2 <- g2 + ggtitle("Stroma = Hovernet Neoplastic Fraction < 0.5")

g0 <- plot.hne(obj)

gtot <- plot_grid(plotlist=c(plts, list(g0), list(g1), list(g2)), labels="AUTO")
png(paste0(plots_dir, "/tumor-signal-epcam-rctd-hov.png"), width = 2 * 480, height = 2  * 480)
print(gtot)
d <- dev.off()
}
```

```{r}
sample <- "SC2200259_9990" 
obj <- filtered.objs[[sample]]

df <- obj[[]]
df$status <- "Tumor"
df[df$Epithelial < 0.5,"status"] <- "Stroma"
df$status <- factor(df$status)
obj <- AddMetaData(obj, df[, "status", drop=FALSE])

DefaultAssay(obj) <- "Spatial"

#g1 <- SpatialPlot(obj, group.by=c("status")) + theme(legend.text = element_text(size=10)) + guides(fill = guide_legend(override.aes = list(size = 5))) + labs(fill = "RCTD\nPrediction")

g1 <- plot.spatial(obj, features = c("Epithelial"), legend.name = "RCTD\nEpithelial\nFraction", rescale.legend = FALSE)

g.stromal <- plot.spatial(obj, features = c("Stromal"), legend.name = "RCTD\nStromal\nFraction", rescale.legend = FALSE)

g2 <- plot.spatial(obj, features = c("EPCAM"), legend.name = "EPCAM", rescale.legend = FALSE) + theme(legend.text = element_text(size=10))
  

g3 <- plot.spatial(obj, features = c("PTPRC"), legend.name = "CD45", rescale.legend = FALSE) + theme(legend.text = element_text(size=10))

meta <- obj[[]]
meta$row.name <- rownames(meta)
meta <- merge(meta[, c("row.name", "row", "col")], mat, by = c("row", "col"), all.x=TRUE)
rownames(meta) <- meta$row.name
meta <- meta[, !(colnames(meta) %in% c("row.name"))]
meta[is.na(meta)] <- 0
obj <- add.metadata.to.seurat.obj(obj, meta)

g4 <- plot.spatial(obj, features = c("connec.frac"), legend.name = "Hover-Net\nStromal\nFraction", rescale.legend = FALSE)

g.vim <- plot.spatial(obj, features = c("VIM"), legend.name = "VIM", rescale.legend = FALSE)

g.immune <- plot.spatial(obj, features = c("Immune"), legend.name = "RCTD\nImmune\nFraction", rescale.legend = FALSE)

g0 <- plot.hne(obj, keep.invisible.legend = TRUE)

gtot <- plot_grid(NULL, g0, NULL, g2, g.vim, g3, g1, g.stromal, g.immune, nrow=3, labels=c("","a","","b","c","d","e","f","g"))
png(paste0(plots_dir, "/tumor-stromal-immune-markers-and-deconv.png"), width = 1.5 * 480, height = 1 * 480)
print(gtot)
d <- dev.off()

gtot <- plot_grid(g0, g2, g1, g3, nrow=2, labels="auto")
png(paste0(plots_dir, "/tumor-stromal-immune-signals.png"), width = 2 * 480, height = 1.5  * 480)
print(gtot)
d <- dev.off()

gtot <- plot_grid(g0, g4, nrow=1, labels="auto")
png(paste0(plots_dir, "/hovernet-stromal-signal.png"), width = 2 * 480, height = 0.75  * 480)
print(gtot)
d <- dev.off()
```

```{r}
gtot <- plot_grid(g0, g2, nrow=1, labels="AUTO")
png(paste0(plots_dir, "/hovernet-epcam-signal.png"), width = 2 * 480, height = 0.75  * 480)
print(gtot)
d <- dev.off()

pdf(paste0(plots_dir, "/hovernet-epcam-signal.pdf"), width = 2 * 480, height = 0.75  * 480)
print(gtot)
d <- dev.off()
```

```{r}
stop("stop")
```


```{r}
# Let's try to recapitulate interactions from 
# https://www.embopress.org/doi/full/10.15252/embj.2019104063
# (see Dataset EV3 and supp fig S4)
# which uses ligand-receptor pairs from Ramilowski 2015:
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4525178/
# See https://fantom.gsc.riken.jp/5/suppl/Ramilowski_et_al_2015/
# and specifically
# https://fantom.gsc.riken.jp/5/suppl/Ramilowski_et_al_2015/data/PairsLigRec.txt
# Subset PairsLigRec.txt to those in the above EV3 dataset
all.lr.df <- fread("PairsLigRec.txt")
tnbc.lr.df <- read.xlsx("Dataset_EV3.xlsx", sheet=1)
tnbc.lr.df <- merge(tnbc.lr.df, unique(all.lr.df[, c("Pair.Name", "Ligand.ApprovedSymbol", "Receptor.ApprovedSymbol")]), by.x = c("interaction"), by.y = c("Pair.Name"))

# Read in the receptor / ligand pairs highlighted in Fig 5 of the above paper
tnbc.fig5.lr.df <- read.xlsx("Wu_EMBOJ_Fig5.xlsx", sheet=1)
```

```{r}

tnbc.lr.df$Ligand.ApprovedSymbol %in% rownames(Seurat::GetAssayData(obj, assay="Spatial"))
tnbc.lr.df$Receptor.ApprovedSymbol %in% rownames(Seurat::GetAssayData(obj, assay="Spatial"))

# to do:
# average expression of scaled data per cell type
```

```{r}
set_element_size <- 
function (p = NULL, element, g = ggplot2::ggplotGrob(p), file = NULL, 
    margin = unit(1, "mm"), width = unit(4, "cm"), height = unit(4, 
        "cm")) 
{
    panels <- grep(element, g$layout$name)
    panel_index_w <- unique(g$layout$l[panels])
    panel_index_h <- unique(g$layout$t[panels])
    nw <- length(panel_index_w)
    nh <- length(panel_index_h)
    g$widths[panel_index_w] <- rep(width, nw)
    g$heights[panel_index_h] <- rep(height, nh)
    if (!is.null(file)) {
        ggplot2::ggsave(file, g, width = grid::convertWidth(sum(g$widths) + 
            margin, unitTo = "in", valueOnly = TRUE), height = grid::convertHeight(sum(g$heights) + 
            margin, unitTo = "in", valueOnly = TRUE))
    }
    g
}

get_element_size <- 
function (p = NULL, element, g = ggplot2::ggplotGrob(p), file = NULL, 
    margin = unit(1, "mm"), width = unit(4, "cm"), height = unit(4, 
        "cm")) 
{
    panels <- grep(element, g$layout$name)
    panel_index_w <- unique(g$layout$l[panels])
    panel_index_h <- unique(g$layout$t[panels])
    nw <- length(panel_index_w)
    nh <- length(panel_index_h)
    return(list("widths" = g$widths[panel_index_w], "heights" = g$heights[panel_index_h]))
}

```


```{r}
plot.ligand.receptor <- function(rctd, pop.weights, expr, ligand.pop, receptor.pop, ligand.gene, receptor.gene, expr.legend.name = "CPM") {
  g1 <- plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(pop.weights)[, ligand.pop], size = 1, ylimit = c(0, max(pop.weights[,ligand.pop])))
  g1 <- g1 + theme_void() + scale_y_reverse()
  g1 <- g1 + ggtitle(paste0("Ligand cell type: ", ligand.pop))
  g1 <- g1 + labs(color="fraction")
  g2 <- plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(pop.weights)[, receptor.pop], size = 1, ylimit = c(0, max(pop.weights[,receptor.pop])))
  g2 <- g2 + theme_void() + scale_y_reverse()
  g2 <- g2 + ggtitle(paste0("Receptor cell type: ", receptor.pop))
  g2 <- g2 + labs(color="fraction")
  g3 <- plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(expr)[ligand.gene,], size = 1, ylimit = c(0, max(expr[ligand.gene,])))
  g3 <- g3 + theme_void() + scale_y_reverse()
  g3 <- g3 + ggtitle(paste0("Ligand: ", ligand.gene))
  g3 <- g3 + labs(color=expr.legend.name)
  g4 <- plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(expr)[receptor.gene,], size = 1, ylimit = c(0, max(expr[receptor.gene,])))
  g4 <- g4 + theme_void() + scale_y_reverse()
  g4 <- g4 + ggtitle(paste0("Receptor: ", receptor.gene))
  g4 <- g4 + labs(color=expr.legend.name)
  plot_grid(g1,g2,g3,g4, nrow=2)
}


```

```{r}
# g <- plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(pop.weights)[, pop], size = 1, ylimit = c(0, mx))
# g <- plot.population.weights(rctd, pop.weights, cell.types.to.plot, obj = obj, show.hne = TRUE, use.absolute.scale = TRUE)
```


```{r}
myRCTD <- rctds[[1]]
barcodes <- colnames(myRCTD@spatialRNA@counts)
weights <- myRCTD@results$weights
norm_weights <- normalize_weights(weights)
cell_types <- c("Epithelial_Basal_Cycling", "myCAFs", "iCAFs")
print(head(norm_weights[,cell_types])) # observe weight values
# plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(d)f[, pop]) 
plot_puck_continuous(myRCTD@spatialRNA, barcodes, norm_weights[,'Epithelial_Basal_Cycling'], 
                     ylimit = c(0,1), 
                     title ='plot of Epithelial_Basal_Cycling weights') 
max.pops <- apply(norm_weights,1,function(row) colnames(norm_weights)[which.max(row)])
#plot_class(myRCTD@spatialRNA, barcodes,factor(max.pops))

pop <- "Epithelial_Basal_Cycling"
plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(df)[, pop], size = 1, ylimit = c(0, max(df[,pop])))

plot.population <- function(rctd, pop) {
  weights <- rctd@results$weights
  barcodes <- colnames(rctd@spatialRNA@counts)
  norm_weights <- normalize_weights(weights)
  max.pops <- apply(norm_weights,1,function(row) colnames(norm_weights)[which.max(row)])
  pops <- rep("other", length(max.pops))
  names(pops) <- names(max.pops)
  pops[max.pops == pop] <- pop
  plot_class(rctd@spatialRNA, barcodes, factor(pops)) + scale_y_reverse()
  
}

plot.populations <- function(rctd, pop.list) {
  weights <- rctd@results$weights
  barcodes <- colnames(rctd@spatialRNA@counts)
  norm_weights <- normalize_weights(weights)
  max.pops <- apply(norm_weights,1,function(row) colnames(norm_weights)[which.max(row)])
  pops <- rep("other", length(max.pops))
  names(pops) <- names(max.pops)
  for(pop.name in names(pop.list)) {
    flag <- unlist(lapply(max.pops, function(x) x %in% pop.list[[pop.name]]))
    pops[flag] <- pop.name
  }
  plot_class(rctd@spatialRNA, barcodes, factor(pops)) + scale_y_reverse()
  
}

```


```{r}
# make.ligand.receptor.plots(rctds[[i]], filtered.objs.[[i]], tnbc.fig5.lr.df)

make.ligand.receptor.plots <- function(rctd, obj, lr.df, sample.name, output.dir) {
  library(edgeR)
  pop.weights <- format.rctd.output(rctd)
  mat <- Seurat::GetAssayData(obj, assay="Spatial")
  common.spots <- intersect(rownames(pop.weights),colnames(mat))
  mat <- mat[, common.spots]
  pop.weights <- pop.weights[common.spots,]
  expr <- cpm(as.matrix(mat), log = FALSE)
  flag <- ( lr.df$ligand %in% rownames(expr) ) & ( lr.df$receptor %in% rownames(expr) ) 
  lr.df <- lr.df[flag, ]
  for(i in 1:nrow(lr.df)) {
    ligand.pop <- lr.df[i, "ligand.cell.type"]
    receptor.pop <- lr.df[i, "receptor.cell.type"]
    ligand.gene <- lr.df[i, "ligand"]
    receptor.gene <- lr.df[i, "receptor"]
    title <- paste0(sample.name, ": ", ligand.gene, " (", ligand.pop, ") - ", receptor.gene, " (", receptor.pop, ")")
    print(title)
    g <- plot.ligand.receptor(rctd, pop.weights, expr, ligand.pop, receptor.pop, ligand.gene, receptor.gene)
    g <- add.title.to.plot(g, title) 
    file <- make.names(paste0("lr-",sample.name, "-",ligand.pop,"-",receptor.pop,"-",ligand.gene,"-",receptor.gene))
    file <- paste0(output.dir, "/", file, ".tif")
    png(file, width = 2 * 480)
    print(g)
    d <- dev.off()
  }
  
}

```

```{r}
calculate.ligand.receptor.interaction.spatial.correlation <- function(rctd, obj, lr.df) {
  library(edgeR)
  
  pop.weights <- format.rctd.output(rctd)
  pos <- obj[[]][, c("row", "col")]
  mat <- Seurat::GetAssayData(obj, assay="Spatial")

  common.spots <- intersect(rownames(pos), rownames(pop.weights))
  common.spots <- intersect(common.spots,colnames(mat))

  mat <- mat[, common.spots]
  pos <- pos[common.spots,]
  pop.weights <- pop.weights[common.spots,]

  expr <- cpm(as.matrix(mat), log = FALSE)
  #W <- 1/as.matrix(dist(pos))
  #diag(W) <- 0
  W <- gausskernel(pos,sigma=1)

  flag <- ( lr.df$ligand %in% rownames(expr) ) & ( lr.df$receptor %in% rownames(expr) ) 
  lr.df <- lr.df[flag, ]
  lr.df$bivar.morans.i <- NA
  p.vals <- 
    unlist(llply(1:nrow(lr.df), .parallel = TRUE,
                 .fun = function(i) {
    ligand.pop <- lr.df[i, "ligand.cell.type"]
    receptor.pop <- lr.df[i, "receptor.cell.type"]
    ligand.gene <- lr.df[i, "ligand"]
    receptor.gene <- lr.df[i, "receptor"]
    min.pop <- unlist(apply(pop.weights[, c(ligand.pop, receptor.pop)], 1, min))
    df <- data.frame(min.pop = min.pop, g1 = expr[ligand.gene,,drop=TRUE], g2 = expr[receptor.gene,,drop=TRUE])
    rownames(df) <- common.spots

    res1 <- BivariateMoransI(df[,c("min.pop","g1")], W)
    res2 <- BivariateMoransI(df[,c("min.pop","g2")], W)
    p.max <- max(res1$p.val["min.pop","g1"], res2$p.val["min.pop","g2"])
    p.max
                 }))
  lr.df$bivar.morans.i <- p.vals
  lr.df <- lr.df[order(lr.df$bivar.morans.i, decreasing=FALSE),]
  lr.df
}

calculate.population.spatial.correlation <- function(rctd, obj) {

  pop.weights <- format.rctd.output(rctd)
  pos <- obj[[]][, c("row", "col")]

  common.spots <- intersect(rownames(pos), rownames(pop.weights))

  pos <- pos[common.spots,]
  pop.weights <- pop.weights[common.spots,]

  W <- gausskernel(pos,sigma=2)

  cols <- colnames(pop.weights)
  cols <- cols[!(cols %in% c("x","y"))]
  df <- as.data.frame(t(combn(cols,2)))
  colnames(df) <- c("pop1", "pop2")
  flag <- df$pop1 != df$pop2
  df$pop1 <- as.character(df$pop1)
  df$pop2 <- as.character(df$pop2)
  df <- df[flag,]
  
  p.vals <- 
    unlist(llply(1:nrow(df), .parallel = TRUE,
                 .fun = function(i) {
    pop1 <- df[i, "pop1"]
    pop2 <- df[i, "pop2"]
    mat <- pop.weights[, c(pop1, pop2)]
    res <- BivariateMoransI(mat, W)
    res$p.val[pop1, pop2]
                 }))
  df$bivar.morans.i <- p.vals
  df <- df[order(df$bivar.morans.i, decreasing=FALSE),]
  df
}

```

```{r}
nms <- names(filtered.objs)
names(nms) <- nms
scor.file <- paste0(plots_dir, "/scor.csv")
if(!file.exists(scor.file)) {
scor <-
  ldply(nms,
        .fun = function(nm) {
          rctd <- rctds[[nm]]
          obj <- filtered.objs[[nm]]
          lr.df <- tnbc.fig5.lr.df
          calculate.ligand.receptor.interaction.spatial.correlation(rctd, obj, lr.df)
        })
colnames(scor)[1] <- "sample"
scor <- scor[order(scor$bivar.morans.i, decreasing=FALSE),]
write.table(file=scor.file, scor, sep=",", row.names=FALSE, col.names=TRUE, quote=FALSE)
}
scor <- read.table(scor.file, sep=",", header=TRUE)

```

```{r}
nms <- names(filtered.objs)
names(nms) <- nms
pop.file <- paste0(plots_dir, "/pop-scor.csv")
if(!file.exists(pop.file)) {
pop.scor <-
  ldply(nms,
        .fun = function(nm) {
          rctd <- rctds[[nm]]
          obj <- filtered.objs[[nm]]
          calculate.population.spatial.correlation(rctd, obj)
        })
colnames(pop.scor)[1] <- "sample"
pop.scor <- pop.scor[order(pop.scor$bivar.morans.i, decreasing=FALSE),]
write.table(file=pop.file, pop.scor, sep=",", row.names=FALSE, col.names=TRUE, quote=FALSE)
}
pop.scor <- read.table(pop.file, sep=",", header=TRUE)
```


```{r}
scor.meta <- ddply(scor, .variables = c("interaction", "ligand", "receptor", "ligand.cell.type", "receptor.cell.type"), .fun = function(df) data.frame(pval.max = max(df$bivar.morans.i)))
scor.meta <- scor.meta[order(scor.meta$pval.max, decreasing=FALSE),]
```

```{r}
pop.scor.meta <- ddply(pop.scor, .variables = c("pop1", "pop2"), .fun = function(df) data.frame(pval.max = max(df$bivar.morans.i)))
pop.scor.meta <- pop.scor.meta[order(pop.scor.meta$pval.max, decreasing=FALSE),]
```

```{r}

```


```{r}
bar <- (expr[c("MYC","ITGAE"),])
foo <- reshape2::melt(bar)
foo$Var2 <- factor(foo$Var2, levels = lvls)
ggplot(data = foo) + geom_col(aes(x = Var2, y = log2(value))) + facet_wrap(~Var1, scales="free")
ii<-do.call('order', as.data.frame(t(bar)))
bar <- bar[,ii]
lvls <- colnames(bar)
# TODO:
# 1. Strip plots (columns are spots) of: -- also add cancer and order spots by cancer, then myeloid, then CD14, then etc. 
# 1a. iCD14+ (CD14-TLR4-CD163-SIGLEC); sCD14+ (CD14-CD2-LY75)
# 1b. CD8+CD103+CXCL13+ T cells in tumor nests
# 3. Sort stroma vs cancer spots (whether cancer > 50%?) -- look at CD14/etc within these
# 4. Look for T cell siglling involving CXCL13 and either myeloid or cancer cells
# 5. Look for interactions with myeloid cells
# 6. Can we do de novo discovery? Previously was using those from publication.

features <- c("Epithelial", "Myeloid", "CD14", "CD2", "LY75", "TLR4", "CD163", "SIGLEC1")
order.by <- features
m <- create.feature.split.plot(obj, features, order.by)

# TODO:
genes <- unique(c("CD8A", "CD14", "CD2", "LY75", "TLR4", "CD163", "SIGLEC1", "PTPRC", "CD3E", "CD8A", "ITGAE", "CXCL13"))
                                                                  
# 1. Function that:
#    1a. Plots gene (row) boxplots (expr col)
#    1b. Plots density along with quintiles (bottom panel)
# 2. Function that does above over samples
# 3. Call on Karolina genes
# 4. Call on LR genes
# 5. Call on transcription factor genes
# 1. Compute all LR expressions in a sample
# 2. Try computing boxplot of all LR within a sample with quantiles
# 3. Compute median and ranges within sample
# 4. Concatenate across all samples
# 5. Output as table
# 3. 
# 1. Calculate bivariateMoran'sI between min(pop1,pop2), gene1 and min(pop1,pop2), gene2 and take max pvalue
# 2. Plot distribution of ligand-receptor pairs from pub relative to quintiles? FPKMs?

flag <- merged["Myeloid", ] > 0.2
tmp <- merged[, flag]
flag <- !(rownames(tmp) %in% c("Myeloid", "Epithelial"))
tmp[flag, ] <- t(apply(tmp[flag,], 1, "/", as.numeric(tmp["Myeloid",])))
m <- reshape2::melt(as.matrix(tmp))

  colnames(m) <- c("feature", "sample", "value")
  if(!is.null(order.by)) {
    tmp <- rbind(mat[rownames(mat) %in% order.by,], t(meta[, colnames(meta) %in% order.by]))
    order.by <- order.by[order.by %in% rownames(tmp)]
    tmp <- tmp[order.by,]
    ii <- do.call('order', as.data.frame(t(tmp)))
    lvls <- colnames(tmp)[ii] 
    m$sample <- factor(m$sample, levels = lvls)
    m$feature <- factor(m$feature, levels = rev(c(order.by, features[!(features %in% order.by)])))
  }
  g <- ggplot(data = m) + geom_col(aes(x = sample, y = value)) + facet_wrap(~feature, scales="free", ncol = 1)
  g <- g + ylab("") + xlab("") + theme(axis.ticks.x = element_blank(), axis.text.x = element_blank())
  
i <- 2
rctd <- rctds[[i]]
obj <- filtered.objs[[i]]
lr.df <- tnbc.fig5.lr.df

pop.weights <- format.rctd.output(rctd)
pos <- obj[[]][, c("row", "col")]
mat <- Seurat::GetAssayData(obj, assay="Spatial")

common.spots <- intersect(rownames(pos), rownames(pop.weights))
common.spots <- intersect(common.spots,colnames(mat))

mat <- mat[, common.spots]
pos <- pos[common.spots,]
pop.weights <- pop.weights[common.spots,]

expr <- cpm(as.matrix(mat), log = FALSE)
W <- 1/as.matrix(dist(pos))
diag(W) <- 0
W <- gausskernel(pos,sigma=1)

g1 <- "CXCL9"
g2 <- "CXCR3"
pop1 <- "Stromal"
pop2 <- "CD4+ T-cells"

g1 <- "BMP4"
g2 <- "BMPR1A"
pop1 <- "Stromal"
pop2 <- "Epithelial_Basal_Cycling"

min.pop <- unlist(apply(pop.weights[, c(pop1, pop2)], 1, min))
df <- data.frame(min.pop = min.pop, g1 = expr[g1,,drop=TRUE], g2 = expr[g2,,drop=TRUE])
rownames(df) <- common.spots

res1 <- BivariateMoransI(df[,c("min.pop","g1")], W)
res2 <- BivariateMoransI(df[,c("min.pop","g2")], W)
p.max <- max(res1$p.val["min.pop","g1"], res2$p.val["min.pop","g2"])

```


```{r}
for(i in 1:length(filtered.objs)) {
  sample.name <- names(filtered.objs)[i]
  rctd <- rctds[[i]]
  obj <- filtered.objs[[i]]
  lr.df <- tnbc.fig5.lr.df
  output.dir <- paste0(plots_dir, "/", "lr/", sample.name, "/")
  dir.create(output.dir, showWarnings = FALSE, recursive = TRUE)
  print(output.dir)
  # make.ligand.receptor.plots(rctd, obj, lr.df, sample.name, output.dir)
  
  pop.weights <- format.rctd.output(rctd)
  # cell.types.to.plot <- c("Epithelial", "T_Cells", "B_Cells", "Myeloid", "iCAFs", "myCAFs", "PVL", "Endothelial")
  cell.types.to.plot <- c("Epithelial", "T_Cells", "B_Cells", "Myeloid", "Stromal")
  g <- plot.population.weights(rctd, pop.weights, cell.types.to.plot, obj = obj, show.hne = TRUE, use.absolute.scale = TRUE)
  g <- add.title.to.plot(g, sample.name, size = 20)
  ncol <- ceiling(length(cell.types.to.plot)/3)
  output.dir <- paste0(plots_dir, "/", "pops/")
  dir.create(output.dir, showWarnings = FALSE, recursive = TRUE)
  png(paste0(output.dir, "/", sample.name, "-populations.png"), width = 3 * 480, height = ncol  * 480)
  print(g)
  d <- dev.off()
}
```

```{r}

```

```{r}

```


```{r}
all.pop.weights <- 
  ldply(rctds, format.rctd.output)
colnames(all.pop.weights)[1] <- "sample"
all.pop.weights <- all.pop.weights[, c("sample", "x", "y", "Immune", "Epithelial", "Stromal")]
```

```{r}
orig.plot <- FALSE
df <- reshape2::melt(all.pop.weights)
colnames(df) <- c("sample", "variable", "value")
df <- subset(df, !(variable %in% c("x","y")))
if(!orig.plot) { df$variable <- gsub(df$variable, pattern="_", replacement=" ")}
df <- merge(df, patient.df[, c("sample", "patient", "treated")], by= c("sample"))
```

```{r}

# Solve: twice as many images in rows as in columns: 2x * x = n
nrow <- floor(sqrt(length(unique(df$variable))/2))
nrow <- 5
text.sz <- 20
if(orig.plot) { text.sz <- 11 }
g <- 
  df %>% 
    group_by(patient, variable) %>%  # do the same calcs for each box
    mutate(value2 = filter_lims(value))  %>% as_data_frame() %>%
    ggplot(aes(y = value2, x = tidytext::reorder_within(patient, value2, variable, function(x) median(x, na.rm=TRUE)), fill = treated)) +
    geom_boxplot(na.rm = TRUE, outlier.shape = NA) +
    labs(fill = "Status") + ylab("Cell Type Fraction") + xlab("Patient") + theme(axis.text.x = element_blank(), text = element_text(size = text.sz))
if(orig.plot) { 
  g <- g + facet_wrap(~variable, scales = "free")
} else {
  g <- g + facet_wrap(~variable, scales = "free", nrow = nrow, labeller = labeller(variable = label_wrap_gen(width = 16)))
}
file <- paste0(plots_dir, "/pops-by-treatment.png")
if(orig.plot) { paste0(plots_dir, "/pops-by-treatment-old.png") }
nheight <- 2
if(orig.plot) { 
  png(file, width = 2 * 480, height = 2 * 480)
} else {
  png(file, width = 3 * 480, height = 2 * 480)
}
print(g)
d <- dev.off()


df.epi <- subset(df, variable == "Epithelial")
df.med <- ddply(df.epi, .variables = c("patient"), .fun = function(df) data.frame(median=median(df$value)))
df.med <- df.med[order(df.med$median),]
pt.levels <- df.med$patient
df$patient <- factor(df$patient, levels=pt.levels)
g <- 
  df %>% 
    group_by(patient, variable) %>%  # do the same calcs for each box
    mutate(value2 = filter_lims(value))  %>% as_data_frame() %>%
    ggplot(aes(y = value2, x = patient, fill = treated)) +
    geom_boxplot(na.rm = TRUE, outlier.shape = NA) +
    labs(fill = "Status") + ylab("Cell Type Fraction") + xlab("Patient") + theme(axis.text.x = element_blank(), text = element_text(size = text.sz))
g <- g + facet_wrap(~variable, scales = "free", nrow = nrow, labeller = labeller(variable = label_wrap_gen(width = 16)))
file <- paste0(plots_dir, "/pops-by-treatment-epi-ordered.png")
png(file)
print(g)
d <- dev.off()



df$sample <- gsub(df$sample, pattern="_", replacement=" ")
df <- df[!grepl(x=df$sample, pattern="reseq"),]
un <- unique(df[, c("sample", "patient", "treated")])
un <- un[order(un$treated, un$patient),]
lvls <- un$sample
df$sample <- factor(df$sample, levels=lvls)


g <- 
  df %>% 
    ggplot(aes(y = value, x = variable, fill = treated)) +
    geom_boxplot(na.rm = TRUE, outlier.shape = NA) +
    labs(fill = "Status") + ylab("Cell Type Fraction") + xlab("Sample") + 
    # theme(axis.text.x = element_blank(), text = element_text(size = text.sz)) + 
    facet_grid(~ sample, labeller = label_wrap_gen(5)) +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1), 
          text = element_text(size = 20))

file <- paste0(plots_dir, "/pops-by-sample.png")
png(file, width = 3 * 480, height = 2 * 480)
print(g)
d <- dev.off()

```

```{r}
sdf <- subset(df, variable == "Myeloid") %>% ddply(.variables = c("patient"), .fun = function(df) data.frame(value = mean(df$value)))
ranks <- sdf$value - mean(sdf$value)
names(ranks) <- sdf$patient
dummy.pathways <- list("Untreated" = unique(subset(patient.df, treated == "Untreated")$patient))
# dummy.pathways[["Treated"]] = unique(subset(patient.df, treated == "Treated")$patient)
# fgseaRes <- fgsea(pathways = dummy.pathways, stats    = ranks, minSize  = 1, maxSize  = 20)
fgseaRes <- fgseaSimple(pathways = dummy.pathways, stats = ranks, minSize = 1, maxSize= 20, nperm = 10000, nproc = 1)
```

```{r}
dummy.pathways <- list("Untreated" = unique(subset(patient.df, treated == "Untreated")$patient))
pop.pvalues <-
  ddply(df, .variables = c("variable"),
        .fun = function(dfv) {
           mdf <- ddply(dfv, .variables = c("patient"), .fun = function(tmp) data.frame(value = mean(tmp$value)))
           ranks <- mdf$value - mean(mdf$value)
           names(ranks) <- mdf$patient
           fgseaRes <- fgseaSimple(pathways = dummy.pathways, stats = ranks, minSize = 1, maxSize= 20, nperm = 10000, nproc = 1)
        })
pop.pvalues$pval.holm <- p.adjust(pop.pvalues$pval, method = "holm")
```


```{r}
g <- plot.population.fractions.across.samples(all.pop.weights, id.cols = c("sample", "x", "y"), sample.col = "sample")
png(paste0(plots_dir, "/pops/", "population-distributions.png"), width = 2 * 480, height = 1  * 480)
print(g)
d <- dev.off()
```


```{r}
expressed.genes <- 
  llply(filtered.objs,
        .fun = function(obj) {
          mat <- Seurat::GetAssayData(obj, assay="Spatial")
          rownames(mat)[rowSums(mat) > 0]
        })

num.expressed.genes <-
  llply(expressed.genes, .fun = function(lst) length(lst))

num.expressed.genes <- data.frame(sample = names(num.expressed.genes), metric = "Total.Genes.Detected", value = as.vector(unlist(num.expressed.genes)))

```



```{r}
# Read in the spaceranger summaries
summary.tbl <- 
  ldply(datasets, 
        .fun = function(dataset) {
          # json.summary.file <- paste0(spaceranger_dirs[[dataset]], "/", "summary.json")
          # json.summary <- fromJSON(file=json.summary.file)
          # json.summary
          seq.metrics.file <- paste0(spaceranger_dirs[[dataset]], "/", "metrics_summary.csv")
          tbl <- read.table(seq.metrics.file, sep=",", header=TRUE, as.is=TRUE)
          #rename.cols <- list("Reads.Mapped.Confidently.to.Probe.Set" = "Reads.Mapped.Confidently.to.Genome", "Number.of.Panel.Genes....10.UMIs" = "Total.Genes.Detected")
          rename.cols <- list("Reads.Mapped.Confidently.to.Probe.Set" = "Reads.Mapped",
                              "Reads.Mapped.Confidently.to.Genome"= "Reads.Mapped" ,"Number.of.Panel.Genes....10.UMIs" = "Total.Genes.Detected")

          for(col in names(rename.cols)) {
            flag <- colnames(tbl) == col
            colnames(tbl)[flag] <- rename.cols[[col]]
          }
          tbl
        })
colnames(summary.tbl)[1] <- "sample"

# cols <- c("Total.Genes.Detected", "Reads.Mapped.Confidently.to.Genome",  "Number.of.Reads",  "Number.of.Spots.Under.Tissue", "Fraction.of.Spots.Under.Tissue", "Median.Genes.per.Spot", "Median.UMI.Counts.per.Spot", "Fraction.Reads.in.Spots.Under.Tissue", "Sequencing.Saturation")
#cols <- c("Reads.Mapped.Confidently.to.Genome",  "Number.of.Reads",  "Number.of.Spots.Under.Tissue", "Fraction.of.Spots.Under.Tissue", "Median.Genes.per.Spot", "Median.UMI.Counts.per.Spot", "Fraction.Reads.in.Spots.Under.Tissue", "Sequencing.Saturation")
cols <- c("Number.of.Reads", "Reads.Mapped", "Number.of.Spots.Under.Tissue", "Fraction.of.Spots.Under.Tissue", "Median.Genes.per.Spot", "Median.UMI.Counts.per.Spot", "Fraction.Reads.in.Spots.Under.Tissue", "Sequencing.Saturation")
summary.tbl <- summary.tbl[, c("sample", cols)]
summary.tbl <- melt(summary.tbl, id.vars = c("sample"))
colnames(summary.tbl) <- c("sample", "metric", "value")
summary.tbl <- rbind(summary.tbl, num.expressed.genes)
summary.tbl$metric <- gsub(summary.tbl$metric, pattern="\\.", replacement=" ")
cols <- gsub(cols, pattern="\\.", replacement=" ")
summary.tbl$metric <- factor(summary.tbl$metric, levels = c("Total Genes Detected",cols))
# summary.tbl$sample <- factor(summary.tbl$sample, levels=sample.lvls)
# summary.tbl <- merge(summary.tbl, dataset.metadata.df, by.x = "sample", by.y ="sample.name")


g <- ggplot(data = subset(summary.tbl, metric == "Fraction Reads in Spots Under Tissue"), aes(x = sample, y = value, fill=type)) + geom_bar(stat="identity")
# scale_fill_manual(values= unname(unlist(color_list)))
g <- g + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
g <- g + ylab("Fraction Reads in Spots\nUnder Tissue") + xlab("")
g <- g + theme(text = element_text(size = 20))
png(paste0(plots_dir, "/", analysis_file_prefix, "frac-reads-in-spots.png"))
print(g)
d <- dev.off()

g <- ggplot(data = subset(summary.tbl, !(metric %in% c("Fraction Reads in Spots Under Tissue", "Number of Spots Under Tissue"))), aes(x = sample, y = value, fill=type)) + geom_bar(stat="identity") + facet_wrap(~ metric, scales="free", labeller = label_wrap_gen())
  # scale_fill_manual(values= unname(unlist(color_list))) + facet_wrap(~ metric, scales="free", labeller = label_wrap_gen())
g <- g + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
g <- g + ylab("")
png(paste0(plots_dir, "/", analysis_file_prefix, "summary.png"), width = 2 * 480)
print(g)
d <- dev.off()
```

```{r}
# Perform normalization of counts using SCTransform (which fits a negative binomial to the count data)
# This adds a new assay "SCT" to the returned Seurat object. That assay has slots "counts" (the corrected counts),
# "data" (log1p(counts)), and "scale.data" (the "pearson residuals").
# These would be accessible via GetAssayData(filtered.objs[[1]], slot = "data", assay = "SCT")
# Running with default parameters (the most interesting of which look to be variable.features.n and/or variable.features.rv.th)
filtered.objs <-
  llply(filtered.objs,
        .fun = function(obj) {
          use.v2 <- TRUE
          if(use.v2) { 
            obj <- SCTransform(obj, assay = "Spatial", verbose = FALSE, vst.flavor = "v2", method = "glmGamPoi")
          } else {
            obj <- SCTransform(obj, assay = "Spatial", verbose = FALSE)
          }
          return(obj)
        })
```

```{r}
filtered.objs <-
  llply(filtered.objs,
        .fun = function(obj) {
          obj <- RunPCA(obj, assay = "SCT", verbose = FALSE)
          # obj <- FindNeighbors(obj, reduction = "pca", dims = 1:30)
          # obj <- FindClusters(obj, verbose = FALSE)
          # obj <- RunUMAP(obj, reduction = "pca", dims = 1:30)
          obj
        })
```

```{r}
nms <- names(filtered.objs)
names(nms) <- nms
elbow.plots <-
  llply(nms,
        .fun = function(nm) {
          obj <- filtered.objs[[nm]]
          g <- ElbowPlot(obj, ndims = 40)
          g <- g + ggtitle(nm)
          g
        })
plot_grid(plotlist=elbow.plots)
```


```{r}
filtered.objs <-
  llply(filtered.objs,
        .fun = function(obj) {
          # obj <- RunPCA(obj, assay = "SCT", verbose = FALSE)
          obj <- FindNeighbors(obj, reduction = "pca", dims = 1:30)
          obj <- FindClusters(obj, verbose = FALSE)
          obj <- RunUMAP(obj, reduction = "pca", dims = 1:30)
          obj
        })

```

```{r}
all.markers <-
  llply(nms,
        .fun = function(nm) {
          obj <- filtered.objs[[nm]]
          cat(paste0("Finding DE for ", nm))
          # FindAllMarkers(obj, test.use="DESeq2", slot="counts")
          FindAllMarkers(obj, assay="SCT", slot="data", test.use="wilcox")
        })
```

```{r}
marker.tbl <- ldply(all.markers)
colnames(marker.tbl)[1] <- "sample"
top.markers <-
  ddply(marker.tbl, .variables = c("sample", "cluster"),
        .fun = function(df) {
          o <- order(df$p_val, decreasing = FALSE)
          df <- df[o,]
          df[1:5,]
        })
```


```{r}
suppressPackageStartupMessages(p_load(msigdbr))
suppressPackageStartupMessages(p_load(fgsea))
```

```{r}
# See https://www.biostars.org/p/339934/
# Retrieve human H (hallmark) gene set
msigdbr_df <- msigdbr(species = "Homo sapiens", category = "H")

# Retrieve human KEGG gene set
# msigdbr_df <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG")

# fixing format to work with fgsea
pathwaysH = split(x = msigdbr_df$human_gene_symbol, f = msigdbr_df$gs_name)

all.fgsea <- 
  llply(all.markers, .parallel = TRUE,
        .fun = function(marker.tbl) {
          ddply(all.markers[[1]], .variables = c("cluster"), .parallel= FALSE,
                .fun = function(df) {
                  # run fgsea enrichment
                  o <- order(df$avg_log2FC)
                  df <- df[o,]
                  ranks <- df$avg_log2FC
                  names(ranks) <- df$gene
                  fgseaRes <- suppressWarnings(fgsea(pathways=pathwaysH, ranks, maxSize = 500))
                  o <- order(fgseaRes$pval, decreasing=FALSE)
                  fgseaRes <- fgseaRes[o,]
                  fgseaRes
                })
        })
                   

```


```{r}
all.filtered.objs <- Reduce(merge, filtered.objs)
Idents(all.filtered.objs) <- all.filtered.objs$orig.ident
```

```{r}
#ATR, BRCA, MYC, NRAS, Ki-67
# See https://pubmed.ncbi.nlm.nih.gov/30146351/
bl1.markers <- list("ATR" = "ATR", "BRCA1" = "BRCA1", "BRCA2" = "BRCA2", "MYC" = "MYC", "NRAS" = "NRAS", "MKI67" = "Ki-67")
bl2.markers <- list("EGFR" = "EGFR", "MET" = "MET", "EPHA2" = "EPHA2", "TP53" = "TP53")
im.markers <- list("JAK1" = "JAK1", "JAK2" = "JAK2", "STAT1" = "STAT1", "STAT4" = "STAT4", "IRF1" = "IRF1", "IRF7" = "IRF7", "IRF8" = "IRF8", "TNF" = "TNF")
m.markers <- list(Wnt, ALK, TGF-β)
msl.markers <- list(EGFR, PDGFR, ERK1/2, VEGFR2)
lar.markers <- list(AR, FOXA1, KRT18, XBP1)
```


```{r}
# SpatialFeaturePlot(all.filtered.objs, features = c("NRAS"), combine = FALSE)
# SpatialFeaturePlot(filtered.objs[[1]], features = names(im.markers), combine = TRUE)
## Genes upregulated in TNBC
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6513966/

# TNBC subtypes
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3127435/
# TNBC tumor subtypes display differential expression of both basal-like cytokeratins (KRT5, KRT6A, KRT6B, KRT14, KRT16, KRT17, KRT23, and KRT81) and luminal cytokeratins (KRT7, KRT8, KRT18, and KRT19)
DefaultAssay(all.filtered.objs) <- "SCT"
luminal.cytos <- c("KRT7", "KRT8", "KRT18", "KRT19")
basal.cytos <- c("KRT5", "KRT6A", "KRT6B", "KRT14", "KRT16", "KRT17", "KRT23", "KRT81")

# TNBC subyptes
# https://www.sciencedirect.com/science/article/pii/S0305737218300999

tnbc.markers <- c("AZGP1", "KRT19", "RPS11", "SFRP1", "EPCAM", "TACSTD2", "MGP", "SFN", "GATA3", "S100A8", "CHI3L1", "KRT15", "KRT14", "NPY1R", "ASPN", "PEG3", "SCGB2A2")
gene <- "PTPRC"
gene <- "CD79A"
gene <- "PDGFRA"
gene <- "CD68"
gene <- tnbc.markers[indx]

# apply(GetAssayData(all.filtered.objs, slot = "counts")[tnbc.markers,],1,max)
diff.tnbc.markers <- c("KRT19", "KRT15", "MGP")

plot.gene.overlays <- function(obj, gene) {
  mx <- max(GetAssayData(obj, slot = "counts")[gene,])
  plts <- SpatialFeaturePlot(obj, features = c(gene), combine = FALSE, slot = "counts")
  plts <- 
    llply(plts,
          .fun = function(g) {
            i <- which(sapply(g$scales$scales, function(x) 'fill' %in% x$aesthetics))
            g$scales$scales[[i]] <- NULL
            g <- g + scale_fill_gradientn(name = gene, colours = Seurat:::SpatialColors(n = 100), limits=c(0,mx))
            g
          })
  # plot_grid(plotlist = plts)
  g <- plot_grid(plotlist = plts)
  g
}

# DefaultAssay(all.filtered.objs) <- "Spatial"
#plts <- SpatialFeaturePlot(all.filtered.objs, features = c(gene), combine = FALSE, slot = "counts") 
#plot_grid(plotlist = plts)
g1 <- plot.gene.overlays(all.filtered.objs, "EPCAM")
#g1 <- add.title.to.plot(g1, "Basal TNBC")
g2 <- plot.gene.overlays(all.filtered.objs, "KRT19")
#g2 <- add.title.to.plot(g2, "Luminal TNBC")
g.tot <- plot_grid(g1,g2)
png(paste0(plots_dir,"tnbc-markers.png"), width = 2*480, height = 480)
print(g.tot)
d <- dev.off()

cell.markers <- list("CD8 T cells" = c("CD3E", "CD8A"), "macrophages" = c("CD68", "CD80"), "B cells" = c("CD79A", "MS4A1"), "fibroblasts" = c("PDGFRA", "FAP"))
plot.pair <- function(obj, genes) {
  gene1 <- genes[1]
  gene2 <- genes[2]
  g1 <- plot.gene.overlays(obj, gene1)
  g2 <- plot.gene.overlays(obj, gene2)
  g.tot <- plot_grid(g1,g2)
  g.tot
}

for(cell.type in names(cell.markers)) {
#cell.type <- "CD8 T cell"
g <- plot.pair(all.filtered.objs, cell.markers[[cell.type]])
g <- add.title.to.plot(g, cell.type)
png(paste0(plots_dir,"tnbc-", make.names(cell.type), "-markers.png"), width = 2*480, height = 480)
print(g)
d <- dev.off()
}

```


```{r}
stop("stop")
```


```{r}
# Also apply scran deconvolution-based normalization.
# scran uses SingleCellExperiment objects, so we will have to convert back and forth between SCEs and Seurat objects.
# See notes on interoperability here: https://satijalab.org/seurat/archive/v3.1/conversion_vignette.html

filtered.objs <-
  llply(filtered.objs, .parallel = FALSE,
        .fun = function(obj) {
          
          # Convert from a Seurat object to a SingleCellExperiment
          sce <- as.SingleCellExperiment(obj, assay = "Spatial")

          
          # Perform the scran normalization (see https://bioconductor.org/packages/devel/bioc/vignettes/scran/inst/doc/scran.html)
          clusters <- quickCluster(sce)
          sce <- computeSumFactors(sce, clusters=clusters)
          sce <- logNormCounts(sce)
          
          # Convert back from SingleCellExperiment to Seurat object. 
          tmp <- as.Seurat(sce, counts = "counts", data = "logcounts", assay="scran")
          obj[["scran"]] <- tmp[["scran"]]
          obj <- FindVariableFeatures(obj, assay="scran")
          obj
        })
          
```


```{r}
# Merge the unfiltered objs into one Seurat object
all.unfiltered.objs <- Reduce(merge, unfiltered.objs)
Idents(all.unfiltered.objs) <- all.unfiltered.objs$orig.ident
```


```{r}
all.filtered.objs <- Reduce(merge, filtered.objs)
Idents(all.filtered.objs) <- all.filtered.objs$orig.ident
```


```{r}
obj.sct <- all.filtered.objs
DefaultAssay(obj.sct) <- "SCT"
VariableFeatures(obj.sct, assay="SCT") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="SCT")))))
obj.sct <- RunPCA(obj.sct, verbose = FALSE)
ElbowPlot(obj.sct, ndims = 40)
mat <- Seurat::GetAssayData(obj.sct, assay = "SCT")
pca <- obj.sct[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(as.matrix(mat)))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance
cumVarExplained <- cumsum(varExplained)

obj.sct <- RunHarmony(obj.sct, group.by.vars = make.names("orig ident"))

# Pick the number of dimensions based on a flattening of the elbow plot
obj.sct <- FindNeighbors(obj.sct,reduction = "harmony", dims = 1:20)
obj.sct <- FindClusters(obj.sct, reduction = "harmony",verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = "harmony",dims = 1:20)
png(paste0(plots_dir,"clusters-merged-UMAP-sct.png"),width=1400,height =600)
obj.sct$Sample=obj.sct$orig.ident
obj.sct$Cluster=obj.sct@active.ident
gg <- DimPlot(obj.sct, reduction = "umap", group.by = c("Cluster","Sample")) 
print(gg)
d <- dev.off()

per_id_per_cluster_tbl<-table(obj.sct@meta.data$seurat_clusters, obj.sct@meta.data$orig.ident)

foo <- (melt(per_id_per_cluster_tbl))
colnames(foo) <- c("cluster", "sample", "cnt")

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

for(target_sample in biological.replicates) {
  bar <- subset(foo, grepl(sample, pattern=target_sample))
  bar <- subset(bar, cnt != 0)
  bar <- melt(acast(bar, cluster ~ sample, fill = 0))
  colnames(bar) <- c("cluster", "sample", "cnt")
  bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
  bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
  png(paste0(plots_dir,target_sample,"-cluster-proportions-sct.png"))
  g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
  g <- g + ylab("Fraction") + xlab("Cluster")
  g <- g + theme(text = element_text(size = 20))
  print(g)
  d <- dev.off()
}

bar <- subset(foo, cnt != 0)
bar <- melt(acast(bar, cluster ~ sample, fill = 0))
colnames(bar) <- c("cluster", "sample", "cnt")
bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
png(paste0(plots_dir,"all-cluster-proportions-sct.png"))
g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
g <- g + ylab("Fraction") + xlab("Cluster")
g <- g + theme(text = element_text(size = 20))
print(g)
d <- dev.off()

png(paste0(plots_dir,"all-cluster-proportions-heatmap-sct.png"),width=980, height=980)

color_list<-list('FFPE'="#d8b365" , 'Frozen'='#5ab4ac')
colSide <- as.vector(unlist(color_list[unlist(dataset.labels[levels(bar$sample)])]))

heatmap.2(acast(bar[, c("cluster","sample","frac")], cluster ~ sample),row_title="Cluster",column_title="Sample",heatmap_legend_param=list(title="Proportion"), ColSideColors = colSide ,col =rev( colorRampPalette(brewer.pal(8, "RdBu"))(25)),xlab="Cluster", ylab="Sample",margins=c(12,8),trace="none",lhei=c(1, 6),keysize=1,key.title="Proportion")
d <- dev.off()
```

```{r}

```


```{r}

ffpe.genes <- unique(Reduce(c,expressed.genes[ffpe.datasets]))
frozen.genes <- unique(Reduce(c,expressed.genes[frozen.datasets]))

x <- list(FFPE = ffpe.genes, frozen = frozen.genes)
g <- ggVennDiagram(x, label_size = 10, set_size = 10)
g <- g + theme(legend.position = "none") 
png(paste0(plots_dir,"ffpe-frozen-venn.png"))
print(g)
d <- dev.off()

# Get the genes that are only highly expressed in fresh frozen samples
# and output their "biotype" -- i.e., whether are coding genes, etc.
frozen.only <- frozen.genes[!(frozen.genes %in% ffpe.genes)]

library(biomaRt)
if (species_sample[1]=='Human'){
    gene_db = useMart("ensembl",dataset="hsapiens_gene_ensembl")
} else {
  gene_db = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
}

gb <- getBM(attributes=c("external_gene_name", "gene_biotype"),filters = c("external_gene_name"), values=frozen.only, mart=gene_db)

frozen.only.biotypes <- as.data.frame(table(gb$gene_biotype))
colnames(frozen.only.biotypes) <- c("biotype", "Freq")
o <- order(frozen.only.biotypes$Freq, decreasing=TRUE)
frozen.only.biotypes <- frozen.only.biotypes[o,]

png(paste0(plots_dir,"frozen-biotypes.png"))
grid.table(frozen.only.biotypes,rows=NULL)
d <- dev.off()

ffpe.only <- ffpe.genes[!(ffpe.genes %in% frozen.genes)]

gb <- getBM(attributes=c("external_gene_name", "gene_biotype"),filters = c("external_gene_name"), values=ffpe.only, mart=gene_db)

ffpe.only.biotypes <- as.data.frame(table(gb$gene_biotype))
colnames(ffpe.only.biotypes) <- c("biotype", "Freq")
o <- order(ffpe.only.biotypes$Freq, decreasing=TRUE)
ffpe.only.biotypes <- ffpe.only.biotypes[o,]

png(paste0(plots_dir,"ffpe-biotypes.png"))
grid.table(ffpe.only.biotypes,rows=NULL)
d <- dev.off()
```


```{r}
obj.scran <- all.filtered.objs
DefaultAssay(obj.scran) <- "scran"
obj.scran <- ScaleData(obj.scran, assay="scran")
VariableFeatures(obj.scran, assay="scran") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="scran")))))
obj.scran <- RunPCA(obj.scran, verbose = FALSE)
ElbowPlot(obj.scran, ndims = 40)
mat <- Seurat::GetAssayData(obj.scran, assay = "scran")
pca <- obj.scran[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(as.matrix(mat)))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance
cumVarExplained <- cumsum(varExplained)

obj.scran <- RunHarmony(obj.scran, group.by.vars = make.names("orig ident"))

obj.scran <- FindNeighbors(obj.scran,reduction = "harmony", dims = 1:20)
obj.scran <- FindClusters(obj.scran, reduction = "harmony", verbose = FALSE)
obj.scran <- RunUMAP(obj.scran, reduction = "harmony", dims = 1:20)
png(paste0(plots_dir,"clusters-merged-UMAP-scran.png"),width=1400,height =600)
obj.scran$Sample=obj.scran$orig.ident
obj.scran$Cluster=obj.scran@active.ident
gg <- DimPlot(obj.scran, reduction = "umap", group.by = c("Cluster","Sample")) 
print(gg)
d <- dev.off()

per_id_per_cluster_tbl<-table(obj.scran@meta.data$seurat_clusters, obj.scran@meta.data$orig.ident)

foo <- (melt(per_id_per_cluster_tbl))
colnames(foo) <- c("cluster", "sample", "cnt")

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

for(target_sample in biological.replicates) {
  bar <- subset(foo, grepl(sample, pattern=target_sample))
  bar <- subset(bar, cnt != 0)
  bar <- melt(acast(bar, cluster ~ sample, fill = 0))
  colnames(bar) <- c("cluster", "sample", "cnt")
  bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
  bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
  png(paste0(plots_dir,target_sample,"-cluster-proportions-scran.png"))
  g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
  g <- g + ylab("Fraction") + xlab("Cluster")
  g <- g + theme(text = element_text(size = 20))
  print(g)
  d <- dev.off()
}

bar <- subset(foo, cnt != 0)
bar <- melt(acast(bar, cluster ~ sample, fill = 0))
colnames(bar) <- c("cluster", "sample", "cnt")
bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
png(paste0(plots_dir,"all-cluster-proportions-scran.png"))
g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
g <- g + ylab("Fraction") + xlab("Cluster")
g <- g + theme(text = element_text(size = 20))
print(g)
d <- dev.off()

color_list<-list('FFPE'="#d8b365" , 'Frozen'='#5ab4ac')
colSide <- as.vector(unlist(color_list[unlist(dataset.labels[levels(bar$sample)])]))
par(cex.main=80)
png(paste0(plots_dir,"all-cluster-proportions-heatmap-scran.png"),width=680, height=980)
heatmap.2(acast(bar[, c("cluster","sample","frac")], cluster ~ sample),row_title="Cluster",column_title="Sample",heatmap_legend_param=list(title="Proportion"), ColSideColors = colSide ,col =rev( colorRampPalette(brewer.pal(8, "RdBu"))(25)),ylab="Cluster", xlab="Sample",margins=c(13,6),trace="none",lhei=c(1,8),keysize=2,key.title="Proportion",cexRow = 2.5,cexCol = 2.5) 
#title('ddddddd', cex.main = 15 * op[["cex.main"]])
 ## this will affect also legend title font size

#g<- g + title(main, cex.main = 1.5 * op[["cex.main"]])
d <- dev.off()

```



```{r}
# Add simplified sample names
sample.name.df <- data.frame(all.unfiltered.objs@meta.data[, c("orig.ident"), drop = FALSE])
sample.name.df$sample.name <- unlist(lapply(sample.name.df$orig.ident, function(str) unlist(strsplit(str, split="_"))[1]))
all.unfiltered.objs <- AddMetaData(all.unfiltered.objs, sample.name.df[, c("sample.name"), drop = FALSE])
```


```{r}

```


```{r}
# Plot the number of UMI counts per spot for unfiltered data (in files *unfiltered-spot-counts.png.png)
unfiltered.count.plots <-
  llply(datasets,
        .fun = function(dataset) {
          g <- plot.spatial(unfiltered.objs[[dataset]], features = c("nCount_Spatial"), legend.name = "UMI Count (k)")
          g <- g + theme(legend.text=element_text(size=15))
          g
        })
```

```{r}
# Plot the number of feature counts per spot for unfiltered data (in files *unfiltered-spot-features.png)
unfiltered.feature.plots <-
  llply(datasets,
        .fun = function(dataset) {
          g <- plot.spatial(unfiltered.objs[[dataset]], features = c("nFeature_Spatial"), legend.name = "Gene Count (k)")
          g <- g + theme(legend.text=element_text(size=15))
          g
        })
```

```{r}
# Plot the raw H&E images (in files *hne.png)
hne.plots <-
  llply(datasets,
        .fun = function(dataset) {
          g <- plot.hne(unfiltered.objs[[dataset]], keep.invisible.legend = TRUE)
          g
        })
```

```{r}
# Make plots of H&E and UMI and feature count overlays
for(pt in names(samples.by.patient)) {
  plts <- llply(samples.by.patient[[pt]],
                .fun = function(sample) {
                  g <- plot_grid(hne.plots[[sample]], unfiltered.count.plots[[sample]], unfiltered.feature.plots[[sample]], byrow=FALSE, ncol=3)
                  g <- add.title.to.plot(g, sample, size = 20)
                  g
                })
  g <- plot_grid(plotlist = plts, ncol=1)
  png(paste0(plots_dir, "/", analysis_file_prefix, pt, "-hne-umis-and-features.png"), width = 3 * 480, height = 2 * 480)
  print(g)
  d <- dev.off()
}
```


```{r}
#' Plot distribution of a response variable (e.g., UMI count) across spots relative to a dependent variable (e.g., tissue vs background spot status)
#' 
#' Create violin/boxplots showing distribution across spots of a user-specified response variable relative to a dependent variable and facted by sample.
#'
#' @param df A data.frame holding the response, depenndent, and faceting variables.
#' @param response.var The variable whose distribution over spots will be plotted.
#' @param facet.var The faceting variable.
#' @param dependent.var The variable that the response variable will be plotted as a function of.
#' @return A ggplot
plot.distributions.vs.cell.type <- function(df, response.var = "nCount_Spatial", facet.var = "sample.name", dependent.var = "spot_type", use.log = TRUE, use.violin = TRUE, label.var="label") {
  lvls <- unique(df[, facet.var, drop=TRUE])
  df[,facet.var] <- factor(df[,facet.var], levels=lvls)
  stat.test <- df %>% group_by_at(facet.var) %>% wilcox_test(as.formula(paste0(response.var, " ~ ", dependent.var)), p.adjust.method = "none")
  stat.test$p.adj <- p.adjust(stat.test$p, method = "bonferroni")
  stat.test <- stat.test %>% add_xy_position(x = dependent.var)
  if(use.log) {
    stat.test$y.position <- log2(stat.test$y.position)
  }
  stat.test$label <- stars.pval(stat.test$p.adj)
  if(use.violin) {
    g <- ggviolin(df, dependent.var, response.var, facet.by = facet.var, add = "boxplot")
  } else {
    g <- ggboxplot(df, dependent.var, response.var, facet.by = facet.var)
  }
  if(use.log) g <- g + yscale("log2")
  g <- g + stat_pvalue_manual(stat.test, label=label.var) + xlab("Spot Type")
  g
}

```


```{r}
# Plot the distribution of UMI counts and gene counts over spots, as a function of whether those spots and within the tissue or outside of it (in file *count-and-feature-dist.png)
tbl <- all.unfiltered.objs@meta.data
tbl <- merge(tbl, dataset.metadata.df)
# tbl <- tbl[order(tbl$sample.name, tbl$type, tbl$sample.name, decreasing=TRUE),]
tbl$sample <- factor(tbl$sample, levels = sample.lvls)
tbl$sample.label <- paste0(tbl$sample.name, "\n", tbl$type)
g.cnt <- plot.distributions.vs.cell.type(tbl, response.var = "nCount_Spatial", facet.var = "sample.label") + ylab("UMI Counts (log2)")
g.feature <- plot.distributions.vs.cell.type(tbl, response.var = "nFeature_Spatial", facet.var = "sample.label") + ylab("Feature Counts (log2)")
g <- plot_grid(g.cnt, g.feature, nrow=1, labels = "AUTO")
png(paste0(plots_dir, "/", analysis_file_prefix, "count-and-feature-dist.png"), width = 2 * 480)
print(g)
d <- dev.off()

```
```{r}
#' Return count matrix from a Seurat object
#' 
#' @param obj A Seurat object.
#' @return A (sparse) matrix holding the spot counts (i.e., from the "counts" slot)
get.count.matrix <- function(obj) {
  as.matrix(x = GetAssayData(object = obj, assay = "Spatial", slot = "counts"))
}

#' Downsample each column of a matrix to a desired total count.
#'
#' A function that, independently for each column/cell, uses a multinomial distribution, parameterized 
#' by the frequency of each gene within that column/cell and the desired total count, to sample a vector of gene counts.
#' This is in contrast to related functions such as SampleUMI (in Seurat), which applies a binomial to each gene (!?)
#' and thus only approximates the desired total count, and downsampleMatrix (in DropletUtils), which downsamples to
#' a fraction of the original number of reads.
#'
#' @param expr_mat A (possibly sparse) matrix of counts.
#' @param tot_cnt The desired number of counts _for each column_
#' @return A downsample matrix
downsample.matrix <- function (expr_mat, tot_cnt) 
{
    down_sample <- function(x) {
        prob <- x/sum(x)
        return(rmultinom(1, tot_cnt, prob))
    }
    down_sampled_mat <- apply(expr_mat, 2, down_sample)
    return(down_sampled_mat)
}

#' Compute the number of expressed genes/features in a downsampled matrix.
#' 
#' A function to downsample the input matrix such that each cell/column has tot_cnt reads and
#' that reports the _median_ (across cells/columns) number of genes/features with non-zero counts.
#'
#' @param expr_mat A (possibly sparse) matrix of counts.
#' @param tot_cnt The desired number of counts _for each column_
#' @return The median (across cells/columns) number of genes/features with non-zero counts in the downsampled matrix.
compute.num.features.at.total.reads <- function(expr_mat, tot_cnt) {
  ds <- downsample.matrix(expr_mat, tot_cnt)
  return(median(colSums(ds > 0)))
}
```

```{r}
# Calculate the median number of reads (across spots) for each sample
# NB: using filtered data here
median.num.reads <- llply(filtered.objs, .fun = function(obj) median(colSums(get.count.matrix(obj))))
```

```{r}
# Perform a sensitivity analysis -- i.e., show the number of detected genes/features as a function
# of total UMI counts per spot. More precisely, we will plot the median (across spots) number of
# detected genes vs the median (across spots) UMI count.

all.downsample.cnts <- round(seq(from=0.1,to=0.9,by=0.1)*max(unlist(median.num.reads)))
names(all.downsample.cnts) <- all.downsample.cnts
downsample.feature.df <-
  ldply(filtered.objs,
        .parallel = FALSE,
        .fun = function(obj) {
          expr_mat <- get.count.matrix(obj)
          median.cnts <- median(colSums(expr_mat))
          downsample.cnts <- all.downsample.cnts[all.downsample.cnts < median.cnts]
          tbl <- 
            ldply(downsample.cnts, .parallel = TRUE,
                  .fun = function(tot_cnt) {
                    data.frame(num.features = compute.num.features.at.total.reads(expr_mat, tot_cnt))
                  })
          colnames(tbl)[1] <- "downsample.count"
          tbl
        })
colnames(downsample.feature.df)[1] <- "sample.name" 
downsample.feature.df$downsample.count <- as.numeric(downsample.feature.df$downsample.count)
downsample.feature.df <- merge(downsample.feature.df, dataset.metadata.df)
```

```{r}
# Plot the sensitivity (# of detected genes/features vs # of reads; in file *num-features-vs-num-downsampled-reads.png)
g <- ggplot(downsample.feature.df, aes(x = downsample.count, y = num.features, colour = sample.name, shape = type))
g <- g + geom_point()
g <- g + xlab("Spot Read Count (Median)") + ylab("Spot Feature Count (Median)")
g <- g + theme(text = element_text(size = 20))
png(paste0(plots_dir, "/", analysis_file_prefix, "num-features-vs-num-downsampled-reads.png"))
print(g)
d <- dev.off()
            
```


```{r}
#' Return most highly-expressed genes
#' 
#' A function to return the most highly-expressed genes (i.e., those with highest value) from a matrix.
#'
#' @param mat A (sparse) matrix.
#' @param n.top The number of genes to return.
#' @param assay The assay from which to access the gene exprssion/values in the Seurat object.
#' @param slot The slot in the assay form which to access the gene expression/values.
#' @return A vector of the highest-expressed genes.
get.top.genes.matrix <- function(mat, n.top = 20, assay = "Spatial", slot = "data") {
  rs <- rowSums(mat)
  rs <- rs[order(rs, decreasing=TRUE)]
  top.genes <- names(rs)[1:n.top]
  top.genes
}

#' Return most highly-expressed genes
#' 
#' A function to return the most highly-expressed genes (i.e., those with highest value) from a Seurat assay.
#'
#' @param obj A Seurat object.
#' @param n.top The number of genes to return.
#' @param assay The assay from which to access the gene exprssion/values in the Seurat object.
#' @param slot The slot in the assay form which to access the gene expression/values.
#' @return A vector of the highest-expressed genes.
get.top.genes <- function(obj, n.top = 20, assay = "Spatial", slot = "data") {
  mat <- GetAssayData(obj, assay = assay, slot = slot)
  get.top.genes.matrix(mat, n.top = n.top, assay = assay, slot = slot)
}

#' Return data subsetted by spot tissue status
#' 
#' A function to return the subset of the data corresponding to spots that are (or are not) in the tissue
#'
#' @param obj A Seurat object.
#' @param tissue.val Spots with tissue.val for the tissue.col metadata field will be retained.
#' @param tissue.col The metadata column of the Seurat object holding the tissue status
#' @param assay The assay from which to access the gene exprssion/values in the Seurat object.
#' @param slot The slot in the assay form which to access the gene expression/values.
#' @return A (sparse) matrix of spots that are (or are not) in tissue
subset.matrix.based.on.tissue.status <- function(obj, tissue.val, tissue.col = "tissue", assay = "Spatial", slot = "data") {
  cell.subset <- rownames((obj@meta.data)[(obj@meta.data)[,tissue.col] == tissue.val,])
  mat <- GetAssayData(obj, assay = assay, slot = slot)
  mat[,cell.subset]
}
```

```{r}

```


```{r}
# Get the most prevalent genes expressed in the background ...
top.genes.background <-
  llply(datasets,
        .fun = function(data.set) {
          obj <- unfiltered.objs[[data.set]]
          mat <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 0, assay = "Spatial", slot = "counts"))
          mat <- sweep(mat, 2, colSums(mat), "/")
          top.genes <- get.top.genes.matrix(mat, n.top = 20)
          top.genes
        })

# ... and in the tissue
top.genes.tissue <-
  llply(datasets,
        .fun = function(data.set) {
          obj <- unfiltered.objs[[data.set]]
          mat <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          mat <- sweep(mat, 2, colSums(mat), "/")
          top.genes <- get.top.genes.matrix(mat, n.top = 20)
          top.genes
        })

```

```{r}
# Find genes that are common between the (union of) background genes and the (union of) tissue genes
all.background.genes <- unique(Reduce("c", top.genes.background))
all.tissue.genes <- unique(Reduce("c", top.genes.tissue))
common.genes <- intersect(all.background.genes, all.tissue.genes)

intersect.background.genes <- unique(Reduce("intersect", top.genes.background))
intersect.tissue.genes <- unique(Reduce("intersect", top.genes.tissue))


flag <- dataset.labels == "FFPE"
ffpe.background.genes <- unique(Reduce("c", top.genes.background[flag]))
ffpe.tissue.genes <- unique(Reduce("c", top.genes.tissue[flag]))
common.ffpe.genes <- intersect(ffpe.background.genes, ffpe.tissue.genes)
intersect.tissue.ffpe.genes <- unique(Reduce("intersect", top.genes.tissue[flag]))

```


```{r}
```


```{r}
# Create plots showing the top 20 most prevalent genes in the background -- highlighting (in bold) the
# genes that are common to the background and tissue
top.genes.background.plts <-
  llply(datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          background.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 0, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(background.sub.matrix, n.top = 20, highlight.genes = intersect.background.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.background.plts)
g.all <- add.title.to.plot(g.all, "Background Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-background-spot.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

# Do the same for spots in the tissue
top.genes.tissue.plts <-
  llply(datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          tissue.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(tissue.sub.matrix, n.top = 20, highlight.genes = intersect.tissue.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.tissue.plts)
g.all <- add.title.to.plot(g.all, "Tissue Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-tissue-spot.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

# Repeat both of the above, but only for FFPE
# Create plots showing the top 20 most prevalent genes in the background -- highlighting (in bold) the
# genes that are common to the background and tissue
top.genes.background.ffpe.plts <-
  llply(ffpe.datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          background.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 0, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(background.sub.matrix, n.top = 20, highlight.genes = common.ffpe.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.background.ffpe.plts)
g.all <- add.title.to.plot(g.all, "Background Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-background-spot-ffpe-only.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

# Do the same for spots in the tissue
top.genes.tissue.ffpe.plts <-
  llply(ffpe.datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          tissue.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(tissue.sub.matrix, n.top = 20, highlight.genes = common.ffpe.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.tissue.ffpe.plts)
g.all <- add.title.to.plot(g.all, "Tissue Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-tissue-spot-ffpe-only.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

top.genes.intersect.tissue.ffpe.plts <-
  llply(ffpe.datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          tissue.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(tissue.sub.matrix, n.top = 20, highlight.genes = intersect.tissue.ffpe.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.intersect.tissue.ffpe.plts)
g.all <- add.title.to.plot(g.all, "Tissue Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-tissue-spot-intersect-ffpe-only.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()



```


```{r}
mylist_qval<-list()
mylist_top50_LLR<-list()
mylist_top100_LLR<-list()
for (i in names(long.dataset.names)){
  r<-read.csv(file = paste0(base_dir, "/automatic_analysis/results/",i,"/stSpatialDE.csv"), header = TRUE, as.is = TRUE, row.names = 1)
  r  <-r[r$qval==0,]
  mm <-sort(r$LLR,decreasing= TRUE,index.return = TRUE)
  
  mylist_qval[[ i ]]<-r$g.1
  mylist_top50_LLR[[ i ]]<-r$g.1[mm$ix[1:50]]
  mylist_top100_LLR[[ i ]]<-r$g.1[mm$ix[1:100]]
}
dictionary_terms<-c(unlist(unique(dataset.labels)),unlist(biological.replicates),"")
for (temp in dictionary_terms){
temp_list1 <- list()
temp_list2 <- list()
temp_list3 <- list()

#temp<-dictionary_terms[1]
if ((temp==dictionary_terms[1]|temp==dictionary_terms[2])&(length(mylist_qval[dataset.labels==temp])<=4 & length(mylist_qval[dataset.labels==temp])>=2)){
  temp_list1<-mylist_qval[dataset.labels==temp]
  temp_list2<-mylist_top50_LLR[dataset.labels==temp]
  temp_list3<-mylist_top100_LLR[dataset.labels==temp]
}else if((temp==dictionary_terms[3] | temp==dictionary_terms[4]) & (length(mylist_qval[dataset.labels==temp]) <=4 & length(mylist_qval[dataset.labels==temp])>=2)) {
  temp_list1<-mylist_qval[grepl(datasets, pattern=temp)]
  temp_list2<-mylist_top50_LLR[grepl(datasets, pattern=temp)]
  temp_list3<-mylist_top100_LLR[grepl(datasets, pattern=temp)]
}else if (temp=="" & ( length(mylist_qval)<=4 & length(mylist_qval)>2)){
  temp_list1<-mylist_qval
  temp_list2<-mylist_top50_LLR
  temp_list3<-mylist_top100_LLR
}
if (length(temp_list1)!=0){
  print(temp)
g <- ggVennDiagram(temp_list1)
g <- g + ggtitle(paste0("Spatially Differentially Expressed genes\n with 0 p-value in ",curr_datatypes, " ",temp)) 
g <- g + theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
g <- g + scale_x_continuous(expand = expansion(mult = .2))
png(paste0(plots_dir, "/", analysis_file_prefix, "venn_SpatialDE_pval_", temp,".png"),width = 480, height = 480)
print(g)
d <- dev.off()

g <- ggVennDiagram(temp_list2)
g <- g + ggtitle(paste0("Top 50 Spatially Differentially Expressed \ngenes  in ",curr_datatypes, " ",temp)) 
g <- g + theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
g <- g + scale_x_continuous(expand = expansion(mult = .2))
png(paste0(plots_dir, "/", analysis_file_prefix, "venn_SpatialDE_top50_", temp,".png"),width = 480, height = 480)
print(g)
d <- dev.off()

g <- ggVennDiagram(temp_list3)
g <- g + ggtitle(paste0("Top 100 Spatially Differentially Expressed \ngenes  in ",curr_datatypes, " ",temp)) 
g <- g + theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
g <- g + scale_x_continuous(expand = expansion(mult = .2))
png(paste0(plots_dir, "/", analysis_file_prefix, "venn_SpatialDE_top100_", temp,".png"),width = 480, height = 480)
print(g)
d <- dev.off()
}
}
#}
```





