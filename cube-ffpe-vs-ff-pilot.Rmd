---
title: "Cube FFPE vs FF pilot"
output: html_notebook
---

```{r}
# pacman is a "package manager" that defines the p_load function.
# p_load automatically installs a library if it is not already installed.
# This often, but doesn't always, works.
suppressPackageStartupMessages(library(pacman)) 
suppressPackageStartupMessages(library(Seurat))
suppressPackageStartupMessages(p_load(hdf5r))
suppressPackageStartupMessages(p_load(ggplot2))
suppressPackageStartupMessages(p_load(patchwork))
suppressPackageStartupMessages(p_load(dplyr))
suppressPackageStartupMessages(p_load(plyr))
suppressPackageStartupMessages(p_load(cowplot))
# suppressPackageStartupMessages(p_load(scales))
suppressPackageStartupMessages(p_load(reshape2))
suppressPackageStartupMessages(p_load(ggbeeswarm))
# suppressPackageStartupMessages(library(devtools))
# install_github("jokergoo/ComplexHeatmap")
suppressPackageStartupMessages(p_load(ComplexHeatmap))
# devtools::install_github("sjmgarnier/viridisLite")
suppressPackageStartupMessages(library(viridisLite))
suppressPackageStartupMessages(library(dendextend))
# suppressPackageStartupMessages(p_load(CCA))
# suppressPackageStartupMessages(p_load("sRDA"))
suppressPackageStartupMessages(p_load(PMA))
suppressPackageStartupMessages(p_load(ggpubr))
suppressPackageStartupMessages(p_load(rstatix))
suppressPackageStartupMessages(p_load(gtools))
suppressPackageStartupMessages(p_load(DropletUtils)) # for downsampling count matrices
suppressPackageStartupMessages(p_load(foreach))
suppressPackageStartupMessages(p_load(parallel))
suppressPackageStartupMessages(p_load(scran)) # for deconvolution-based normalization
suppressPackageStartupMessages(p_load(scuttle)) # for deconvolution-based normalization
suppressPackageStartupMessages(p_load(rjson))
##if (!require(devtools)) install.packages("devtools")
##devtools::install_github("gaospecial/ggVennDiagram")
suppressPackageStartupMessages(p_load(ggVennDiagram))
suppressPackageStartupMessages(p_load(gridExtra))
library("gplots")
library(RColorBrewer)
library(harmony)


```


Setup a parallel execution environment.

```{r}
num.cores <- detectCores()
if(!is.na(num.cores) && (num.cores > 1)) {
  suppressPackageStartupMessages(p_load("doMC"))
  cat(paste("Registering ", num.cores-1, " cores.\n", sep=""))
  registerDoMC(cores=(num.cores-1))
}

```

Configure variables that point to location of images and directories where analyses and plots will be stored.

```{r}
#dataset.labels <- list('SC2200108_DT-21-4142-BR6526' = 'FFPE', 'SC2200109_DT-21-4142-BR6526' = 'FFPE', 'SC2200110_DT-21-4141-BR7212' = 'FFPE', 'SC2200111_DT-21-4141-BR7212' = 'FFPE', 'SC2200104_BR6526' = 'Frozen')
# long.dataset.names <- c('SC2200108_DT-21-4142-BR6526', 'SC2200109_DT-21-4142-BR6526', 'SC2200110_DT-21-4141-BR7212', 'SC2200111_DT-21-4141-BR7212', 'SC2200104_BR6526')
# long.dataset.names <- c('SC2200104_BR6526')
# long.dataset.names <- names(dataset.labels)

data_types <- c('pdac','endometrium','gbm','breastcancer','lungcancer','peritoneum')
#for (curr_datatypes in data_types){
#}
curr_datatypes=data_types[6]
if (curr_datatypes==data_types[1]){
# base_dir <- '/projects/compsci/whitebr/cancer-cube/qc-pilot/cpdac/'  
# long.dataset.names <- list('BR6526-108' = 'SC2200108_DT-21-4142-BR6526', 'BR6526-109' = 'SC2200109_DT-21-4142-BR6526', 'BR7212-110' = 'SC2200110_DT-21-4141-BR7212', 'BR7212-111' = 'SC2200111_DT-21-4141-BR7212', 'BR6526-104' = 'SC2200104_BR6526')

base_dir<-'/projects/compsci/USERS/somara/pdac/'
biological.replicates <- c("BR6526", "BR7212")
long.dataset.names <- list('BR6526-108' = 'SC2200108BR6526', 'BR6526-109' = 'SC2200109BR6526', 'BR7212-110' = 'SC2200110BR7212', 'BR7212-111' = 'SC2200111BR7212', 'BR6526-104' = 'SC2200104_BR6526')
dataset.labels <- list('BR6526-108' = 'FFPE', 'BR6526-109' = 'FFPE', 'BR7212-110' = 'FFPE', 'BR7212-111' = 'FFPE', 'BR6526-104' = 'Frozen')
species_sample <- replicate(length(dataset.labels), "Mouse")
} else if (curr_datatypes==data_types[2]){
base_dir <- '/projects/compsci/USERS/somara/endometrium/'
biological.replicates <- c("EuE-31")
long.dataset.names <- list('EuE-31-236' = 'SC2200236_EuE-31', 'EuE-31-235' = 'SC2200235_EuE-31', 'EuE-31-165' = 'SC2200165_EuE-31', 'EuE-31-164' = 'SC2200164_EuE-31')
dataset.labels <- list('EuE-31-164' = 'Frozen', 'EuE-31-165' = 'Frozen', 'EuE-31-235' = 'FFPE', 'EuE-31-236' = 'FFPE')
species_sample <- replicate(length(dataset.labels), "Human")
} else if (curr_datatypes==data_types[3]) {
base_dir <- '/projects/compsci/USERS/somara/gbm/'
biological.replicates <- c("UC-01","UC-02")
long.dataset.names <- list('UC-02-242' = 'SC2200242_UC-02', 'UC-02-241' = 'SC2200241_UC-02', 'UC-01-240' = 'SC2200240_UC-01', 'UC-02-171' = 'SC2200171_UC-02', 'UC-02-170' = 'SC2200170_UC-02', 'UC-01-169' = 'SC2200169_UC-01', 'UC-01-168' = 'SC2200168_UC-01')
dataset.labels <- list('UC-02-242' = 'FFPE', 'UC-02-241' = 'FFPE', 'UC-01-240' = 'FFPE', 'UC-02-171' = 'Frozen', 'UC-02-170' = 'Frozen','UC-01-169' = 'Frozen', 'UC-01-168' = 'Frozen')
species_sample <- replicate(length(dataset.labels), "Human")
} else if (curr_datatypes==data_types[4]) {
base_dir <- '/projects/compsci/USERS/somara/breast_cancer/'
biological.replicates <- c("T1O")
long.dataset.names <- list('T1O-244' = 'SC2200244_T1O', 'T1O-243' = 'SC2200243_T1O', 'T1O-199' = 'SC2200199_T1O', 'T1O-198' = 'SC2200198_T1O')
dataset.labels <- list('T1O-244' = 'FFPE', 'T1O-243' = 'FFPE', 'T1O-199' = 'Frozen', 'T1O-198' = 'Frozen')
species_sample <- replicate(length(dataset.labels), "Mouse")  
} else if (curr_datatypes==data_types[5]) {
base_dir <- '/projects/compsci/USERS/somara/lung_cancer/'
biological.replicates <- c("LM2O")
long.dataset.names <- list('LM2O-246' = 'SC2200246_LM2O', 'LM2O-245' = 'SC2200245_LM2O', 'LM2O-201' = 'SC2200201_LM2O', 'LM2O-200' = 'SC2200200_LM2O')
dataset.labels <- list('LM2O-246' ='FFPE', 'LM2O-245' ='FFPE', 'LM2O-201' = 'Frozen', 'LM2O-200' = 'Frozen')
species_sample <- replicate(length(dataset.labels), "Mouse")  
} else if (curr_datatypes==data_types[6]){
base_dir <- '/projects/compsci/USERS/somara/peritoneum/'
biological.replicates <- c('EcP-33')
long.dataset.names <- list('EcP-33-238' = 'SC2200238_EcP-33', 'EcP-33-167' = 'SC2200167_EcP-33', 'EcP-33-166' = 'SC2200166_EcP-33')
dataset.labels <- list('EcP-33-167' = 'Frozen', 'EcP-33-166' = 'Frozen', 'EcP-33-238' = 'FFPE')
species_sample <- replicate(length(dataset.labels), "Human")
}

# Write csv file for automatic ST pipeline 
temp_var<- paste0(base_dir,long.dataset.names,'/spaceranger/')
temp_var2<- replicate(length(dataset.labels), "")
ST_automated<- data.frame (sample_id= names(dataset.labels), species= species_sample, st_data_dir=temp_var, sc_data_dir= temp_var2 )
dir.create(file.path(base_dir, '/automatic_analysis/'))
write.csv(ST_automated,paste0(base_dir,'/automatic_analysis/',curr_datatypes,'.csv'), row.names = FALSE ,quote=FALSE)

dataset.metadata.df <- data.frame(sample.name = names(dataset.labels), type = unlist(unname(dataset.labels)))

# # Strip off everything past the "_" so that SC2200108_DT-21-4142-BR6526 -> SC2200108
# simple.dataset.names <- unlist(lapply(long.dataset.names, function(str) unlist(strsplit(str,split="_"))[1]))
#names(long.dataset.names) <- simple.dataset.names
#names(dataset.labels) <- simple.dataset.names
#datasets <- simple.dataset.names


datasets <- names(long.dataset.names)
names(datasets) <- datasets
```

```{r}

sample.lvls <- dataset.metadata.df$sample.name
sample.lvls <- sample.lvls[order(dataset.metadata.df$sample.name, dataset.metadata.df$type)]
datasets <- datasets[sample.lvls]
dataset.labels <- dataset.labels[sample.lvls]
long.dataset.names <- long.dataset.names[sample.lvls]

ffpe.datasets <- datasets[dataset.labels == "FFPE"]
frozen.datasets <- datasets[dataset.labels == "Frozen"]
color_list<-list('FFPE'="#d8b365" , 'Frozen'='#5ab4ac')


# Directory holding the raw data
spaceranger_dirs <- paste0(base_dir, long.dataset.names, "/spaceranger/")
names(spaceranger_dirs) <- datasets

# Define and create output results and plots directories
# base_dir_antonis<-'/projects/compsci/USERS/somara/cancer-cude/qc-pilot/'
analysis_dir <- paste0(base_dir, '/analysis/')
dir.create(analysis_dir, showWarnings = FALSE, recursive = TRUE)
plots_dir <- paste0(base_dir, '/plots/')
dir.create(plots_dir, showWarnings = FALSE, recursive = TRUE)

# Prefix for all output files (results and plots)
analysis_file_prefix <- paste0(curr_datatypes,"-pilot-")
```



```{r}
#' Get the position information for each spot in a tissue
#' 
#' A function that extracts spot position information from the spaceranger output corresponding to 
#' a single tissue. See https://support.10xgenomics.com/spatial-gene-expression/software/pipelines/latest/output/images
#' for a full description.
#'
#' @param spaceranger_dir The path to the spaceranger output.
#' @return A data.frame with columns:
#'  barcode: The sequence of the barcode associated to the spot.
#'  in_tissue: Binary, indicating if the spot falls inside (1) or outside (0) of tissue.
#'  array_row: The row coordinate of the spot in the array from 0 to 77. The array has 78 rows.
#'  array_col: The column coordinate of the spot in the array. In order to express the orange crate arrangement of the spots, this column index uses even numbers from 0 to 126 for even rows, and odd numbers from 1 to 127 for odd rows. Notice then that each row (even or odd) has 64 spots.
#'  pxl_row_in_fullres: The row pixel coordinate of the center of the spot in the full resolution image.
#'  pxl_col_in_fullres: The column pixel coordinate of the center of the spot in the full resolution image.
get.tissue.position.metadata <- function(spaceranger_dir) {
  image.dir <- paste0(spaceranger_dir, "/", "spatial/")
  tissue.positions <- 
    read.csv(file = file.path(image.dir, "tissue_positions_list.csv"), 
             col.names = c("barcodes", "tissue", "row", "col", "imagerow", "imagecol"), header = FALSE, 
             as.is = TRUE, row.names = 1)
  tissue.positions
}
```


```{r}
# Read in the filtered and unfiltered matrices and append the tissue positions information to the metadata:
filtered.objs <- 
  llply(datasets, 
        .fun = function(dataset) {
          # NB: here loading filtered_feature_bc_matrix.h5 with filter.matrix = TRUE
          # filtered_feature_bc_matrix.h5 should only contain data from spots overlaying tissue,
          # though I can't find this documented conclusively.
          # filter.matrix = TRUE definitely filteres coordinates in the Seurat object
          # according to those that overlap the tissue (i.e., have tissue == 1 in the
          # tissue_positions_list.csv file -- see code for Read10X_Image, which is called
          # by Load10X_Spatial)
          
          # See this issue for how to set up these individual objects such that we can merge them:
          # https://github.com/satijalab/seurat/issues/3732
          # Namely, set the slice and then the orig.ident
          obj <- Seurat::Load10X_Spatial(spaceranger_dirs[[dataset]], filename = 'filtered_feature_bc_matrix.h5', filter.matrix = TRUE, slice = dataset)
          obj$orig.ident <- dataset
          tissue.positions <- get.tissue.position.metadata(spaceranger_dirs[[dataset]])
          tissue.positions$spot_type <- "background"
          tissue.positions[tissue.positions$tissue == 1, "spot_type"] <- "tissue"
          obj <- AddMetaData(obj, tissue.positions)
          obj
        })

unfiltered.objs <- 
  llply(datasets, 
        .fun = function(dataset) {
          # NB: here loading raw_feature_bc_matrix.h5 with filter.matrix = FALSE
          obj <- Seurat::Load10X_Spatial(spaceranger_dirs[[dataset]], filename = 'raw_feature_bc_matrix.h5', filter.matrix = FALSE, slice = dataset)
          obj$orig.ident <- dataset
          tissue.positions <- get.tissue.position.metadata(spaceranger_dirs[[dataset]])
          tissue.positions$spot_type <- "background"
          tissue.positions[tissue.positions$tissue == 1, "spot_type"] <- "tissue"
          obj <- AddMetaData(obj, tissue.positions)
          obj
        })

```


```{r}
expressed.genes <- 
  llply(filtered.objs,
        .fun = function(obj) {
          mat <- Seurat::GetAssayData(obj, assay="Spatial")
          rownames(mat)[rowSums(mat) > 0]
        })

num.expressed.genes <-
  llply(expressed.genes, .fun = function(lst) length(lst))

num.expressed.genes <- data.frame(sample = names(num.expressed.genes), metric = "Total.Genes.Detected", value = as.vector(unlist(num.expressed.genes)))

```



```{r}
# Read in the spaceranger summaries
summary.tbl <- 
  ldply(datasets, 
        .fun = function(dataset) {
          # json.summary.file <- paste0(spaceranger_dirs[[dataset]], "/", "summary.json")
          # json.summary <- fromJSON(file=json.summary.file)
          # json.summary
          seq.metrics.file <- paste0(spaceranger_dirs[[dataset]], "/", "metrics_summary.csv")
          tbl <- read.table(seq.metrics.file, sep=",", header=TRUE, as.is=TRUE)
          #rename.cols <- list("Reads.Mapped.Confidently.to.Probe.Set" = "Reads.Mapped.Confidently.to.Genome", "Number.of.Panel.Genes....10.UMIs" = "Total.Genes.Detected")
          rename.cols <- list("Reads.Mapped.Confidently.to.Probe.Set" = "Reads.Mapped",
                              "Reads.Mapped.Confidently.to.Genome"= "Reads.Mapped" ,"Number.of.Panel.Genes....10.UMIs" = "Total.Genes.Detected")

          for(col in names(rename.cols)) {
            flag <- colnames(tbl) == col
            colnames(tbl)[flag] <- rename.cols[[col]]
          }
          tbl
        })
colnames(summary.tbl)[1] <- "sample"

# cols <- c("Total.Genes.Detected", "Reads.Mapped.Confidently.to.Genome",  "Number.of.Reads",  "Number.of.Spots.Under.Tissue", "Fraction.of.Spots.Under.Tissue", "Median.Genes.per.Spot", "Median.UMI.Counts.per.Spot", "Fraction.Reads.in.Spots.Under.Tissue", "Sequencing.Saturation")
#cols <- c("Reads.Mapped.Confidently.to.Genome",  "Number.of.Reads",  "Number.of.Spots.Under.Tissue", "Fraction.of.Spots.Under.Tissue", "Median.Genes.per.Spot", "Median.UMI.Counts.per.Spot", "Fraction.Reads.in.Spots.Under.Tissue", "Sequencing.Saturation")
cols <- c("Number.of.Reads", "Reads.Mapped", "Number.of.Spots.Under.Tissue", "Fraction.of.Spots.Under.Tissue", "Median.Genes.per.Spot", "Median.UMI.Counts.per.Spot", "Fraction.Reads.in.Spots.Under.Tissue", "Sequencing.Saturation")
summary.tbl <- summary.tbl[, c("sample", cols)]
summary.tbl <- melt(summary.tbl, id.vars = c("sample"))
colnames(summary.tbl) <- c("sample", "metric", "value")
summary.tbl <- rbind(summary.tbl, num.expressed.genes)
summary.tbl$metric <- gsub(summary.tbl$metric, pattern="\\.", replacement=" ")
cols <- gsub(cols, pattern="\\.", replacement=" ")
summary.tbl$metric <- factor(summary.tbl$metric, levels = c("Total Genes Detected",cols))
summary.tbl$sample <- factor(summary.tbl$sample, levels=sample.lvls)
summary.tbl <- merge(summary.tbl, dataset.metadata.df, by.x = "sample", by.y ="sample.name")


g <- ggplot(data = subset(summary.tbl, metric == "Fraction Reads in Spots Under Tissue"), aes(x = sample, y = value, fill=type)) + geom_bar(stat="identity") + scale_fill_manual(values= unname(unlist(color_list)))
g <- g + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
g <- g + ylab("Fraction Reads in Spots\nUnder Tissue") + xlab("")
g <- g + theme(text = element_text(size = 20))
png(paste0(plots_dir, "/", analysis_file_prefix, "frac-reads-in-spots.png"))
print(g)
d <- dev.off()

g <- ggplot(data = subset(summary.tbl, !(metric %in% c("Fraction Reads in Spots Under Tissue", "Number of Spots Under Tissue"))), aes(x = sample, y = value, fill=type)) + geom_bar(stat="identity") + scale_fill_manual(values= unname(unlist(color_list))) + facet_wrap(~ metric, scales="free", labeller = label_wrap_gen())
g <- g + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
g <- g + ylab("")
png(paste0(plots_dir, "/", analysis_file_prefix, "summary.png"), width = 2 * 480)
print(g)
d <- dev.off()
```

```{r}
# Perform normalization of counts using SCTransform (which fits a negative binomial to the count data)
# This adds a new assay "SCT" to the returned Seurat object. That assay has slots "counts" (the corrected counts),
# "data" (log1p(counts)), and "scale.data" (the "pearson residuals").
# These would be accessible via GetAssayData(filtered.objs[[1]], slot = "data", assay = "SCT")
# Running with default parameters (the most interesting of which look to be variable.features.n and/or variable.features.rv.th)
filtered.objs <-
  llply(filtered.objs,
        .fun = function(obj) SCTransform(obj, assay = "Spatial", verbose = FALSE))
```

```{r}
# Also apply scran deconvolution-based normalization.
# scran uses SingleCellExperiment objects, so we will have to convert back and forth between SCEs and Seurat objects.
# See notes on interoperability here: https://satijalab.org/seurat/archive/v3.1/conversion_vignette.html

filtered.objs <-
  llply(filtered.objs, .parallel = FALSE,
        .fun = function(obj) {
          
          # Convert from a Seurat object to a SingleCellExperiment
          sce <- as.SingleCellExperiment(obj, assay = "Spatial")

          
          # Perform the scran normalization (see https://bioconductor.org/packages/devel/bioc/vignettes/scran/inst/doc/scran.html)
          clusters <- quickCluster(sce)
          sce <- computeSumFactors(sce, clusters=clusters)
          sce <- logNormCounts(sce)
          
          # Convert back from SingleCellExperiment to Seurat object. 
          tmp <- as.Seurat(sce, counts = "counts", data = "logcounts", assay="scran")
          obj[["scran"]] <- tmp[["scran"]]
          obj <- FindVariableFeatures(obj, assay="scran")
          obj
        })
          
```


```{r}
# Merge the unfiltered objs into one Seurat object
all.unfiltered.objs <- Reduce(merge, unfiltered.objs)
Idents(all.unfiltered.objs) <- all.unfiltered.objs$orig.ident
```


```{r}
all.filtered.objs <- Reduce(merge, filtered.objs)
Idents(all.filtered.objs) <- all.filtered.objs$orig.ident
```


```{r}
obj.sct <- all.filtered.objs
DefaultAssay(obj.sct) <- "SCT"
VariableFeatures(obj.sct, assay="SCT") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="SCT")))))
obj.sct <- RunPCA(obj.sct, verbose = FALSE)
ElbowPlot(obj.sct, ndims = 40)
mat <- Seurat::GetAssayData(obj.sct, assay = "SCT")
pca <- obj.sct[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(as.matrix(mat)))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance
cumVarExplained <- cumsum(varExplained)

obj.sct <- RunHarmony(obj.sct, group.by.vars = make.names("orig ident"))

# Pick the number of dimensions based on a flattening of the elbow plot
obj.sct <- FindNeighbors(obj.sct,reduction = "harmony", dims = 1:20)
obj.sct <- FindClusters(obj.sct, reduction = "harmony",verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = "harmony",dims = 1:20)
png(paste0(plots_dir,"clusters-merged-UMAP-sct.png"),width=1400,height =600)
obj.sct$Sample=obj.sct$orig.ident
obj.sct$Cluster=obj.sct@active.ident
gg <- DimPlot(obj.sct, reduction = "umap", group.by = c("Cluster","Sample")) 
print(gg)
d <- dev.off()

per_id_per_cluster_tbl<-table(obj.sct@meta.data$seurat_clusters, obj.sct@meta.data$orig.ident)

foo <- (melt(per_id_per_cluster_tbl))
colnames(foo) <- c("cluster", "sample", "cnt")

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

for(target_sample in biological.replicates) {
  bar <- subset(foo, grepl(sample, pattern=target_sample))
  bar <- subset(bar, cnt != 0)
  bar <- melt(acast(bar, cluster ~ sample, fill = 0))
  colnames(bar) <- c("cluster", "sample", "cnt")
  bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
  bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
  png(paste0(plots_dir,target_sample,"-cluster-proportions-sct.png"))
  g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
  g <- g + ylab("Fraction") + xlab("Cluster")
  g <- g + theme(text = element_text(size = 20))
  print(g)
  d <- dev.off()
}

bar <- subset(foo, cnt != 0)
bar <- melt(acast(bar, cluster ~ sample, fill = 0))
colnames(bar) <- c("cluster", "sample", "cnt")
bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
png(paste0(plots_dir,"all-cluster-proportions-sct.png"))
g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
g <- g + ylab("Fraction") + xlab("Cluster")
g <- g + theme(text = element_text(size = 20))
print(g)
d <- dev.off()

png(paste0(plots_dir,"all-cluster-proportions-heatmap-sct.png"),width=980, height=980)

color_list<-list('FFPE'="#d8b365" , 'Frozen'='#5ab4ac')
colSide <- as.vector(unlist(color_list[unlist(dataset.labels[levels(bar$sample)])]))

heatmap.2(acast(bar[, c("cluster","sample","frac")], cluster ~ sample),row_title="Cluster",column_title="Sample",heatmap_legend_param=list(title="Proportion"), ColSideColors = colSide ,col =rev( colorRampPalette(brewer.pal(8, "RdBu"))(25)),xlab="Cluster", ylab="Sample",margins=c(12,8),trace="none",lhei=c(1, 6),keysize=1,key.title="Proportion")
d <- dev.off()
```

```{r}

ffpe.genes <- unique(Reduce(c,expressed.genes[ffpe.datasets]))
frozen.genes <- unique(Reduce(c,expressed.genes[frozen.datasets]))

x <- list(FFPE = ffpe.genes, frozen = frozen.genes)
g <- ggVennDiagram(x, label_size = 10, set_size = 10)
g <- g + theme(legend.position = "none") 
png(paste0(plots_dir,"ffpe-frozen-venn.png"))
print(g)
d <- dev.off()

# Get the genes that are only highly expressed in fresh frozen samples
# and output their "biotype" -- i.e., whether are coding genes, etc.
frozen.only <- frozen.genes[!(frozen.genes %in% ffpe.genes)]

library(biomaRt)
if (species_sample[1]=='Human'){
    gene_db = useMart("ensembl",dataset="hsapiens_gene_ensembl")
} else {
  gene_db = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
}

gb <- getBM(attributes=c("external_gene_name", "gene_biotype"),filters = c("external_gene_name"), values=frozen.only, mart=gene_db)

frozen.only.biotypes <- as.data.frame(table(gb$gene_biotype))
colnames(frozen.only.biotypes) <- c("biotype", "Freq")
o <- order(frozen.only.biotypes$Freq, decreasing=TRUE)
frozen.only.biotypes <- frozen.only.biotypes[o,]

png(paste0(plots_dir,"frozen-biotypes.png"))
grid.table(frozen.only.biotypes,rows=NULL)
d <- dev.off()

ffpe.only <- ffpe.genes[!(ffpe.genes %in% frozen.genes)]

gb <- getBM(attributes=c("external_gene_name", "gene_biotype"),filters = c("external_gene_name"), values=ffpe.only, mart=gene_db)

ffpe.only.biotypes <- as.data.frame(table(gb$gene_biotype))
colnames(ffpe.only.biotypes) <- c("biotype", "Freq")
o <- order(ffpe.only.biotypes$Freq, decreasing=TRUE)
ffpe.only.biotypes <- ffpe.only.biotypes[o,]

png(paste0(plots_dir,"ffpe-biotypes.png"))
grid.table(ffpe.only.biotypes,rows=NULL)
d <- dev.off()
```


```{r}
obj.scran <- all.filtered.objs
DefaultAssay(obj.scran) <- "scran"
obj.scran <- ScaleData(obj.scran, assay="scran")
VariableFeatures(obj.scran, assay="scran") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="scran")))))
obj.scran <- RunPCA(obj.scran, verbose = FALSE)
ElbowPlot(obj.scran, ndims = 40)
mat <- Seurat::GetAssayData(obj.scran, assay = "scran")
pca <- obj.scran[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(as.matrix(mat)))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance
cumVarExplained <- cumsum(varExplained)

obj.scran <- RunHarmony(obj.scran, group.by.vars = make.names("orig ident"))

obj.scran <- FindNeighbors(obj.scran,reduction = "harmony", dims = 1:20)
obj.scran <- FindClusters(obj.scran, reduction = "harmony", verbose = FALSE)
obj.scran <- RunUMAP(obj.scran, reduction = "harmony", dims = 1:20)
png(paste0(plots_dir,"clusters-merged-UMAP-scran.png"),width=1400,height =600)
obj.scran$Sample=obj.scran$orig.ident
obj.scran$Cluster=obj.scran@active.ident
gg <- DimPlot(obj.scran, reduction = "umap", group.by = c("Cluster","Sample")) 
print(gg)
d <- dev.off()

per_id_per_cluster_tbl<-table(obj.scran@meta.data$seurat_clusters, obj.scran@meta.data$orig.ident)

foo <- (melt(per_id_per_cluster_tbl))
colnames(foo) <- c("cluster", "sample", "cnt")

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

for(target_sample in biological.replicates) {
  bar <- subset(foo, grepl(sample, pattern=target_sample))
  bar <- subset(bar, cnt != 0)
  bar <- melt(acast(bar, cluster ~ sample, fill = 0))
  colnames(bar) <- c("cluster", "sample", "cnt")
  bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
  bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
  png(paste0(plots_dir,target_sample,"-cluster-proportions-scran.png"))
  g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
  g <- g + ylab("Fraction") + xlab("Cluster")
  g <- g + theme(text = element_text(size = 20))
  print(g)
  d <- dev.off()
}

bar <- subset(foo, cnt != 0)
bar <- melt(acast(bar, cluster ~ sample, fill = 0))
colnames(bar) <- c("cluster", "sample", "cnt")
bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
png(paste0(plots_dir,"all-cluster-proportions-scran.png"))
g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
g <- g + ylab("Fraction") + xlab("Cluster")
g <- g + theme(text = element_text(size = 20))
print(g)
d <- dev.off()

color_list<-list('FFPE'="#d8b365" , 'Frozen'='#5ab4ac')
colSide <- as.vector(unlist(color_list[unlist(dataset.labels[levels(bar$sample)])]))
par(cex.main=80)
png(paste0(plots_dir,"all-cluster-proportions-heatmap-scran.png"),width=680, height=980)
heatmap.2(acast(bar[, c("cluster","sample","frac")], cluster ~ sample),row_title="Cluster",column_title="Sample",heatmap_legend_param=list(title="Proportion"), ColSideColors = colSide ,col =rev( colorRampPalette(brewer.pal(8, "RdBu"))(25)),ylab="Cluster", xlab="Sample",margins=c(13,6),trace="none",lhei=c(1,8),keysize=2,key.title="Proportion",cexRow = 2.5,cexCol = 2.5) 
#title('ddddddd', cex.main = 15 * op[["cex.main"]])
 ## this will affect also legend title font size

#g<- g + title(main, cex.main = 1.5 * op[["cex.main"]])
d <- dev.off()

```



```{r}
# Add simplified sample names
sample.name.df <- data.frame(all.unfiltered.objs@meta.data[, c("orig.ident"), drop = FALSE])
sample.name.df$sample.name <- unlist(lapply(sample.name.df$orig.ident, function(str) unlist(strsplit(str, split="_"))[1]))
all.unfiltered.objs <- AddMetaData(all.unfiltered.objs, sample.name.df[, c("sample.name"), drop = FALSE])
```


```{r}
#' Create a spatial feature plot
#' 
#' A convenience function that wraps Seurat's SpatialFeaturePlot to add a centered title and a legend at the bottom.
#'
#' @param obj A Seurat object.
#' @param features A vector of strings listing one or more features to plot.
#' @param legend.name A string name for the legend
#' @return a ggplot
plot.spatial <- function(obj, features = c("nCount_Spatial"), legend.name = "Read Count") {
  g <- suppressWarnings(SpatialFeaturePlot(obj, features = features) )
  # g <- g + theme(plot.title = element_text(hjust = 0.5), text = element_text(size = 15), legend.position = "bottom", legend.key.width = unit(1.5, 'cm'))
  g <- g + theme(plot.title = element_text(hjust = 0.5), text = element_text(size = 15), legend.position = "bottom")
  g <- g + suppressWarnings(scale_fill_gradientn(name = legend.name, labels = function(x) { sprintf('%.0fk', x/1000) }, colours = Seurat:::SpatialColors(n = 100)))
  g
}
```

```{r}
#' Create a plot of the raw H&E image
#' 
#' A convenience function that wraps Seurat's SpatialFeaturePlot to plot only the overlaid H&E image and not the spots.
#'
#' @param obj A Seurat object.
#' @return a ggplot
plot.hne <- function(obj, keep.invisible.legend = FALSE) {
  # Set the opacity/alpha to 0 so that we only see the H&E image.
  g <- suppressWarnings(SpatialFeaturePlot(obj, features = "nCount_Spatial", alpha = c(0,0)))
  g <- g + theme(plot.title = element_text(hjust = 0.5), text = element_text(size = 15))
  if(keep.invisible.legend) {
    g <- g + theme(legend.position = "bottom") 
    g <- g + theme(legend.title = element_text(color = "transparent"), legend.text = element_text(color = "transparent"))
    # g <- g + scale_fill_continuous(fill = guide_legend(override.aes = list(alpha = 1)))
    # g <- g + scale_fill_gradientn(colors = brewer.pal(10,"Spectral"), guide = guide_legend(override.aes = list(alpha = 1)))
    # g <- g + guides(fill = guide_legend(override.aes = list(alpha = 1)))
    g <- g + scale_fill_gradientn(colours = c("white"))
  } else {
    g <- g + theme(legend.position = "none")
  }
  g
}
```


```{r}
#' Add a title to a cowplot
#' 
#' A convenience function that adds a panel with a title above an existing figure.
#'
#' @param g A ggplot.
#' @param title A string title.
#' @param size Size of title text.
#' @return A ggplot
add.title.to.plot <- function(g, title, size = 14) {
  g.title <- ggdraw() +  draw_label(title, size = size)
  g <- cowplot::plot_grid(title = g.title, g, nrow=2, rel_heights=c(0.1,1))
  g
}
```


```{r}
# Plot the number of UMI counts per spot for unfiltered data (in files *unfiltered-spot-counts.png.png)
unfiltered.count.plots <-
  llply(datasets,
        .fun = function(dataset) {
          g <- plot.spatial(unfiltered.objs[[dataset]], features = c("nCount_Spatial"), legend.name = "Count")
          g <- g + theme(legend.text=element_text(size=9))
          title <- paste0(dataset, "\n", dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist = unfiltered.count.plots)
g.all <- add.title.to.plot(g.all, "All Spots")
png(paste0(plots_dir, "/", analysis_file_prefix, "unfiltered-spot-counts.png"))
print(g.all)
d <- dev.off()
```

```{r}
# Plot the number of feature counts per spot for unfiltered data (in files *unfiltered-spot-features.png)
unfiltered.feature.plots <-
  llply(datasets,
        .fun = function(dataset) {
          g <- plot.spatial(unfiltered.objs[[dataset]], features = c("nFeature_Spatial"), legend.name = "Feature")
          g <- g + theme(legend.text=element_text(size=9))
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist = unfiltered.feature.plots)
g.all <- add.title.to.plot(g.all, "All Spots")
png(paste0(plots_dir, "/", analysis_file_prefix, "unfiltered-spot-features.png"))
print(g.all)
d <- dev.off()
```
```{r}
# Plot the raw H&E images (in files *hne.png)
hne.plots <-
  llply(datasets,
        .fun = function(dataset) {
          g <- plot.hne(unfiltered.objs[[dataset]], keep.invisible.legend = TRUE)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist = hne.plots)
g.all <- add.title.to.plot(g.all, "Raw H&E")
png(paste0(plots_dir, "/", analysis_file_prefix, "hne.png"))
print(g.all)
d <- dev.off()
```

```{r}
#' Plot distribution of a response variable (e.g., UMI count) across spots relative to a dependent variable (e.g., tissue vs background spot status)
#' 
#' Create violin/boxplots showing distribution across spots of a user-specified response variable relative to a dependent variable and facted by sample.
#'
#' @param df A data.frame holding the response, depenndent, and faceting variables.
#' @param response.var The variable whose distribution over spots will be plotted.
#' @param facet.var The faceting variable.
#' @param dependent.var The variable that the response variable will be plotted as a function of.
#' @return A ggplot
plot.distributions.vs.cell.type <- function(df, response.var = "nCount_Spatial", facet.var = "sample.name", dependent.var = "spot_type") {
  lvls <- unique(df[, facet.var, drop=TRUE])
  df[,facet.var] <- factor(df[,facet.var], levels=lvls)
  stat.test <- df %>% group_by_at(facet.var) %>% wilcox_test(as.formula(paste0(response.var, " ~ ", dependent.var)), p.adjust.method = "none")
  stat.test$p.adj <- p.adjust(stat.test$p, method = "bonferroni")
  stat.test <- stat.test %>% add_xy_position(x = dependent.var)
  stat.test$y.position <- log2(stat.test$y.position)
  stat.test$label <- stars.pval(stat.test$p.adj)
  g <- ggviolin(df, dependent.var, response.var, facet.by = facet.var, add = "boxplot")
  g <- g + yscale("log2") + stat_pvalue_manual(stat.test, label="label") + xlab("Spot Type")
  g
}
```


```{r}
# Plot the distribution of UMI counts and gene counts over spots, as a function of whether those spots and within the tissue or outside of it (in file *count-and-feature-dist.png)
tbl <- all.unfiltered.objs@meta.data
tbl <- merge(tbl, dataset.metadata.df)
# tbl <- tbl[order(tbl$sample.name, tbl$type, tbl$sample.name, decreasing=TRUE),]
tbl$sample <- factor(tbl$sample, levels = sample.lvls)
tbl$sample.label <- paste0(tbl$sample.name, "\n", tbl$type)
g.cnt <- plot.distributions.vs.cell.type(tbl, response.var = "nCount_Spatial", facet.var = "sample.label") + ylab("UMI Counts (log2)")
g.feature <- plot.distributions.vs.cell.type(tbl, response.var = "nFeature_Spatial", facet.var = "sample.label") + ylab("Feature Counts (log2)")
g <- plot_grid(g.cnt, g.feature, nrow=1, labels = "AUTO")
png(paste0(plots_dir, "/", analysis_file_prefix, "count-and-feature-dist.png"), width = 2 * 480)
print(g)
d <- dev.off()

```
```{r}
#' Return count matrix from a Seurat object
#' 
#' @param obj A Seurat object.
#' @return A (sparse) matrix holding the spot counts (i.e., from the "counts" slot)
get.count.matrix <- function(obj) {
  as.matrix(x = GetAssayData(object = obj, assay = "Spatial", slot = "counts"))
}

#' Downsample each column of a matrix to a desired total count.
#'
#' A function that, independently for each column/cell, uses a multinomial distribution, parameterized 
#' by the frequency of each gene within that column/cell and the desired total count, to sample a vector of gene counts.
#' This is in contrast to related functions such as SampleUMI (in Seurat), which applies a binomial to each gene (!?)
#' and thus only approximates the desired total count, and downsampleMatrix (in DropletUtils), which downsamples to
#' a fraction of the original number of reads.
#'
#' @param expr_mat A (possibly sparse) matrix of counts.
#' @param tot_cnt The desired number of counts _for each column_
#' @return A downsample matrix
downsample.matrix <- function (expr_mat, tot_cnt) 
{
    down_sample <- function(x) {
        prob <- x/sum(x)
        return(rmultinom(1, tot_cnt, prob))
    }
    down_sampled_mat <- apply(expr_mat, 2, down_sample)
    return(down_sampled_mat)
}

#' Compute the number of expressed genes/features in a downsampled matrix.
#' 
#' A function to downsample the input matrix such that each cell/column has tot_cnt reads and
#' that reports the _median_ (across cells/columns) number of genes/features with non-zero counts.
#'
#' @param expr_mat A (possibly sparse) matrix of counts.
#' @param tot_cnt The desired number of counts _for each column_
#' @return The median (across cells/columns) number of genes/features with non-zero counts in the downsampled matrix.
compute.num.features.at.total.reads <- function(expr_mat, tot_cnt) {
  ds <- downsample.matrix(expr_mat, tot_cnt)
  return(median(colSums(ds > 0)))
}
```

```{r}
# Calculate the median number of reads (across spots) for each sample
# NB: using filtered data here
median.num.reads <- llply(filtered.objs, .fun = function(obj) median(colSums(get.count.matrix(obj))))
```

```{r}
# Perform a sensitivity analysis -- i.e., show the number of detected genes/features as a function
# of total UMI counts per spot. More precisely, we will plot the median (across spots) number of
# detected genes vs the median (across spots) UMI count.

all.downsample.cnts <- round(seq(from=0.1,to=0.9,by=0.1)*max(unlist(median.num.reads)))
names(all.downsample.cnts) <- all.downsample.cnts
downsample.feature.df <-
  ldply(filtered.objs,
        .parallel = FALSE,
        .fun = function(obj) {
          expr_mat <- get.count.matrix(obj)
          median.cnts <- median(colSums(expr_mat))
          downsample.cnts <- all.downsample.cnts[all.downsample.cnts < median.cnts]
          tbl <- 
            ldply(downsample.cnts, .parallel = TRUE,
                  .fun = function(tot_cnt) {
                    data.frame(num.features = compute.num.features.at.total.reads(expr_mat, tot_cnt))
                  })
          colnames(tbl)[1] <- "downsample.count"
          tbl
        })
colnames(downsample.feature.df)[1] <- "sample.name" 
downsample.feature.df$downsample.count <- as.numeric(downsample.feature.df$downsample.count)
downsample.feature.df <- merge(downsample.feature.df, dataset.metadata.df)
```

```{r}
# Plot the sensitivity (# of detected genes/features vs # of reads; in file *num-features-vs-num-downsampled-reads.png)
g <- ggplot(downsample.feature.df, aes(x = downsample.count, y = num.features, colour = sample.name, shape = type))
g <- g + geom_point()
g <- g + xlab("Spot Read Count (Median)") + ylab("Spot Feature Count (Median)")
g <- g + theme(text = element_text(size = 20))
png(paste0(plots_dir, "/", analysis_file_prefix, "num-features-vs-num-downsampled-reads.png"))
print(g)
d <- dev.off()
            
```


```{r}
#' Return most highly-expressed genes
#' 
#' A function to return the most highly-expressed genes (i.e., those with highest value) from a matrix.
#'
#' @param mat A (sparse) matrix.
#' @param n.top The number of genes to return.
#' @param assay The assay from which to access the gene exprssion/values in the Seurat object.
#' @param slot The slot in the assay form which to access the gene expression/values.
#' @return A vector of the highest-expressed genes.
get.top.genes.matrix <- function(mat, n.top = 20, assay = "Spatial", slot = "data") {
  rs <- rowSums(mat)
  rs <- rs[order(rs, decreasing=TRUE)]
  top.genes <- names(rs)[1:n.top]
  top.genes
}

#' Return most highly-expressed genes
#' 
#' A function to return the most highly-expressed genes (i.e., those with highest value) from a Seurat assay.
#'
#' @param obj A Seurat object.
#' @param n.top The number of genes to return.
#' @param assay The assay from which to access the gene exprssion/values in the Seurat object.
#' @param slot The slot in the assay form which to access the gene expression/values.
#' @return A vector of the highest-expressed genes.
get.top.genes <- function(obj, n.top = 20, assay = "Spatial", slot = "data") {
  mat <- GetAssayData(obj, assay = assay, slot = slot)
  get.top.genes.matrix(mat, n.top = n.top, assay = assay, slot = slot)
}

#' Return data subsetted by spot tissue status
#' 
#' A function to return the subset of the data corresponding to spots that are (or are not) in the tissue
#'
#' @param obj A Seurat object.
#' @param tissue.val Spots with tissue.val for the tissue.col metadata field will be retained.
#' @param tissue.col The metadata column of the Seurat object holding the tissue status
#' @param assay The assay from which to access the gene exprssion/values in the Seurat object.
#' @param slot The slot in the assay form which to access the gene expression/values.
#' @return A (sparse) matrix of spots that are (or are not) in tissue
subset.matrix.based.on.tissue.status <- function(obj, tissue.val, tissue.col = "tissue", assay = "Spatial", slot = "data") {
  cell.subset <- rownames((obj@meta.data)[(obj@meta.data)[,tissue.col] == tissue.val,])
  mat <- GetAssayData(obj, assay = assay, slot = slot)
  mat[,cell.subset]
}
```

```{r}
plot.top.genes <- function(mat, n.top = 20, highlight.genes = NULL) {
  mat <- sweep(mat, 2, colSums(mat), "/")
  top.genes <- get.top.genes.matrix(mat, n.top = n.top)
  df <- melt(mat[top.genes,])
  colnames(df) <- c("gene", "spot", "value")
  df$gene <- factor(df$gene, levels = rev(top.genes))
  g <- ggplot() + geom_boxplot(data = df, aes(x = gene, y = 100 * value), fill = (scales::hue_pal())(n.top)[n.top:1]) + coord_flip()
  g <- g + ylab("% total count per cell") + xlab("")
  g <- g + theme(text = element_text(size=20), plot.title = element_text(hjust = 0.5))
  if(!is.null(highlight.genes)) {
    vec_fontface <- ifelse(levels(df$gene) %in% highlight.genes,"bold","plain")
    g <- g + theme(axis.text.y=element_text(face=vec_fontface))
  }
  g
}
```


```{r}
# Get the most prevalent genes expressed in the background ...
top.genes.background <-
  llply(datasets,
        .fun = function(data.set) {
          obj <- unfiltered.objs[[data.set]]
          mat <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 0, assay = "Spatial", slot = "counts"))
          mat <- sweep(mat, 2, colSums(mat), "/")
          top.genes <- get.top.genes.matrix(mat, n.top = 20)
          top.genes
        })

# ... and in the tissue
top.genes.tissue <-
  llply(datasets,
        .fun = function(data.set) {
          obj <- unfiltered.objs[[data.set]]
          mat <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          mat <- sweep(mat, 2, colSums(mat), "/")
          top.genes <- get.top.genes.matrix(mat, n.top = 20)
          top.genes
        })

```

```{r}
# Find genes that are common between the (union of) background genes and the (union of) tissue genes
all.background.genes <- unique(Reduce("c", top.genes.background))
all.tissue.genes <- unique(Reduce("c", top.genes.tissue))
common.genes <- intersect(all.background.genes, all.tissue.genes)

intersect.background.genes <- unique(Reduce("intersect", top.genes.background))
intersect.tissue.genes <- unique(Reduce("intersect", top.genes.tissue))


flag <- dataset.labels == "FFPE"
ffpe.background.genes <- unique(Reduce("c", top.genes.background[flag]))
ffpe.tissue.genes <- unique(Reduce("c", top.genes.tissue[flag]))
common.ffpe.genes <- intersect(ffpe.background.genes, ffpe.tissue.genes)
intersect.tissue.ffpe.genes <- unique(Reduce("intersect", top.genes.tissue[flag]))

```


```{r}
```


```{r}
# Create plots showing the top 20 most prevalent genes in the background -- highlighting (in bold) the
# genes that are common to the background and tissue
top.genes.background.plts <-
  llply(datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          background.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 0, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(background.sub.matrix, n.top = 20, highlight.genes = intersect.background.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.background.plts)
g.all <- add.title.to.plot(g.all, "Background Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-background-spot.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

# Do the same for spots in the tissue
top.genes.tissue.plts <-
  llply(datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          tissue.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(tissue.sub.matrix, n.top = 20, highlight.genes = intersect.tissue.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.tissue.plts)
g.all <- add.title.to.plot(g.all, "Tissue Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-tissue-spot.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

# Repeat both of the above, but only for FFPE
# Create plots showing the top 20 most prevalent genes in the background -- highlighting (in bold) the
# genes that are common to the background and tissue
top.genes.background.ffpe.plts <-
  llply(ffpe.datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          background.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 0, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(background.sub.matrix, n.top = 20, highlight.genes = common.ffpe.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.background.ffpe.plts)
g.all <- add.title.to.plot(g.all, "Background Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-background-spot-ffpe-only.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

# Do the same for spots in the tissue
top.genes.tissue.ffpe.plts <-
  llply(ffpe.datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          tissue.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(tissue.sub.matrix, n.top = 20, highlight.genes = common.ffpe.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.tissue.ffpe.plts)
g.all <- add.title.to.plot(g.all, "Tissue Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-tissue-spot-ffpe-only.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

top.genes.intersect.tissue.ffpe.plts <-
  llply(ffpe.datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          tissue.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(tissue.sub.matrix, n.top = 20, highlight.genes = intersect.tissue.ffpe.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.intersect.tissue.ffpe.plts)
g.all <- add.title.to.plot(g.all, "Tissue Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-tissue-spot-intersect-ffpe-only.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()



```


```{r}
mylist_qval<-list()
mylist_top50_LLR<-list()
mylist_top100_LLR<-list()
for (i in names(long.dataset.names)){
  r<-read.csv(file = paste0(base_dir, "/automatic_analysis/results/",i,"/stSpatialDE.csv"), header = TRUE, as.is = TRUE, row.names = 1)
  r  <-r[r$qval==0,]
  mm <-sort(r$LLR,decreasing= TRUE,index.return = TRUE)
  
  mylist_qval[[ i ]]<-r$g.1
  mylist_top50_LLR[[ i ]]<-r$g.1[mm$ix[1:50]]
  mylist_top100_LLR[[ i ]]<-r$g.1[mm$ix[1:100]]
}
dictionary_terms<-c(unlist(unique(dataset.labels)),unlist(biological.replicates),"")
for (temp in dictionary_terms){
temp_list1 <- list()
temp_list2 <- list()
temp_list3 <- list()

#temp<-dictionary_terms[1]
if ((temp==dictionary_terms[1]|temp==dictionary_terms[2])&(length(mylist_qval[dataset.labels==temp])<=4 & length(mylist_qval[dataset.labels==temp])>=2)){
  temp_list1<-mylist_qval[dataset.labels==temp]
  temp_list2<-mylist_top50_LLR[dataset.labels==temp]
  temp_list3<-mylist_top100_LLR[dataset.labels==temp]
}else if((temp==dictionary_terms[3] | temp==dictionary_terms[4]) & (length(mylist_qval[dataset.labels==temp]) <=4 & length(mylist_qval[dataset.labels==temp])>=2)) {
  temp_list1<-mylist_qval[grepl(datasets, pattern=temp)]
  temp_list2<-mylist_top50_LLR[grepl(datasets, pattern=temp)]
  temp_list3<-mylist_top100_LLR[grepl(datasets, pattern=temp)]
}else if (temp=="" & ( length(mylist_qval)<=4 & length(mylist_qval)>2)){
  temp_list1<-mylist_qval
  temp_list2<-mylist_top50_LLR
  temp_list3<-mylist_top100_LLR
}
if (length(temp_list1)!=0){
  print(temp)
g <- ggVennDiagram(temp_list1)
g <- g + ggtitle(paste0("Spatially Differentially Expressed genes\n with 0 p-value in ",curr_datatypes, " ",temp)) 
g <- g + theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
g <- g + scale_x_continuous(expand = expansion(mult = .2))
png(paste0(plots_dir, "/", analysis_file_prefix, "venn_SpatialDE_pval_", temp,".png"),width = 480, height = 480)
print(g)
d <- dev.off()

g <- ggVennDiagram(temp_list2)
g <- g + ggtitle(paste0("Top 50 Spatially Differentially Expressed \ngenes  in ",curr_datatypes, " ",temp)) 
g <- g + theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
g <- g + scale_x_continuous(expand = expansion(mult = .2))
png(paste0(plots_dir, "/", analysis_file_prefix, "venn_SpatialDE_top50_", temp,".png"),width = 480, height = 480)
print(g)
d <- dev.off()

g <- ggVennDiagram(temp_list3)
g <- g + ggtitle(paste0("Top 100 Spatially Differentially Expressed \ngenes  in ",curr_datatypes, " ",temp)) 
g <- g + theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
g <- g + scale_x_continuous(expand = expansion(mult = .2))
png(paste0(plots_dir, "/", analysis_file_prefix, "venn_SpatialDE_top100_", temp,".png"),width = 480, height = 480)
print(g)
d <- dev.off()
}
}
#}
```





