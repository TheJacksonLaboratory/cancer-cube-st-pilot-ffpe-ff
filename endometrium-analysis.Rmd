---
title: "TNBC"
output: html_notebook
---



```{r}
# pacman is a "package manager" that defines the p_load function.
# p_load automatically installs a library if it is not already installed.
# This often, but doesn't always, works.
if(!require("pacman")) {
  install.packages("pacman")
}
suppressPackageStartupMessages(library(pacman)) 
suppressPackageStartupMessages(library(Seurat))
if(!require("spacexr")) {
  devtools::install_github("dmcable/spacexr", build_vignettes = FALSE)
  suppressPackageStartupMessages(p_load(spacexr))
}
#install.packages("hdf5r")
#suppressPackageStartupMessages(p_load(hdf5r))
# install.packages("hdf5r", configure.args="--with-hdf5=/home/whitebr/local/hdf5/bin/h5cc")
# install.packages("https://cran.r-project.org/src/contrib/hdf5r_1.3.8.tar.gz",repos=NULL,type="source", configure.args="--with-hdf5=/home/whitebr/local/hdf5/bin/h5cc")
#install.packages("https://cran.r-project.org/src/contrib/hdf5r_1.3.8.tar.gz",repos=NULL,type="source", configure.args="--with-hdf5=/home/whitebr/local/hdf5-1.14.0/bin/h5cc")
dyn.load("/home/whitebr/local/hdf5-1.14.0/lib/libhdf5_hl.so.310")
library(hdf5r)
suppressPackageStartupMessages(p_load(ggplot2))
suppressPackageStartupMessages(p_load(edgeR))
suppressPackageStartupMessages(p_load(patchwork))
suppressPackageStartupMessages(p_load(dplyr))
suppressPackageStartupMessages(p_load(plyr))
suppressPackageStartupMessages(p_load(cowplot))
# suppressPackageStartupMessages(p_load(scales))
suppressPackageStartupMessages(p_load(reshape2))
suppressPackageStartupMessages(p_load(ggbeeswarm))
# suppressPackageStartupMessages(library(devtools))
# install_github("jokergoo/ComplexHeatmap")
suppressPackageStartupMessages(p_load(ComplexHeatmap))
# devtools::install_github("sjmgarnier/viridisLite")
suppressPackageStartupMessages(library(viridisLite))
suppressPackageStartupMessages(p_load(dendextend))
# suppressPackageStartupMessages(p_load(CCA))
# suppressPackageStartupMessages(p_load("sRDA"))
suppressPackageStartupMessages(p_load(PMA))
suppressPackageStartupMessages(p_load(ggpubr))
suppressPackageStartupMessages(p_load(rstatix))
suppressPackageStartupMessages(p_load(gtools))
suppressPackageStartupMessages(p_load(DropletUtils)) # for downsampling count matrices
suppressPackageStartupMessages(p_load(foreach))
suppressPackageStartupMessages(p_load(parallel))
suppressPackageStartupMessages(p_load(scran)) # for deconvolution-based normalization
suppressPackageStartupMessages(p_load(scuttle)) # for deconvolution-based normalization
suppressPackageStartupMessages(p_load(rjson))
##if (!require(devtools)) install.packages("devtools")
##devtools::install_github("gaospecial/ggVennDiagram")
suppressPackageStartupMessages(p_load(ggVennDiagram))
suppressPackageStartupMessages(p_load(gridExtra))
suppressPackageStartupMessages(p_load(openxlsx))
suppressPackageStartupMessages(p_load(data.table))
suppressPackageStartupMessages(p_load(biomaRt))
suppressPackageStartupMessages(library("gplots"))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(p_load(harmony))

# suppressPackageStartupMessages(p_load(spots))
# install.packages("devtools")
# devtools::install_github("stevexniu/spots")
suppressPackageStartupMessages(library(spots))

suppressPackageStartupMessages(p_load(KRLS)) # for gausskernel
suppressPackageStartupMessages(p_load(devtools))

suppressPackageStartupMessages(p_load(rhdf5))
suppressPackageStartupMessages(p_load(Rsamtools))
if(TRUE) {
if(!require(OmnipathR)) {
  BiocManager::install('OmnipathR')
}
if(!require(decoupleR)) {
  # install.packages("BiocManager")
  # BiocManager::install("decoupleR")
  devtools::install_git("https://github.com/saezlab/decoupleR")
  # BiocManager::install("saezlab/decoupleR")
}
suppressPackageStartupMessages(p_load(decoupleR))
}
if(!require(dorothea)) {
  BiocManager::install("dorothea")
}
suppressPackageStartupMessages(p_load(dorothea))

suppressPackageStartupMessages(p_load(dplyr))
suppressPackageStartupMessages(p_load(tibble))
suppressPackageStartupMessages(p_load(tidyr))

if(!require(STdeconvolve)) {
  require(remotes)
  remotes::install_github('JEFworks-Lab/STdeconvolve')
}

#require(devtools)
# #install_version("rlang", version="1.0.5", repos = "http://cran.us.r-project.org")

# remotes::install_github("satijalab/sctransform", ref="develop")
# BiocManager::install("glmGamPoi")

suppressPackageStartupMessages(p_load(MAST))
suppressPackageStartupMessages(p_load(transformGamPoi))
# for ridge in misty
dyn.load('/home/whitebr/local/gsl-2.5/lib/libgsl.so.23')
```


Setup a parallel execution environment.

```{r}
num.cores <- detectCores()
if(!is.na(num.cores) && (num.cores > 1)) {
  suppressPackageStartupMessages(p_load("doMC"))
  # num.cores <- min(num.cores,6)
  cat(paste("Registering ", num.cores-1, " cores.\n", sep=""))
  registerDoMC(cores=(num.cores-1))
  options(mc.cores=num.cores-1)
}

```

```{r}
url <- "https://raw.githubusercontent.com/TheJacksonLaboratory/r_hne_image_utils/main/hovernet-utils.R"
source_url(url) # for extract.cell.info.from.hovernet.output, extract.hovernet.cell.info
url <- "https://raw.githubusercontent.com/TheJacksonLaboratory/cancer-cube-st-pilot-ffpe-ff/main/utils.R"
source(url)
url <- "https://raw.githubusercontent.com/TheJacksonLaboratory/cancer-cube-st-pilot-ffpe-ff/main/plotting-utils.R"
source(url)
```

```{r}
endo.init.file <- '/pod/2/activities/jaxcc/CATch-project/raw-data/visium/analysis_dir/Endometrium/Endometrium.csv'
peri.init.file <- '/pod/2/activities/jaxcc/CATch-project/raw-data/visium/analysis_dir/Peritoneum/peritoneum.csv'
endo.dataset.info <- read.table(endo.init.file, sep=",", header=TRUE)
peri.dataset.info <- read.table(peri.init.file, sep=",", header=TRUE)

# I don't know why the peri single_cell_Expr and single_cell_cell_types are NA. Fill them in
peri.dataset.info$single_cell_expr <- endo.dataset.info[1, "single_cell_expr"]
peri.dataset.info$single_cell_cell_types <- endo.dataset.info[1, "single_cell_cell_types"]

dataset.info <- rbind(endo.dataset.info, peri.dataset.info)

output_base_dir <- '/projects/compsci/jgeorge/whitebr/cancer-cube/endometrium/'
dir.create(output_base_dir, recursive=TRUE)

datasets <- dataset.info$names
spaceranger_dirs <- dataset.info$dataset_names

names(spaceranger_dirs) <- datasets
names(datasets) <- datasets

# Define and create output results and plots directories
# base_dir_antonis<-'/projects/compsci/USERS/somara/cancer-cude/qc-pilot/'
analysis_dir <- paste0(output_base_dir, '/analysis/')
dir.create(analysis_dir, showWarnings = FALSE, recursive = TRUE)
plots_dir <- paste0(output_base_dir, '/plots/')
dir.create(plots_dir, showWarnings = FALSE, recursive = TRUE)

# Prefix for all output files (results and plots)
analysis_file_prefix <- "endo-"

```

```{r}

names(datasets) <- datasets


# Extract the sample name from the datasets (i.e., foo_<sample>)
patient <- unlist(lapply(datasets, function(str) unlist(strsplit(str, split="-"))[2]))
short.sample <- unlist(lapply(datasets, function(str) unlist(strsplit(str, split="-"))[3]))
tissue <- unlist(lapply(datasets, function(str) unlist(strsplit(str, split="-"))[1]))

patient.df <- data.frame(sample = datasets, patient = patient, short.sample = short.sample, tissue = tissue)
rownames(patient.df) <- patient.df$sample

```


```{r}
p_load(moments)
p_load(qvalue)
tryCatch(source("https://raw.githubusercontent.com/saketkc/scRNA_NB_comparison/master/code/01_run_glm.R"),
         error = function(e) print(e))
```

```{r}
source("/home/whitebr/cancer-cube-st-pilot-ffpe-ff/misty-utils.R")
```




```{r}
# net <- get_collectri(organism='human', split_complexes=FALSE)
# net <- decoupleR::get_dorothea(levels=c("A"))
```


```{r}
# Read in the filtered and unfiltered matrices and append the tissue positions information to the metadata:
filtered.objs <- create.visium.seurat.objects(spaceranger_dirs, filter.spots = TRUE)
unfiltered.objs <- create.visium.seurat.objects(spaceranger_dirs, filter.spots = FALSE)
```

```{r}
num.filtered.cells <- llply(filtered.objs, .fun = function(obj) nrow(obj[[]]))
```


```{r}
#stop("stop")
```

```{r}
# Let's downsample and fit the EuE samples
indices <- 1:length(filtered.objs[grepl(names(filtered.objs), pattern="EuE")])
names(indices) <- names(filtered.objs)[grepl(names(filtered.objs), pattern="EuE")]
ds.size <- 1500
num.iters <- 5
ds.nb.fits <- 
  llply(indices, .parallel = FALSE,
        .fun = function(indx) { 
          
          ret <-
            llply(1:num.iters,
                  .fun = function(iter) {
                    set.seed(iter)
                    cat(paste0(names(filtered.objs)[indx], " iter: ", iter, "\n"))
                    orig.obj <- filtered.objs[[indx]]
                    ds.obj <- orig.obj[, sample(colnames(orig.obj), size = ds.size, replace=F)]
          
                    rds.file <- paste0(analysis_dir, "nb-fits-all-", names(filtered.objs)[indx], "-ds-", iter, ".rds")
                    if(!file.exists(rds.file)) {
                      fit <- suppressWarnings(GetFit(GetAssayData(ds.obj, assay="Spatial", slot="counts"), type="negbin"))
                      saveRDS(fit, file=rds.file)
                    }
                    fit <- readRDS(rds.file)
                    fit
                  })
          ret
        })
```


```{r}
indices <- 1:length(filtered.objs)
names(indices) <- names(filtered.objs)
nb.fits <- 
  llply(indices, .parallel = FALSE,
        .fun = function(indx) { 
          print(names(filtered.objs)[indx])
          rds.file <- paste0(analysis_dir, "nb-fits-all-", names(filtered.objs)[indx], ".rds")
          if(!file.exists(rds.file)) {
            fit <- suppressWarnings(GetFit(GetAssayData(filtered.objs[[indx]], assay="Spatial", slot="counts"), type="negbin"))
            saveRDS(fit, file=rds.file)
          }
          fit <- readRDS(rds.file)
          #fit$meanvarfit[, c("gene", "mean", "variance", "pval_ssrstd_quantile")]
          #print(table(fit$meanvarfit$pval_ssrstd_quantile < 0.05))
          #flag <- fit$meanvarfit$pval_ssrstd_quantile < 0.05
          #unfit.genes <- fit$meanvarfit[flag, "gene"]
          fit
        })
```
```{r}
nb.ordered.fit.tbls <-
  llply(nb.fits,
        .fun = function(fit) {
          tbl <- fit$meanvarfit
          tbl <- tbl[order(tbl$pval_ssrstd_quantile, decreasing=FALSE),]
          tbl
        })
```


```{r}
# Perform normalization of counts using SCTransform (which fits a negative binomial to the count data)
# This adds a new assay "SCT" to the returned Seurat object. That assay has slots "counts" (the corrected counts),
# "data" (log1p(counts)), and "scale.data" (the "pearson residuals").
# These would be accessible via GetAssayData(filtered.objs[[1]], slot = "data", assay = "SCT")
# Running with default parameters (the most interesting of which look to be variable.features.n and/or variable.features.rv.th)
filtered.objs <- apply.sctransform(filtered.objs)
# glimpse(obj@assays$SCT@SCTModel.list$model1)

#sct <- obj@assays$SCT@SCTModel.list$model1
#data <- GetAssayData(obj, assay="Spatial", slot="counts")
#sct.feats <- sct@feature.attributes
```

```{r}
cpms <-
  llply(filtered.objs,
        .fun = function(obj) {
          mat <- GetAssayData(obj, assay="Spatial", slot="counts")
          norm.mat <- edgeR::cpm(as.matrix(mat), log=FALSE)
          norm.mat
        })
```

```{r}
l.cpms <-
  llply(filtered.objs,
        .fun = function(obj) {
          mat <- GetAssayData(obj, assay="Spatial", slot="counts")
          norm.mat <- edgeR::cpm(as.matrix(mat), log=TRUE)
          norm.mat
        })
```


```{r}
# Read in Endometrium scRNA-seq data
read.endometrium.scrna.seq.data <- function(expr.file, cell.label.file) {
  counts_sc <- as.data.frame(fread(expr.file))
  rownames(counts_sc) <- counts_sc$index
  counts_sc <- t(counts_sc[,-1])
  
  # Note: using "main" cell types. These are a coarse set of cell types.
  cell_types <- read.csv(cell.label.file)
  cell_types[[2]] <- make.names(cell_types[[2]])
  cell_types <- setNames(cell_types[[2]], cell_types[[1]])
  cell_types <- as.factor(cell_types) # convert to factor data type
  
  return(list(counts=counts_sc, cell_labels=cell_types))
}
```


```{r}
load.sc.ref <- FALSE
rctd.prefix <- "-main"
# Force use of fine-grained results
#cell.label.file <- "/projects/compsci/jgeorge/USERS/somara/datasets/endometrium/endo-2022_global_celltypes.csv"
#rctd.prefix <- "-fine"
for(dataset in datasets) {
  rds.output.file <- paste0(output_base_dir, "/", dataset, rctd.prefix, "-no-intersect-rctd.rds")
  if(!file.exists(rds.output.file)) {
    load.sc.ref <- TRUE
  }
}
load.sc.ref <- TRUE
if(load.sc.ref) {
  
  # Confirm that all samples are using the sample single-cell dataset
  sc.counts.file <- dataset.info[1, "single_cell_expr"]
  cell.label.file <- dataset.info[1, "single_cell_cell_types"]
  #stopifnot(all(dataset.info$single_cell_expr == sc.counts.file))
  #stopifnot(all(dataset.info$single_cell_cell_types == cell.label.file))

  sc.res <- read.endometrium.scrna.seq.data(sc.counts.file, cell.label.file)
}
```

```{r}
cat("Fitting vst to scRNA-seq\n")
rds.file <- paste0(analysis_dir, "vst-", "scrnaseq", ".rds")
p_load(sctransform)
if(!file.exists(rds.file)) {
  umi <- as(sc.res$counts, "dgCMatrix")
  vst_out <- vst(umi = umi, vst.flavor = "v2", verbosity = 10, return_cell_attr = TRUE)
#  vst.flavor='v2' set, setting model to use fixed slope and exclude poisson genes.
  saveRDS(vst_out, file=rds.file)
#Calculating cell attributes from input UMI matrix: log_umi
#Total Step 1 genes: 19373
#Total overdispersed genes: 19325
#Excluding 48 genes from Step 1 because they are not overdispersed.
#Variance stabilizing transformation of count matrix of size 25708 by 108497
#Model formula is y ~ log_umi
#Get Negative Binomial regression parameters per gene
#Using 2000 genes, 2000 cells
#Setting estimate of  278 genes to inf as theta_mm/theta_mle < 1e-3
## of step1 poisson genes (variance < mean): 0
## of low mean genes (mean < 0.001): 4356
#Total # of Step1 poisson genes (theta=Inf; variance < mean): 285
#Total # of poisson genes (theta=Inf; variance < mean): 4529
#Calling offset model for all 4529 poisson genes
#Found 373 outliers - those will be ignored in fitting/regularization step

#Ignoring theta inf genes
#Replacing fit params for 4529 poisson genes by theta=Inf
#Setting min_variance based on median UMI:  0.04
#Second step: Get residuals using fitted parameters for 25708 genes
#Calculating gene attributes
#Wall clock passed: Time difference of 8.979065 mins
}
vst_out <- readRDS(rds.file)
```


```{r}
cat("Fitting nb to scRNA-seq\n")

rds.file <- paste0(analysis_dir, "nb-fits-all-", "scrnaseq", ".rds")
if(!file.exists(rds.file)) {
  sc.nb.fit <- suppressWarnings(GetFit(sc.res$counts, type="negbin"))
  saveRDS(sc.nb.fit, file=rds.file)
}
sc.nb.fit <- readRDS(rds.file)
 
```


```{r}
stop("stop")
```


```{r}
nms <- names(datasets)
names(nms) <- nms
rctds <-
  llply(nms, .parallel = FALSE,
        .fun = function(nm) {
          print(nm)
          rctd.wrapper(st.obj = filtered.objs[[nm]], sc.counts = sc.res$counts, sc.cell.types = sc.res$cell_labels, 
                       rds.output.file = paste0(output_base_dir, "/", nm, rctd.prefix, "-no-intersect-rctd.rds"), 
                       intersect.sc.and.st.genes = FALSE)
        })
```

```{r}
# Add RCTD metadata to the Seurat objects
filtered.objs <-
  llply(datasets, .parallel = FALSE,
        .fun = function(nm) {
          print(nm)
          md.df <- format.rctd.output_(rctds[[nm]])
          obj <- add.metadata.to.seurat.obj(filtered.objs[[nm]], md.df)
          obj
        })
```

```{r}
# MISTy analysis
p_load(mistyR)
p_load(future)

# data manipulation
p_load(dplyr)
p_load(purrr)
p_load(distances)


plan(multisession)
p_load(tidyverse)
setwd("/home/whitebr/local/gsl-2.5/lib/")

```

```{r}
net <- get_progeny(organism = 'human', top = 100)

common.genes <- Reduce(intersect, lapply(filtered.objs, function(obj) rownames(obj)))

net.sub <- subset(net, target %in% common.genes)

# Get ligands from omnipath
icn <- import_intercell_network()
icn.ligand <- subset(icn, category_intercell_source == "ligand")
# Find the highest confident 100 ligands 
hc.ligands <-
  ddply(as.data.frame(icn.ligand[, c("source_genesymbol", "consensus_score_intercell_source")]),
        .variables = c("source_genesymbol"),
        .fun = function(df) {
          data.frame(score = max(df$consensus_score_intercell_source))
        })
hc.ligands <- hc.ligands[order(hc.ligands$score, decreasing=TRUE),]
colnames(hc.ligands) <- c("gene", "score")
hc.ligands <- subset(hc.ligands, gene %in% common.genes)

net.sub.no.ligands <- subset(net.sub, !(target %in% hc.ligands$gene))

avg.max.lig.expr <- 
  ldply(filtered.objs,
        .fun = function(obj) {
          vec <- apply(GetAssayData(obj, assay="Spatial", slot="counts"),1,max)[hc.ligands$gene]
        })
colnames(avg.max.lig.expr)[1] <- "sample"
rownames(avg.max.lig.expr) <- avg.max.lig.expr$sample
avg.max.lig.expr <- avg.max.lig.expr[, !(colnames(avg.max.lig.expr) %in% c("sample"))]
sms <- colSums(avg.max.lig.expr)
sms <- sms[order(sms, decreasing=TRUE)]
top.ligands <- unique(c("MFGE8", names(sms)[1:35]))
```

```{r}
all.sample.acts <-
  llply(l.cpms,
        .fun = function(expr) {
          sample_acts <- run_wmean(mat=expr, net=net.sub.no.ligands, .source='source', .target='target',
                  .mor='weight', times = 2, minsize = 5)
        })
```


```{r}
stop("misty")
```


```{r}

sample.name <- names(filtered.objs)[1]
for(sample.name in names(filtered.objs)) {
  print(sample.name)

  rctd.df <- format.rctd.output_(rctds[[sample.name]])
  rctd.df <- rctd.df[, !(colnames(rctd.df) %in% c("x","y"))]
  
  sample_acts <- subset(all.sample.acts[[sample.name]], statistic == "wmean")[, c("source", "condition", "score")]
  act.mat <- dcast(sample_acts, condition ~ source)
  rownames(act.mat) <- act.mat$condition
  act.mat <- act.mat[, !(colnames(act.mat) %in% c("condition"))]
  colnames(act.mat) <- make.names(colnames(act.mat))

  expr <- l.cpms[[sample.name]]
  
  obj <- filtered.objs[[sample.name]]
  common.spots <- intersect(rownames(act.mat), colnames(expr))
  act.mat <- act.mat[common.spots,]
  rctd.df <- rctd.df[common.spots,]
  obj <- obj[, common.spots]
  expr <- expr[, common.spots]
  
  exclude <- apply(rctd.df, 1, function(row) any(is.na(row)))
  
  act.mat <- act.mat[!exclude,]
  rctd.df <- rctd.df[!exclude,]
  expr <- expr[, !exclude]
  obj <- obj[, !exclude]
  
  pos <- obj[[]][,c("row","col")]

  obj <- add.metadata.to.seurat.obj(obj, act.mat)

  #tmp <- rbind(expr[rownames(expr) %in% top.ligands,], t(rctd.df))
  tmp <- expr[rownames(expr) %in% top.ligands,]
  ligand.expr <- tmp %>% t() %>% as_tibble(rownames = NA)
  act.expr <- act.mat %>% as_tibble(rownames = NA)

  misty.views <- create_initial_view(act.expr)
  
  # paraview for pathways
  misty.views <- misty.views %>% add_paraview(pos, l = 9, zoi = 1)
  names(misty.views)[length(misty.views)] <- "paraview.path_9"
  misty.views[[length(misty.views)]]$abbrev <- "para.path_9"
  
  # paraview for ligands (and cell types)
  # misty.views <- misty.views %>% add_views(create_view("paraview.lig_9", ligand.expr, "para.lig_9"))
  dummy.views <- create_initial_view(ligand.expr)
  dummy.views <- dummy.views %>% add_paraview(pos, l = 9, zoi = 0)
  data.red <- dummy.views[["paraview.9"]]$data
  misty.views <- misty.views %>% add_views(create_view("paraview.lig_9", data.red, "para.lig_9"))
  
  #dummy.views <- create_initial_view(cell.type.freq)
  #dummy.views <- dummy.views %>% add_paraview(pos, l = 9, zoi = 0)
  #data.red <- dummy.views[["paraview.9"]]$data
  #misty.views <- misty.views %>% add_views(create_view("paraview.ct_9", data.red, "para.ct_9"))

  res <- run_misty(misty.views, results.folder = paste0(analysis_dir, "misty-path-lig-indep-", sample.name))
#%>% collect_results()
}
```


```{r}
ffpe.sample <- "EuE-31-235"
ff.sample <- "EuE-31-165"

#ffpe.sample <- "EuE-31-236"
#ff.sample <- "EuE-31-164"
```

```{r}
ffpe.obj <- filtered.objs[[ffpe.sample]]
ff.obj <- filtered.objs[[ff.sample]]

ffpe.sct <- ffpe.obj@assays$SCT@SCTModel.list$model1
ffpe.data <- GetAssayData(ffpe.obj, assay="Spatial", slot="counts")
ffpe.sct.feats <- ffpe.sct@feature.attributes

ff.sct <- ff.obj@assays$SCT@SCTModel.list$model1
ff.data <- GetAssayData(ff.obj, assay="Spatial", slot="counts")
ff.sct.feats <- ff.sct@feature.attributes

genes <- rownames(ffpe.data)
names(genes) <- genes
ffpe.cs <- colSums(ffpe.data)
cs.cors <- llply(genes[1:10], .fun = function(gene) cor(ffpe.data[gene,], ffpe.cs))
cs.cors <- cs.cors[order(cs.cors, decreasing=TRUE),]

cs.cors <- cor(t(as.matrix(ff.data)),colSums(ff.data))
cs.cors <- cs.cors[order(cs.cors[,1], decreasing=TRUE),]

# plot(log10(sct.feats$gmean), sct.feats[, "step1_(Intercept)"])
plot(log10(ff.sct.feats$gmean), log10(ff.sct.feats$variance))
plot(log10(ffpe.sct.feats$gmean), ffpe.sct.feats$residual_variance)

hist(colSums(ffpe.data))
hist(colSums(ff.data))
 
plot(density(log10(ffpe.sct.feats$gmean)))
lines(density(log10(ff.sct.feats$gmean)))
```


```{r}
res <- collect_results(paste0(analysis_dir, "misty-cell-path-lig-indep-", ff.sample))
```
```{r}
res %>% plot_improvement_stats("gain.R2")
res %>% plot_view_contributions()
res %>% plot_interaction_heatmap(view = "intra")
res %>% plot_interaction_heatmap(view = "para.lig_9")
res %>% plot_interaction_heatmap(view = "para.path_9")
res$importances.aggregated %>%  filter(view == "para.lig_9", Target == "Hypoxia") %>% arrange(-Importance)
```

```{r}
my_correct_counts_for_gene <-
function (x, umi, gene, cell_attr = x$cell_attr, scale_factor = NA, 
    verbosity = 2, verbose = NULL, show_progress = NULL) 
{
    if (!is.null(verbose)) {
        warning("The 'verbose' argument is deprecated as of v0.3. Use 'verbosity' instead. (in sctransform::vst)", 
            immediate. = TRUE, call. = FALSE)
        verbosity <- as.numeric(verbose)
    }
    if (!is.null(show_progress)) {
        warning("The 'show_progress' argument is deprecated as of v0.3. Use 'verbosity' instead. (in sctransform::vst)", 
            immediate. = TRUE, call. = FALSE)
        if (show_progress) {
            verbosity <- 2
        }
        else {
            verbosity <- min(verbosity, 1)
        }
    }
    regressor_data_orig <- model.matrix(as.formula(gsub("^y", 
        "", x$model_str)), cell_attr)
    cell_attr[, x$arguments$latent_var] <- apply(cell_attr[, 
        x$arguments$latent_var, drop = FALSE], 2, function(x) rep(median(x), 
        length(x)))
    if (!is.na(scale_factor) && !is.numeric(scale_factor)) {
        stop("`scale_factor` should be numeric")
    }
    if (!is.na(scale_factor)) {
        if (verbosity > 0) {
            message(paste("Setting log_umi for correcting counts to", 
                scale_factor))
        }
        cell_attr[, "log_umi"] <- log10(scale_factor)
    }
    regressor_data <- model.matrix(as.formula(gsub("^y", "", 
        x$model_str)), cell_attr)
    genes <- rownames(umi)[rownames(umi) %in% rownames(x$model_pars_fit)]
    bin_size <- x$arguments$bin_size
    bin_ind <- ceiling(x = 1:length(x = genes)/bin_size)
    max_bin <- max(bin_ind)
    if (verbosity > 0) {
        message("Computing corrected UMI count matrix")
    }
    if (verbosity > 1) {
        pb <- txtProgressBar(min = 0, max = max_bin, style = 3)
    }
    corrected_data <- list()
    i <- bin_ind[which(genes==gene)]
#    for (i in 1:max_bin) {
        genes_bin <- genes[bin_ind == i]
        coefs <- x$model_pars_fit[genes_bin, -1, drop = FALSE]
        theta <- x$model_pars_fit[genes_bin, 1]
        mu_0 <- exp(tcrossprod(coefs, regressor_data_orig))
        variance_0 <- mu_0 + mu_0^2/theta
        y <- as.matrix(umi[genes_bin, , drop = FALSE])
        pearson_residual <- (y - mu_0)/sqrt(variance_0)
        mu <- exp(tcrossprod(coefs, regressor_data))
        variance <- mu + mu^2/theta
        y.res <- mu + pearson_residual * sqrt(variance)
#        y.res <- round(y.res, 0)
#        y.res[y.res < 0] <- 0
#        corrected_data[[length(corrected_data) + 1]] <- make.sparse(mat = y.res)
        if (verbosity > 1) {
            setTxtProgressBar(pb, i)
        }
        return(list(coefs = coefs, theta = theta, mu_0 = mu_0, variance_0 = variance_0, y = y, pearson_residual = pearson_residual, mu = mu, variance = variance, y.res = y.res, regressor_data_orig = regressor_data_orig, regressor_data = regressor_data))
 #   }
    if (verbosity > 1) {
        close(pb)
    }
        
    corrected_data <- do.call(what = rbind, args = corrected_data)
    return(corrected_data)
}
```

```{r}
my_hist <- function(x, xlims = c(0,30), ...) {
  x <- x[x >= xlims[1]]
  x <- x[x <= xlims[2]]
  hist(x, ...)
}
```

```{r}
compare_vsts <- function(vst1, vst1.name, vst2, vst2.name, gene) {
  vars <- c("coefs", "theta", "mu_0", "variance_0", "pearson_residual", "mu", "variance")
  for(var in vars) {
    cat(paste0(var, "\n"))
    cat(paste0(vst1.name, "\n"))
    if(is.null(dim(vst1[[var]]))) {
      print(vst1[[var]][gene])
    } else {
      print(head(vst1[[var]][gene,]))
    }
    cat(paste0(vst2.name, "\n"))
    if(is.null(dim(vst2[[var]]))) {
      print(vst2[[var]][gene])
    } else {
      print(head(vst2[[var]][gene,]))
    }
    cat("\n")
  }
}
```


```{r}
gene <- "ACTB"
gene <- "EPCAM"
for(gene in c("EPCAM", "COL1A1")) {

  common.genes <- intersect(rownames(GetAssayData(filtered.objs[[ff.sample]], assay="SCT", slot="counts")),
                            rownames(GetAssayData(filtered.objs[[ffpe.sample]], assay="SCT", slot="counts")))
  

  ff.obj <- filtered.objs[[ff.sample]]
  ff.vst.orig <- vst(GetAssayData(object = ff.obj, slot = "counts", assay = "Spatial"), vst.flavor = "v2", verbosity = 10, return_cell_attr = TRUE)
  ff.obj.subset <- ff.obj[common.genes,]
  ff.vst.subset <- vst(GetAssayData(object = ff.obj.subset, slot = "counts", assay = "Spatial"), vst.flavor = "v2", verbosity = 10, return_cell_attr = TRUE)


  
  ffpe.obj <- filtered.objs[[ffpe.sample]]
  ffpe.obj <- ffpe.obj[common.genes,]
  ffpe.vst <- vst(GetAssayData(object = ffpe.obj, slot = "counts", assay = "Spatial"), vst.flavor = "v2", verbosity = 10, return_cell_attr = TRUE)

  ff.obj.subset.same.ncells <- ff.obj[common.genes,1:length(Cells(ffpe.obj))]
  ff.vst.subset.same.ncells <- vst(GetAssayData(object = ff.obj.subset.same.ncells, slot = "counts", assay = "Spatial"), vst.flavor = "v2", verbosity = 10, return_cell_attr = TRUE)
  
  m <- merge(ff.vst.subset$model_pars_fit, ffpe.vst$model_pars_fit, by = "row.names")
  # Intercepts are very similar
  plot(m[, "(Intercept).x"], m[, "(Intercept).y"])
  # Thetas are not
  plot(m$theta.x, m$theta.y)
  
  ff.cc <- correct_counts(ff.vst.orig, GetAssayData(ff.obj, assay="Spatial", slot="counts"),verbosity=20)
  ff.cc.subset <- correct_counts(ff.vst.subset, GetAssayData(ff.obj.subset, assay="Spatial", slot="counts"),verbosity=20)
  ffpe.cc <- correct_counts(ffpe.vst, GetAssayData(ffpe.obj, assay="Spatial", slot="counts"),verbosity=20)

  # WORKING
  # Observation: EPCAM has zero raw counts in FFPE, but few / no zero SCT-transformed counts in FFPE
  # Why?
  # Confirm for x_c = 0, y_c > 0 if n0 > nc
  
  # Other observations:
  # 1. Tot counts are normal in FF, but skewed in FFPE
  # 2. mu_0 is exactly proportional to total counts. This is following Lause.
  # 3. pearson residuals distibutions look very different
  # 4. Given how simple the fit is, I'm not sure it makes sense to switch out the counts and cell_attrs as I do below.
  # 5. mu_0 > 0 because mu_0 = nc * e^beta_0 and both nc and e^beta_0 are > 0
  # 6. Very strong correlation in ffpe of gene UMI with total counts (at least for epcam), less true for ff
  
  # WORKING: when we use the same umis and the same cell_attrs, but use different fits,
  # the results look very similar (ie hist(y.res.ff))
  # Confirm this.
  # What can we change to break this? umis? cell_attr? scale_factor?
  # In the other direction, confirm that using the same fits, but different counts,
  # the results look very different.
  ff.cell_attr <- ff.vst.subset.same.ncells$cell_attr
  ff.umi.all <- GetAssayData(ff.obj, assay="Spatial", slot="counts")

  ff.umi <- GetAssayData(ff.obj.subset.same.ncells, assay="Spatial", slot="counts")
  ff.scale_factor <- median(10^ff.cell_attr$log_umi)
  ret.ff <- my_correct_counts_for_gene(ff.vst.subset.same.ncells, ff.umi, gene, cell_attr = ff.cell_attr, scale_factor = ff.scale_factor, verbosity = 0)
  # fit in ret.ff$coefs[gene,] and ret.ff$theta[gene] or x$model_pars_fit[gene,]
  
  # Substituting ffpe cell_attr, umis, and scale_factor (with ff fits)
  ffpe.cell_attr <- ffpe.vst$cell_attr
  ffpe.umi <- GetAssayData(ffpe.obj, assay="Spatial", slot="counts")
  ffpe.scale_factor <- median(10^ffpe.cell_attr$log_umi)

  ret.ffpe <- my_correct_counts_for_gene(ffpe.vst, ffpe.umi, gene, cell_attr = ffpe.cell_attr, scale_factor = ffpe.scale_factor, verbosity = 0)


  # Substituting ffpe properties into ff
  ######################################
    
  # Substituting ffpe cell_attr (with ff fits)
  ret.ff.with.ffpe.attr <- my_correct_counts_for_gene(ff.vst.subset.same.ncells, ff.umi, gene, cell_attr = ffpe.cell_attr, scale_factor = ff.scale_factor, verbosity = 0)
  
  # Substituting ffpe cell_attr and umis (with ff fits)
  ret.ff.with.ffpe.attr.umis <- my_correct_counts_for_gene(ff.vst.subset.same.ncells, ffpe.umi, gene, cell_attr = ffpe.cell_attr, scale_factor = ff.scale_factor, verbosity = 0)

  # Substituting ffpe cell_attr and scale_factor (with ff fits)
  ret.ff.with.ffpe.attr.sf <- my_correct_counts_for_gene(ff.vst.subset.same.ncells, ff.umi, gene, cell_attr = ffpe.cell_attr, scale_factor = ffpe.scale_factor, verbosity = 0)

  # Substituting ffpe umis (with ff fits)
  ret.ff.with.ffpe.umis <- my_correct_counts_for_gene(ff.vst.subset.same.ncells, ffpe.umi, gene, cell_attr = ff.cell_attr, scale_factor = ff.scale_factor, verbosity = 0)

  # Substituting ffpe umis and sf (with ff fits)
  ret.ff.with.ffpe.umis.sf <- my_correct_counts_for_gene(ff.vst.subset.same.ncells, ffpe.umi, gene, cell_attr = ff.cell_attr, scale_factor = ffpe.scale_factor, verbosity = 0)

  # Substituting ffpe scale factor (with ff fits)
  ret.ff.with.ffpe.sf <- my_correct_counts_for_gene(ff.vst.subset.same.ncells, ff.umi, gene, cell_attr = ff.cell_attr, scale_factor = ffpe.scale_factor, verbosity = 0)

  ret.ff.with.ffpe.umis.attr.sf <- my_correct_counts_for_gene(ff.vst.subset.same.ncells, ffpe.umi, gene, cell_attr = ffpe.cell_attr, scale_factor = ffpe.scale_factor, verbosity = 0)

  # Substituting ff properties into ffpe
  ######################################
  
  # ret.ffpe <- my_correct_counts_for_gene(ffpe.vst, ffpe.umi, gene, cell_attr = ffpe.cell_attr, scale_factor = ffpe.scale_factor, verbosity = 0)

  # Substituting ff cell_attr (with ffpe fits)
  ret.ffpe.with.ff.attr <- my_correct_counts_for_gene(ffpe.vst, ffpe.umi, gene, cell_attr = ff.cell_attr, scale_factor = ffpe.scale_factor, verbosity = 0)
  
  # Substituting ff cell_attr and umis (with ffpe fits)
  ret.ffpe.with.ff.attr.umis <- my_correct_counts_for_gene(ffpe.vst, ff.umi, gene, cell_attr = ff.cell_attr, scale_factor = ffpe.scale_factor, verbosity = 0)

  # Substituting ff cell_attr and scale_factor (with ffpe fits)
  ret.ffpe.with.ff.attr.sf <- my_correct_counts_for_gene(ffpe.vst, ffpe.umi, gene, cell_attr = ff.cell_attr, scale_factor = ff.scale_factor, verbosity = 0)

  # Substituting ff umis (with ffpe fits)
  ret.ffpe.with.ff.umis <- my_correct_counts_for_gene(ffpe.vst, ff.umi, gene, cell_attr = ffpe.cell_attr, scale_factor = ffpe.scale_factor, verbosity = 0)

  # Substituting ff umis and sf (with ffpe fits)
  ret.ffpe.with.ff.umis.sf <- my_correct_counts_for_gene(ffpe.vst, ff.umi, gene, cell_attr = ffpe.cell_attr, scale_factor = ff.scale_factor, verbosity = 0)

  # Substituting ff scale factor (with ffpe fits)
  ret.ffpe.with.ff.sf <- my_correct_counts_for_gene(ffpe.vst, ffpe.umi, gene, cell_attr = ffpe.cell_attr, scale_factor = ff.scale_factor, verbosity = 0)

  ret.ffpe.with.ff.umis.attr.sf <- my_correct_counts_for_gene(ffpe.vst, ff.umi, gene, cell_attr = ff.cell_attr, scale_factor = ff.scale_factor, verbosity = 0)

  
  ffpe.zero.flag <- ret.ffpe$y.res[gene,] <= 0

    
  # mu0 vs counts look very different for the two
  par(mfrow=c(1,2)) 
  plot(ff.umi[gene,], ret.ff$mu_0[gene,])
  abline(a=0,b=1)
  plot(ffpe.umi[gene,], ret.ffpe$mu_0[gene,])
  abline(a=0,b=1)
  text(ffpe.umi[gene,ffpe.zero.flag], ret.ffpe$mu_0[gene,ffpe.zero.flag], labels="X")

  # mu0 vs counts look very different for the two
  par(mfrow=c(1,2)) 
  plot(ff.umi[gene,], ret.ff$mu_0[gene,], xlim=c(0,10))
  abline(a=0,b=1)
  plot(ffpe.umi[gene,], ret.ffpe$mu_0[gene,], xlim=c(0,10))
  abline(a=0,b=1)
  text(ffpe.umi[gene,ffpe.zero.flag], ret.ffpe$mu_0[gene,ffpe.zero.flag], labels="X")
  
  
  par(mfrow=c(1,2)) 
  plot(ff.umi[gene,], ff.umi[gene,] - ret.ff$mu_0[gene,], xlim = c(0,10))
  plot(ffpe.umi[gene,], ffpe.umi[gene,] - ret.ffpe$mu_0[gene,], xlim = c(0,10))
  text(ffpe.umi[gene,ffpe.zero.flag], ffpe.umi[gene,ffpe.zero.flag] - ret.ffpe$mu_0[gene,ffpe.zero.flag], labels="X")

  par(mfrow=c(1,2)) 
  plot(ff.umi[gene,], ret.ff$pearson_residual[gene,], xlim = c(0,10))
  plot(ffpe.umi[gene,], ret.ffpe$pearson_residual[gene,], xlim = c(0,10))
  text(ffpe.umi[gene,ffpe.zero.flag], ret.ffpe$pearson_residual[gene,ffpe.zero.flag], labels="X")

  par(mfrow=c(1,2)) 
  plot(ff.umi[gene,], sqrt(ret.ff$variance_0[gene,]), xlim = c(0,10))
  plot(ffpe.umi[gene,], sqrt(ret.ffpe$variance_0[gene,]), xlim = c(0,10))
  text(ffpe.umi[gene,ffpe.zero.flag], sqrt(ret.ffpe$variance_0[gene,ffpe.zero.flag]), labels="X")
  

  par(mfrow=c(1,2)) 
  # Original ff results look skewed
  my_hist(ret.ff$y.res[gene,], xlims = c(-Inf,30), main = "FF orig")
  # ff fit with ffpe umis and cell attr looks normal
  my_hist(ret.ffpe$y.res[gene,], xlims = c(0,30), main = "FFPE orig")

  # Theta for ffpe is _much_ bigger:
  print(c(ret.ffpe$theta[gene], ret.ff$theta[gene]))
  # Should imply variances are smaller (but also a function of mu)
  
  # Variance of FFPE is right-skewed, because mu_0 is right-skewed, because tot counts are right skewed
  par(mfrow=c(1,2)) 
  my_hist(ret.ff$variance_0[gene,], xlims = c(-Inf,30), main = "FF orig")
  my_hist(ret.ffpe$variance_0[gene,], xlims = c(0,30), main = "FFPE orig")

  par(mfrow=c(1,2))
  hist(ret.ff$pearson_residual[gene,])
  hist(ret.ffpe$pearson_residual[gene,])
  
  par(mfrow=c(1,2))
  plot(sqrt(ret.ff$variance_0[gene,]), sqrt(ret.ff$mu_0[gene,]))
  abline(a=0,b=1)
  plot(sqrt(ret.ffpe$variance_0[gene,]), sqrt(ret.ffpe$mu_0[gene,]))
  abline(a=0,b=1)
  
  # Pearson residual and pearson * sqrt(variance) are skeweed in ff
  par(mfrow=c(1,2))
  hist((ret.ff$pearson_residual[gene,] * sqrt(ret.ff$variance[gene,])))
  hist((ret.ffpe$pearson_residual[gene,] * sqrt(ret.ffpe$variance[gene,])))

  par(mfrow=c(1,2))
  hist((ret.ff$pearson_residual[gene,] * sqrt(ret.ff$variance[gene,])) + ret.ff$mu[gene,])
  hist((ret.ffpe$pearson_residual[gene,] * sqrt(ret.ffpe$variance[gene,])) + ret.ffpe$mu[gene,])
  
  par(mfrow=c(1,2))
  plot(colSums(ff.umi), ret.ff$pearson_residual[gene,])
  plot(colSums(ffpe.umi), ret.ffpe$pearson_residual[gene,])
  
  # mu and variance are the same for all cells (for all genes), though the values differ by gene.
  # This is again a consequence of Lause, with a fixed umi count n0
  par(mfrow=c(1,2)) 
  hist(ret.ff$variance[gene,], main = "FF orig")
  hist(ret.ffpe$variance[gene,], main = "FFPE orig")

  par(mfrow=c(1,2)) 
  hist(ret.ff$mu[gene,], main = "FF orig")
  hist(ret.ffpe$mu[gene,], main = "FFPE orig")

      
  par(mfrow=c(1,2)) 
  my_hist(ret.ff$mu_0[gene,], xlims = c(-Inf,30), main = "FF orig")
  my_hist(ret.ffpe$mu_0[gene,], xlims = c(0,30), main = "FFPE orig")

  par(mfrow=c(1,2)) 
  hist((colSums(ff.umi)))
  hist((colSums(ffpe.umi)))

  par(mfrow=c(1,2)) 
  hist(ret.ff$variance[gene,], main = "FF orig")
  hist(ret.ffpe$variance[gene,], main = "FFPE orig")

  
  # Plot ff with ffpe subs
  par(mfrow=c(3,3)) 
  # Original ff results look skewed
  my_hist(ret.ff$y.res[gene,], xlims = c(-Inf,30), main = "FF orig")
  # ff fit with ffpe umis and cell attr looks normal
  my_hist(ret.ff.with.ffpe.umis.attr.sf$y.res[gene,], xlims = c(0,30), main = "FF sub umis, attr, sf")

  my_hist(ret.ff.with.ffpe.umis$y.res[gene,], xlims = c(-Inf,30), main = "FF sub umis")
  my_hist(ret.ff.with.ffpe.attr$y.res[gene,], xlims = c(-Inf,30), main = "FF sub attr")
  my_hist(ret.ff.with.ffpe.sf$y.res[gene,], xlims = c(-Inf,30), main = "FF sub sf")

  my_hist(ret.ff.with.ffpe.attr.umis$y.res[gene,], xlims = c(-Inf,30), main = "FF sub umis, attr")
  my_hist(ret.ff.with.ffpe.attr.sf$y.res[gene,], xlims = c(-Inf,30), main = "FF sub attr, sf")
  my_hist(ret.ff.with.ffpe.umis.sf$y.res[gene,], xlims = c(-Inf,30), main = "FF sub umis, sf")

  # Plot ffpe with ff subs  
  par(mfrow=c(3,3)) 
  my_hist(ret.ffpe$y.res[gene,], xlims = c(-Inf,30), main = "FFPE orig")
  my_hist(ret.ffpe.with.ff.umis.attr.sf$y.res[gene,], xlims = c(0,30), main = "FFPE sub umis, attr, sf")

  my_hist(ret.ffpe.with.ff.umis$y.res[gene,], xlims = c(-Inf,30), main = "FFPE sub umis")
  my_hist(ret.ffpe.with.ff.attr$y.res[gene,], xlims = c(-Inf,30), main = "FFPE sub attr")
  my_hist(ret.ffpe.with.ff.sf$y.res[gene,], xlims = c(-Inf,30), main = "FFPE sub sf")

  my_hist(ret.ffpe.with.ff.attr.umis$y.res[gene,], xlims = c(-Inf,30), main = "FFPE sub umis, attr")
  my_hist(ret.ffpe.with.ff.attr.sf$y.res[gene,], xlims = c(-Inf,30), main = "FFPE sub attr, sf")
  my_hist(ret.ffpe.with.ff.umis.sf$y.res[gene,], xlims = c(-Inf,30), main = "FFPE sub umis, sf")

  
  
  compare_vsts(ret.ff, "ff", ret.ff.with.ffpe.attr.umis, "ff.with.ffpe.attr.umis", gene)

  par(mfrow=c(1,2))
  hist(ret.ff$pearson_residual[gene,])
  hist(ret.ff.with.ffpe.umis.cell_attrs$pearson_residual[gene,])
  
  # Plot UMIs for gene vs colsums
  par(mfrow=c(1,2))
  plot(ff.umi[gene,], colSums(ff.umi))
  plot(ffpe.umi[gene,], colSums(ffpe.umi))

  g <- ggplot_smooth_scatter(data.frame(x=ff.umi[gene,], y=colSums(ff.umi)), aes(x=x,y=y))
  
  # Plot UMIs for gene vs colsums (limit x axis)
  par(mfrow=c(1,2))
  plot(ff.umi[gene,], colSums(ff.umi), xlim=c(0,30))
  plot(ffpe.umi[gene,], colSums(ffpe.umi), xlim=c(0,30))
  
  
  par(mfrow=c(1,2))
  plot(colSums(ff.umi), ff.umi[gene,])
  plot(colSums(ffpe.umi), ffpe.umi[gene,])

    
  par(mfrow=c(1,2))
  plot(log10(colSums(ff.umi)), ff.umi[gene,])
  plot(log10(colSums(ffpe.umi)), ffpe.umi[gene,])
  par(mfrow=c(1,2))
  hist(colSums(ffpe.umi))
  hist(colSums(ff.umi))

  par(mfrow=c(1,2))
  my_hist(log(ret.ff.with.ffpe.attr.umis$mu_0[gene,]))
  my_hist(log(ret.ff$mu_0[gene,]))

  
  par(mfrow=c(1,2))
  plot(colSums(ret.ff.with.ffpe.attr.umis$y), log(ret.ff.with.ffpe.attr.umis$mu_0[gene,]))
  plot(colSums(ret.ff$y), log(ret.ff$mu_0[gene,]))

  par(mfrow=c(1,2))
  y.min.1 <- min(log(ret.ff.with.ffpe.attr.umis$mu_0[gene,]))
  y.min.2 <- min(log(ret.ff$mu_0[gene,]))
  y.max <- max(log(ret.ff$mu_0[gene,]))
  plot(colSums(ret.ff.with.ffpe.attr.umis$y), log(ret.ff.with.ffpe.attr.umis$mu_0[gene,]), ylim=c(y.min.1, y.max), xlim=c(0,1000))
  plot(colSums(ret.ff$y), log(ret.ff$mu_0[gene,]), ylim=c(y.min.2, y.max), xlim=c(0,1000))

  
    
  ret <- my_correct_counts_for_gene(x, umi, gene, cell_attr = x$cell_attr, scale_factor = NA)
  par(mfrow=c(1,2)) 
  hd <- hist(y.res.ff[gene,] - min(y.res.ff[gene,]))
  hd <- hist(y.res.ffpe[gene,] - min(y.res.ffpe[gene,]), breaks=hd$breaks)
    
  x <- ffpe.vst
  umi <- GetAssayData(ffpe.obj, assay="Spatial", slot="counts")
  cell_attr <- x$cell_attr
  scale_factor <- median(10^ffpe.vst$cell_attr$log_umi)
  
  #regressor_data_orig[,2] <- regressor_data_orig.ff[1:nrow(regressor_data_orig),2] 
    genes_bin <- genes[bin_ind == i]
    coefs.ffpe <- x$model_pars_fit[genes_bin, -1, drop=FALSE]
    theta.ffpe <- x$model_pars_fit[genes_bin, 1]
    # get pearson residuals
    mu.ffpe.0 <- exp(tcrossprod(coefs.ffpe, regressor_data_orig))
    variance.ffpe.0 <- mu.ffpe.0 + mu.ffpe.0^2 / theta.ffpe
    y.ffpe <- as.matrix(umi[genes_bin, , drop=FALSE])
    pearson_residual.ffpe <- (y.ffpe - mu.ffpe.0) / sqrt(variance.ffpe.0)
    # generate output
    mu.ffpe <- exp(tcrossprod(coefs.ffpe, regressor_data))
    variance.ffpe <- mu.ffpe + mu.ffpe^2 / theta.ffpe
    y.res.ffpe <- mu.ffpe + pearson_residual.ffpe * sqrt(variance.ffpe)

  

  tmp <- ff.vst.subset.same.ncells
  tmp$model_pars_fit[gene,"(Intercept)"] <- ffpe.vst$model_pars_fit[gene,"(Intercept)"]
  tmp$model_pars_fit[gene,"theta"] <- ffpe.vst$model_pars_fit[gene,"theta"]
  x <- tmp
  umi <- GetAssayData(ff.obj.subset.same.ncells, assay="Spatial", slot="counts")
  cell_attr <- x$cell_attr
  scale_factor <- median(10^ffpe.vst$cell_attr$log_umi)
  
  # Try the same data (counts), but switch the params
  # Switch the data (including counts!?), but keep the same params (here, check mm.0 distributions)
  
      genes_bin <- genes[bin_ind == i]
    coefs.ff <- x$model_pars_fit[genes_bin, -1, drop=FALSE]
    theta.ff <- x$model_pars_fit[genes_bin, 1]
    # get pearson residuals
    mu.ff.0 <- exp(tcrossprod(coefs.ff, regressor_data_orig))
    variance.ff.0 <- mu.ff.0 + mu.ff.0^2 / theta.ff
    y.ff <- as.matrix(umi[genes_bin, , drop=FALSE])
    pearson_residual.ff <- (y.ff - mu.ff.0) / sqrt(variance.ff.0)
    # generate output
    mu.ff <- exp(tcrossprod(coefs.ff, regressor_data))
    variance.ff <- mu.ff + mu.ff^2 / theta.ff
    y.res.ff <- mu.ff + pearson_residual.ff * sqrt(variance.ff)

  
  par(mfrow=c(1,2)) 
  hd <- hist(y.res.ff[gene,] - min(y.res.ff[gene,]))
  hd <- hist(y.res.ffpe[gene,] - min(y.res.ffpe[gene,]), breaks=hd$breaks)

    par(mfrow=c(1,2)) 
  hd <- hist(y.res.ff[gene,])
  hd <- hist(y.res.ffpe[gene,])

  
#  par(mfrow=c(1,2)) 
  hd <- hist(regressor_data_orig.ffpe[,2] - min(regressor_data_orig.ffpe[,2]))
  hd <- hist(regressor_data_orig.ff[,2] - min(regressor_data_orig.ff[,2]), breaks=hd$breaks)

      
  # This shows that subsetting genes (in FF) has little effect
  d <- density(ff.cc[gene,])
  plot(d)
  lines(density(ff.cc.subset[gene,], bw=d$bw), col="green")
  lines(density(ffpe.cc[gene,], bw=d$bw), col="blue")
  
  # What happens if we upsample ff
  ff.cc.subset.up <- correct_counts(ff.vst.subset, GetAssayData(ff.obj.subset, assay="Spatial", slot="counts"),verbosity=20, scale_factor=1*median(10^ffpe.vst$cell_attr$log_umi))
  d <- density(ff.cc[gene,])
  plot(d)
  lines(density(ff.cc.subset[gene,], bw=d$bw), col="green")
  lines(density(ffpe.cc[gene,], bw=d$bw), col="blue")
  lines(density(ff.cc.subset.up[gene,], bw=d$bw), col="red")

  # What happens if we downsample ffpe  
  ffpe.cc.down <- correct_counts(ffpe.vst, GetAssayData(ffpe.obj, assay="Spatial", slot="counts"),verbosity=20, scale_factor=1*median(10^ff.vst.subset$cell_attr$log_umi))
  d <- density(ff.cc[gene,])
  plot(d)
  lines(density(ff.cc.subset[gene,], bw=d$bw), col="green")
  lines(density(ffpe.cc[gene,], bw=d$bw), col="blue")
  lines(density(ffpe.cc.down[gene,], bw=d$bw), col="red")

  # What happens if we subsitute ffpe intercept for ff intercept (no change)
  tmp <- ff.vst.subset
  tmp$model_pars_fit[gene,"(Intercept)"] <- ffpe.vst$model_pars_fit[gene,"(Intercept)"]
  ff.cc.subset.mod <- correct_counts(tmp, GetAssayData(ff.obj.subset, assay="Spatial", slot="counts"),verbosity=20)
  d <- density(ff.cc[gene,])
  plot(d)
  lines(density(ff.cc.subset[gene,], bw=d$bw), col="green")
  lines(density(ffpe.cc[gene,], bw=d$bw), col="blue")
  lines(density(ff.cc.subset.mod[gene,], bw=d$bw), col="red")

  # What happens if we subsitute ffpe theta for ff theta 
  tmp <- ff.vst.subset
  tmp$model_pars_fit[gene,"theta"] <- ffpe.vst$model_pars_fit[gene,"theta"]
  ff.cc.subset.mod <- correct_counts(tmp, GetAssayData(ff.obj.subset, assay="Spatial", slot="counts"),verbosity=20, scale_factor=1*median(10^ffpe.vst$cell_attr$log_umi))
  d <- density(ff.cc[gene,])
  plot(d)
  lines(density(ff.cc.subset[gene,], bw=d$bw), col="green")
  lines(density(ffpe.cc[gene,], bw=d$bw), col="blue")
  lines(density(ff.cc.subset.mod[gene,], bw=d$bw), col="red")
  
  table(ff.cc.subset[gene,]==0)
  ff.total_umi <- colSums(GetAssayData(filtered.objs[[ff.sample]], assay="SCT", slot="counts")[common.genes,])
  ff.total_umi.all <- colSums(GetAssayData(filtered.objs[[ff.sample]], assay="SCT", slot="counts"))
  ffpe.total_umi <- colSums(GetAssayData(filtered.objs[[ffpe.sample]], assay="SCT", slot="counts")[common.genes,])
  ffpe.total_umi.all <- colSums(GetAssayData(filtered.objs[[ffpe.sample]], assay="SCT", slot="counts"))
  
ffpe.median.log_umi <- median(scts[[ffpe.sample]]$cell_attr$log_umi)
ff.median.log_umi <- median(scts[[ff.sample]]$cell_attr$log_umi)

vst.out <- scts[[ffpe.sample]]
foo <- correct_counts(vst.out, GetAssayData(filtered.objs[[ffpe.sample]], assay="Spatial", slot="counts"),verbosity=20)
hist(GetAssayData(filtered.objs[[ffpe.sample]], assay="SCT", slot="counts")[gene,])
vst.out.mod <- vst.out
# vst.out.mod$cell_attr$log_umi <- ff.median.log_umi
#foo.mod <- correct_counts(vst.out.mod, GetAssayData(filtered.objs[[ffpe.sample]], assay="Spatial", slot="counts"),verbosity=20, scale_factor=10^ff.median.log_umi)
foo.mod <- correct_counts(vst.out.mod, GetAssayData(filtered.objs[[ffpe.sample]], assay="Spatial", slot="counts"),verbosity=20, scale_factor=median(ff.total_umi))

foo.mod2 <- correct_counts(vst.out.mod, GetAssayData(filtered.objs[[ffpe.sample]], assay="Spatial", slot="counts"),verbosity=20, scale_factor=median(ff.total_umi/2))


ff.vst.out <- scts[[ff.sample]]
ff.cc <- correct_counts(ff.vst.out, GetAssayData(filtered.objs[[ff.sample]], assay="Spatial", slot="counts"),verbosity=20)

plot(density(ff.cc[gene,]))
lines(density(foo[gene,], bw=0.6717), col="green")
lines(density(foo.mod[gene,], bw=0.6717), col="blue")
lines(density(foo.mod2[gene,], bw=0.6717), col="red")

# SCT normalized counts
ff.sct.gene <- GetAssayData(filtered.objs[[ff.sample]], assay="SCT", slot="counts")[gene,]
ffpe.sct.gene <- GetAssayData(filtered.objs[[ffpe.sample]], assay="SCT", slot="counts")[gene,]

# SCT Pearson residuals
ff.sct.pearson.gene <- GetAssayData(filtered.objs[[ff.sample]], assay="SCT", slot="scale.data")[gene,]
ffpe.sct.pearson.gene <- GetAssayData(filtered.objs[[ffpe.sample]], assay="SCT", slot="scale.data")[gene,]

# raw counts
ff.raw.cnt.gene <- GetAssayData(filtered.objs[[ff.sample]], assay="Spatial", slot="counts")[gene,]
ffpe.raw.cnt.gene <- GetAssayData(filtered.objs[[ffpe.sample]], assay="Spatial", slot="counts")[gene,]

# CPMs
ff.cpm.gene <- cpms[[ff.sample]][gene,]
ffpe.cpm.gene <- cpms[[ffpe.sample]][gene,]


g1 <- ggplot(data = data.frame(x = ff.raw.cnt.gene), aes(x = x, y = ..density..)) + 
  geom_histogram(bins = 100, colour = 1, fill = "white") + xlab(paste0(gene, "\n(Raw Counts)")) + ylab("Density") + 
  theme(text = element_text(size = 20))

g2 <- ggplot(data = data.frame(x = ff.cpm.gene), aes(x = x, y = ..density..)) + 
  geom_histogram(bins = 100, colour = 1, fill = "white") + xlab(paste0(gene, "\n(CPMs)")) + ylab("Density") +
  theme(text = element_text(size = 20))

g3 <- ggplot(data = data.frame(x = ff.sct.gene),
             aes(x = x, y = ..density..)) + 
  geom_histogram(bins = 100, colour = 1, fill = "white") + xlab(paste0(gene, "\n(SCT-xformed Counts)")) + ylab("Density") +
  theme(text = element_text(size = 20))

g4 <- ggplot(data = data.frame(x = ff.sct.pearson.gene),
             aes(x = x, y = ..density..)) + 
  geom_histogram(bins = 100, colour = 1, fill = "white") + xlab(paste0(gene, "\n(SCT Pearson Residuals)")) + ylab("Density") +
  theme(text = element_text(size = 20))


g.left <- plot_grid(g1, g2, g3, g4, nrow=4)
g.left <- add.title.to.plot(g.left, paste0(ff.sample, " (Fresh Frozen)"), rel_heights=c(0.05,1), size = 20)


g1 <- ggplot(data = data.frame(x = ffpe.raw.cnt.gene), aes(x = x, y = ..density..)) + 
  geom_histogram(bins = 100, colour = 1, fill = "white") + xlab(paste0(gene, "\n(Raw Counts)")) + ylab("Density") + 
  theme(text = element_text(size = 20))

g2 <- ggplot(data = data.frame(x = ffpe.cpm.gene), aes(x = x, y = ..density..)) + 
  geom_histogram(bins = 100, colour = 1, fill = "white") + xlab(paste0(gene, "\n(CPMs)")) + ylab("Density") +
  theme(text = element_text(size = 20))

g3 <- ggplot(data = data.frame(x = ffpe.sct.gene),
             aes(x = x, y = ..density..)) + 
  geom_histogram(bins = 100, colour = 1, fill = "white") + xlab(paste0(gene, "\n(SCT-xformed Counts)")) + ylab("Density") +
  theme(text = element_text(size = 20))

g4 <- ggplot(data = data.frame(x = ffpe.sct.pearson.gene),
             aes(x = x, y = ..density..)) + 
  geom_histogram(bins = 100, colour = 1, fill = "white") + xlab(paste0(gene, "\n(SCT Pearson Residuals)")) + ylab("Density") +
  theme(text = element_text(size = 20))

g.right <- plot_grid(g1, g2, g3, g4, nrow=4)
g.right <- add.title.to.plot(g.right, paste0(ffpe.sample, " (FFPE)"), rel_heights=c(0.05,1), size = 20)

g.all <- plot_grid(g.left, g.right, nrow=1)

png(paste0(plots_dir, "ffpe-vs-ff-", gene, ".png"))
print(g.all)
d <- dev.off()

df1 <- data.frame(cell = Cells(filtered.objs[[ff.sample]]), sct = ff.sct.gene)
df2 <- data.frame(cell = colnames(cpms[[ff.sample]]), cpm = cpms[[ff.sample]][gene,])
df <- merge(df1, df2)
g1 <- ggscatter(df, x = "cpm", y = "sct",
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE # Add confidence interval 
   ) + xlab(paste0(gene, " (CPMs)")) + ylab(paste0(gene, " (SCT-transformed Counts)")) +
  stat_cor(aes(label = ..rr.label..), method = "pearson", label.x = 10, label.y = 0.9 * max(df$sct), size = 10)
g1 <- g1 + theme(text = element_text(size = 20)) + ggtitle(paste0(ff.sample, " (Fresh Frozen)"))
g1 <- g1 + xlim(c(0, 1.05 * max(df$cpm))) + ylim(c(0, 1.05 * max(df$sct)))

df1 <- data.frame(cell = Cells(filtered.objs[[ff.sample]]), sct = ff.sct.pearson.gene)
df2 <- data.frame(cell = colnames(cpms[[ff.sample]]), cpm = cpms[[ff.sample]][gene,])
df <- merge(df1, df2)
g2 <- ggscatter(df, x = "cpm", y = "sct",
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE # Add confidence interval 
   ) + xlab(paste0(gene, " (CPMs)")) + ylab(paste0(gene, " (SCT Pearson Residuals)")) +
  stat_cor(aes(label = ..rr.label..), method = "pearson", label.x = 10, label.y = 0.9 * max(df$sct), size = 10)
g2 <- g2 + theme(text = element_text(size = 20)) + ggtitle(paste0(ff.sample, " (Fresh Frozen)"))
g2 <- g2 + xlim(c(0, 1.05 * max(df$cpm))) + ylim(c(0, 1.05 * max(df$sct)))


df1 <- data.frame(cell = Cells(filtered.objs[[ffpe.sample]]), sct = ffpe.sct.gene)
df2 <- data.frame(cell = colnames(cpms[[ffpe.sample]]), cpm = cpms[[ffpe.sample]][gene,])
df <- merge(df1, df2)
g3 <- ggscatter(df, x = "cpm", y = "sct",
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE # Add confidence interval 
   ) + xlab(paste0(gene, " (CPMs)")) + ylab(paste0(gene, " (SCT-transformed Counts)")) +
  stat_cor(aes(label = ..rr.label..), method = "pearson", label.x = 10, label.y = 0.9 * max(df$sct), size = 10)
g3 <- g3 + theme(text = element_text(size = 20)) + ggtitle(paste0(ffpe.sample, " (FFPE)"))
g3 <- g3 + xlim(c(0, 1.05 * max(df$cpm))) + ylim(c(0, 1.05 * max(df$sct)))

df1 <- data.frame(cell = Cells(filtered.objs[[ffpe.sample]]), sct = ffpe.sct.pearson.gene)
df2 <- data.frame(cell = colnames(cpms[[ffpe.sample]]), cpm = cpms[[ffpe.sample]][gene,])
df <- merge(df1, df2)
g4 <- ggscatter(df, x = "cpm", y = "sct",
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE # Add confidence interval 
   ) + xlab(paste0(gene, " (CPMs)")) + ylab(paste0(gene, " (SCT Pearson Residuals)")) +
  stat_cor(aes(label = ..rr.label..), method = "pearson", label.x = 10, label.y = 0.9 * max(df$sct), size = 10)
g4 <- g4 + theme(text = element_text(size = 20)) + ggtitle(paste0(ffpe.sample, " (FFPE)"))
g4 <- g4 + xlim(c(0, 1.05 * max(df$cpm))) + ylim(c(0, 1.05 * max(df$sct)))

g.all <- plot_grid(g1, g2, nrow=1)

png(paste0(plots_dir, "ffpe-vs-ff-correlation-", gene, ".png"), width = 2 * 480)
print(g.all)
d <- dev.off()

}
```


```{r}
stop("stop")
```



```{r}
if(FALSE){
for(indx in 1:length(filtered.objs)) {
#indx <- 1
obj <- filtered.objs[[indx]]
obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = "^MT-")
obj[["percent.ribo"]] <- PercentageFeatureSet(obj, pattern = "^RPL|^RPS")
lst <- plot.features_(obj, features=c("percent.mt", "percent.ribo"), feature.names = c("% MT", "% Ribo"), include.hne=TRUE, include.umi.cnts=TRUE)
g1 <- ggscatter(obj[[]], x = "nCount_Spatial", y = "percent.ribo",
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE # Add confidence interval
   )
g1 <- g1 + stat_cor(method = "pearson", size=10, aes(label = ..rr.label..)) 
g1 <- g1 + xlab("# UMIs") + ylab("% Ribosomal UMIs") + theme(text = element_text(size = 20))
g2 <- ggscatter(obj[[]], x = "nCount_Spatial", y = "percent.mt",
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE # Add confidence interval
   )
g2 <- g2 + stat_cor(method = "pearson", size=10, aes(label = ..rr.label..)) 
g2 <- g2 + xlab("# UMIs") + ylab("% Mitochondrial UMIs") + theme(text = element_text(size = 20))
g <- plot_grid(plotlist = c(lst, list(g2), list(g1)),nrow=3)
sample <- names(filtered.objs)[indx]
g <- add.title.to.plot(g, sample, rel_heights=c(0.05,1))
cat(paste0("Cor(ribo, read cnt): ", cor(obj[[]]$percent.ribo, obj[[]]$nCount_Spatial), "\n"))
cat(paste0("Cor(MT, read cnt): ", cor(obj[[]]$percent.mt, obj[[]]$nCount_Spatial), "\n"))
png(paste0("mt-ribo-spatial-", sample, ".png"), width = 2 * 480, height = 3 * 480)
print(g)
d <- dev.off()
}
}

```





```{r}
# net <- get_collectri(organism='human', split_complexes=FALSE)
```

```{r}
p_load(sctransform)
nms <- names(filtered.objs)
names(nms) <- nms
scts <-
  llply(nms,
        .fun = function(nm) {
          obj <- filtered.objs[[nm]]
          rds.file <- paste0(analysis_dir, "vst-", "st-", nm, ".rds")
          #if(!file.exists(rds.file)) {
            sct.data <- vst(GetAssayData(object = obj, slot = "counts", assay = "Spatial"), vst.flavor = "v2", verbosity = 10, return_cell_attr = TRUE)
            saveRDS(sct.data, file=rds.file)
          #}
          sct.data <- readRDS(rds.file)
        })
```



```{r}
if(FALSE) {
net <- read.table("/home/whitebr/dorothea-net.tsv", sep="\t", header=TRUE)
pax8.net <- subset(net, source=="PAX8")
# foo <- run_wmean(GetAssayData(filtered.objs[[1]], assay="Spatial"), network=pax8.net, .source="source", .target="target", .mor = "weight")
pax8.acts <-
  llply(filtered.objs,
        .fun = function(obj) {
          run_wmean(GetAssayData(obj, assay="SCT", slot="data"), network=pax8.net, .source="source", .target="target", .mor = "weight")
        })
}
```

```{r}
nm <- names(filtered.objs)[4]
obj <- filtered.objs[[nm]]
tbl <- as.data.frame(subset(pax8.acts[[nm]], statistic == "wmean"))
rownames(tbl) <- tbl$condition
stopifnot(all(rownames(tbl) == colnames(GetAssayData(obj, assay="SCT", slot="data"))))
tbl <- tbl[, c("score", "p_value")]
colnames(tbl) <- c("pax8.wmean.score", "pax8.wmean.pval")
obj <- add.metadata.to.seurat.obj(obj, tbl)
plot.features(obj, features=c("pax8.wmean.score", "PAX8", "SLC34A2"))

```




```{r}
nm <- names(filtered.objs)[4]
obj <- filtered.objs[[nm]]
seurat.vs <- obj

# Filtering genes that are expressed in at least 5% of spots

gene.expression <- GetAssayData(seurat.vs, assay = "SCT", slot="data")
gene.expression.cnts <- GetAssayData(seurat.vs, assay = "SCT", slot="counts")
#coverage <- rowSums(gene.expression > 0) / ncol(gene.expression)
#slide.markers <- names(which(coverage >= 0.05))
vars <- unlist(apply(gene.expression, 1, var))
gene.expression <- gene.expression[vars > 0,]

pops <- c("endothelial", "epithelial", "lymphocytes", "myeloid", "stromal")
#pops <- c("endothelial", "lymphocytes", "myeloid", "stromal")
#slide.markers <- unique(c("PAX8", "SLC34A2", pax8.net$target, pops))

slide.markers <- c("PAX8", "SLC34A2")

slide.markers <- slide.markers[slide.markers %in% rownames(gene.expression)]
data <- rbind(gene.expression.cnts[slide.markers,], t(obj[[]][colnames(gene.expression),pops]))
exclude <- apply(data, 2, function(col) any(is.na(col)))
# data <- data[, !exclude]
obj[["SCT"]] <- CreateAssayObject(data = data)
obj <- obj[, !exclude]
DefaultAssay(obj) <- "SCT"
# obj[["Spatial"]] <- NULL

slide.markers <- unique(c(slide.markers, pops))

seurat.vs <- obj


# Define assay for each view
view.assays <- list(
  "main" = "SCT",
  "juxta" = "SCT"
)

# Define features for each view
view.features <- list(
  "main" = slide.markers,
  "juxta" = slide.markers
)

# Define spatial context for each view
view.types <- list(
  "main" = "intra",
  "juxta" = "juxta"
)

# Define additional parameters (l in the case of paraview)
view.params <- list(
  "main" = NULL,
  "juxta" = NULL
)


misty.out <- "vignette_model_seurat"

p_load(tidyverse)
setwd("/home/whitebr/local/gsl-2.5/lib/")
misty.results <- run_misty_seurat(
  visium.slide = seurat.vs,
  view.assays = view.assays,
  view.features = view.features,
  view.types = view.types,
  view.params = view.params,
  spot.ids = NULL, # Using the whole slide
  out.alias = misty.out,
  target.subset = c("PAX8"),
  bypass.intra = TRUE
)
res <-  collect_results(misty.results)
```

```{r}
pos <- obj[[]][,c("row","col")]
# expr <- t(GetAssayData(obj, assay="SCT", slot="data"))
expr <- extract_seurat_data(obj, "SCT", pos)
misty.intra <- create_initial_view(expr)
# misty.views <- misty.intra %>% add_paraview(pos, l = 10)
m <- as.tibble(do.call(rbind, rep(list(colMeans(expr)),nrow(expr))))
v <- create_view("mean", m, "mean")
# misty.views <- misty.intra %>% add_paraview(pos, l = 10)
misty.views <- misty.intra %>% add_views(v)
res <- run_misty(misty.views) %>% collect_results()
```


```{r}

res %>% plot_improvement_stats("gain.R2")
res %>% plot_view_contributions()
res %>% plot_interaction_heatmap(view = "intra")
res$importances.aggregated %>% 
  filter(view == "intra", Target == "PAX8") %>%
  arrange(-Importance)
SpatialFeaturePlot(seurat.vs, features = c("IGKC", "Plasma.Cells"))
res %>% plot_interaction_heatmap(view = "para.igkc_10")
SpatialFeaturePlot(seurat.vs, features = c("IGKC", "Endothelial"))
SpatialFeaturePlot(seurat.vs, features = c("Plasma.Cells", "Endothelial"))
SpatialFeaturePlot(seurat.vs, features = c("iCAFs", "Myoepithelial"))
```


```{r}
stop("stop")
```


```{r}
if(FALSE) {
flag <- tnbc.cell.types %in% c("B_Cells", "CD4+ T-cells", "CD8+ T-cells", "iCAFs", "myCAFs", "imPVL")
# flag <- tnbc.cell.types %in% c("B_Cells", "CD8+ T-cells", "iCAFs")
conditions <- as.character(tnbc.cell.types)[flag]
mat <- tnbc.cnts[, flag]
names(conditions) <- colnames(mat)
mat <- mat[rowSums(mat) > 0,]
#norm.mat <- log1p.sf.norm(mat)
}
```

```{r}
if(FALSE) {
norm.mats <- list()
norm.mats[["log1p.sf"]] = log1p.sf.norm(mat)
norm.mats[["tmm.cpm"]] = tmm.cpm.norm(mat)
#norm.mats[["seurat.counts"]] = sctransform.norm.cnts(mat)
#norm.mats[["seurat.log1p"]] = sctransform.norm.log1p(mat)
obj <- CreateSeuratObject(mat, assay="RNA")
obj <- apply.sctransform_(obj, assay="RNA")
norm.mats[["seurat.counts"]] = GetAssayData(obj,assay="SCT",slot="counts")
norm.mats[["seurat.log1p"]] = GetAssayData(obj,assay="SCT",slot="data")
}
```

```{r}
if(FALSE) {
mat <- tnbc.cnts
mat <- mat[rowSums(mat) > 0,]
all.norm.mats <- list()
all.norm.mats[["log1p.sf"]] = log1p.sf.norm(mat)
gc()
all.norm.mats[["tmm.cpm"]] = tmm.cpm.norm(mat)
gc()
obj <- CreateSeuratObject(mat, assay="RNA")
obj <- apply.sctransform_(obj, assay="RNA")
gc()
all.norm.mats[["seurat.counts"]] = GetAssayData(obj,assay="SCT",slot="counts")
gc()
all.norm.mats[["seurat.log1p"]] = GetAssayData(obj,assay="SCT",slot="data")
gc()
rm(obj)
rm(mat)
gc()
}
```


```{r}
de.methods <- list()
de.methods[["mast"]] <- mast.de.test
de.methods[["wilcoxon"]] <- wilcoxon.de.test
```

```{r}
#foo <- find.markers.wrapper(norm.mats, as.character(all.norm.mats), de.methods["wilcoxon"])
```


```{r}
#stop("Done")
```


```{r}
#wilcoxon.res <- test.de.consistency.wrapper(norm.mats, conditions, de.methods["wilcoxon"], num.iterations=10)
#save(wilcoxon.res, file="wilcoxon.res.Rdata")
```


```{r}
if(FALSE) {
mast.res <- test.de.consistency.wrapper(norm.mats[c("seurat.log1p", "log1p.sf")], conditions, de.methods["mast"], num.iterations=10)
save(mast.res, file="mast.res.Rdata")
cat("Done\n")
stop("Done")
}
```


```{r}
if(FALSE) {
de.nms <- names(de.methods)
names(de.nms) <- de.nms
norm.nms <- names(norm.mats)
names(norm.nms) <- norm.nms
all.res <-
  ldply(de.nms,
        .parallel = FALSE,
        .fun = function(de.method.name) {
          de.method <- de.methods[[de.method.name]]
          print(de.method.name)
          ret <- 
            ldply(norm.nms,
                  .parallel = FALSE,
                  .fun = function(norm.name) {
                    print(norm.name)
                    norm.mat <- norm.mats[[norm.name]]
                    de.res <- test.de.consistency(norm.mat, conditions, de.method = de.method, num.iterations = 1)
                    gc()
                    de.res
                  })
          colnames(ret)[1] <- "norm"
          ret
                  
        })
colnames(all.res)[1] <- "de.method"
save(all.res, file="all.res.Rdata")
cat("Done!")
}
```


```{r}
#stop("stop")
```


```{r}
#de.wilcox <- test.de.consistency(norm.mat, conditions, de.method = wilcoxon.de.test, num.iterations = 5)
```

```{r}
#de.mast <- test.de.consistency(norm.mat, conditions, de.method = mast.de.test, num.iterations = 5)
```

```{r}
```

```{r}
plot.mean.var <- function(cnt.mat) {
sce <- SingleCellExperiment(assays=list(counts=cnt.mat))
tmp <- logNormCounts(sce)
#lcnts <- assay(tmp, "logcounts")
dec <- modelGeneVar(tmp)

fit.pbmc <- metadata(dec)
plot(fit.pbmc$mean, fit.pbmc$var, xlab="Mean of log-expression",
    ylab="Variance of log-expression")
curve(fit.pbmc$trend(x), col="dodgerblue", add=TRUE, lwd=2)
return(fit.pbmc)  
}
```

```{r}
calculate.tmm.and.scran.library.sizes <- function(cnt.mat) {
  sce <- SingleCellExperiment(assays=list(counts=cnt.mat))
  # size factors: Normalized expression values are computed by dividing the counts for each cell by the size factor for that cell. 
  lcnts <- logNormCounts(sce)
  scran.sf <- sizeFactors(lcnts)
  # calcNormFactors: lib.size * norm.factors where lib.size contains the original library sizes and norm.factors is the vector of scaling factors computed by this function. 
  tmm <- edgeR::calcNormFactors(cnt.mat)
  list("scran.sf" = scran.sf, "tmm.sf" = tmm)
}
```

```{r}
#ret <- calculate.tmm.and.scran.library.sizes(GetAssayData(filtered.objs[[1]], assay="Spatial", slot="count"))
```


```{r}
calculate.fracs.top.n <- function(cnt.mat) {
  cols <- colnames(cnt.mat)
  names(cols) <- cols
  ret <- ldply(cols,
               .parallel = TRUE,
               .fun = function(col) {
                 vec <- cnt.mat[,col]
                 vec <- vec[order(vec, decreasing=TRUE)]
                 cs <- cumsum(vec)
                 tot <- sum(vec)
                 ns <- c(1,5,10,20,50,100)
                 nms <- paste0("frac.", ns)
                 ret <- cs[ns]/tot
                 names(ret) <- nms
                 df <- t(as.data.frame(ret))
                 rownames(df) <- NULL
                 df
                })
  colnames(ret)[1] <- "id"
  ret
}

# Exclude all zeroes
# foo <- apply(cnt.mat, 2, rank)
# rm <- rowMeans(foo)
# rm <- rm[order(rm, decreasing=TRUE)]
```


```{r}
if(FALSE) {
cnt.mat <- GetAssayData(filtered.objs[[1]], assay="Spatial", slot="count")
sce <- SingleCellExperiment(assays=list(counts=cnt.mat))
tmp <- logNormCounts(sce)
lcnts <- assay(tmp, "logcounts")
dec <- modelGeneVar(tmp)

fit.pbmc <- metadata(dec)
plot(fit.pbmc$mean, fit.pbmc$var, xlab="Mean of log-expression",
    ylab="Variance of log-expression")
curve(fit.pbmc$trend(x), col="dodgerblue", add=TRUE, lwd=2)
# plot(density(cnt.mat["MALAT1",]/colSums(cnt.mat)))
}
# To do
# Plot TMM vs scran normalization -- library size vs norm
# Plot TMM density
# Plot scran norm density
# Plot mean-var
# Plot entropy?
# Plot frac of genes by top n=5, 10, 20, 50, 100
```


```{r}
# Use edgeR with cell detection rate as a covariate. This was a top-performing method
# in a recent study (though by the authors)
# See https://www.nature.com/articles/nmeth.4612
# See the code where upon which the below is based
# https://github.com/csoneson/conquer_comparison/blob/master/scripts/apply_edgeRQLFDetRate.R
# NB: cond1 will be the reference.
# This means that those genes with _negative_ logFC will be positive markers for cond1.
# conditions: vector of cell-level conditions/labels
find.markers.edgeRQLFDetRate <- function(raw.counts, conditions, cond1, cond2) {
  flag <- conditions %in% c(cond1, cond2)
  L.count <- raw.counts[, flag]
  L.condt <- factor(conditions[flag], levels = c(cond1, cond2))
  dge <- DGEList(L.count, group = L.condt)
  dge <- calcNormFactors(dge)
  cdr <- scale(colMeans(L.count > 0))
  design <- model.matrix(~ cdr + L.condt)
  dge <- estimateDisp(dge, design = design)
  fit <- glmQLFit(dge, design = design)
  qlf <- glmQLFTest(fit)
  tt <- topTags(qlf, n = Inf)
  cond1.flag <- conditions == cond1
  pct.1 <- as.numeric(rowMeans(raw.counts[rownames(tt$table),cond1.flag]>0))
  cond2.flag <- conditions == cond2
  pct.2 <- as.numeric(rowMeans(raw.counts[rownames(tt$table),cond2.flag]>0))
  tt$table <- cbind(tt$table, pct.1=pct.1, pct.2=pct.2)
  tt
}

find.all.markers <- function(raw.counts, conditions, rds.output.file.prefix = NULL) {
  uniq.conditions <- unique(conditions)
  cond1.indices <- 1:(length(uniq.conditions)-1)
  names(cond1.indices) <- uniq.conditions[cond1.indices]
  llply(cond1.indices, .parallel = FALSE,
        .fun = function(i) {
          cat(paste0("Find markers for cell type ", i, " of ", length(uniq.conditions), ": ", uniq.conditions[i], "\n"))
          cond2.indices <- (i+1):length(uniq.conditions)
          names(cond2.indices) <- uniq.conditions[cond2.indices]
          llply(cond2.indices, .parallel = FALSE,
                .fun = function(j) {
                  cat(paste0("Find markers for cell type ", uniq.conditions[i], 
                             " (", i , " of ", length(uniq.conditions), ") vs ",
                             uniq.conditions[j], " (", j , " of ", length(uniq.conditions), ")\n"))

                  rds.output.file <- NULL
                  if(!is.null(rds.output.file.prefix)) {
                    rds.output.file <- paste0(rds.output.file.prefix, make.names(uniq.conditions[i]), "-vs-", make.names(uniq.conditions[j]), ".rds")
                    if(file.exists(rds.output.file)) {
                      res <- readRDS(rds.output.file)
                      gc()
                      return(res)
                    }
                  }
                  res <- find.markers(raw.counts, conditions, cond1 = uniq.conditions[i], cond2 = uniq.conditions[j])
                  if(!is.null(rds.output.file)) {
                    saveRDS(res, rds.output.file)
                  }
                  gc()
                  return(res)
                })
        })
}
```

```{r}
if(FALSE) {
flag <- as.character(tnbc.cell.types) %in% c("iCAFs", "myCAFs", "B_Cells")
# tt <- find.markers(raw.counts = tnbc.cnts, conditions = as.character(tnbc.cell.types), cond1 = "myCAFs", cond2 = "B_Cells")
# tnbc.markers <- find.all.markers(tnbc.cnts[,flag], as.character(tnbc.cell.types)[flag])
dir.create(paste0(analysis_dir, "/wu-scrnaseq-markers/"), showWarnings = FALSE, recursive = TRUE)
tnbc.markers <- find.all.markers(tnbc.cnts, as.character(tnbc.cell.types), rds.output.file.prefix = paste0(analysis_dir, "/wu-scrnaseq-markers/wu-scrnaseq-markers-"))
}
```


```{r}
#stop("stop")
```


```{r}
if(FALSE) {
cpm.pb <- read.table("cpm-pb.tsv", sep="\t", header=TRUE)
patient.df <- read.table("patient-df.tsv", sep="\t", header=TRUE)
patient.df$label <- factor(patient.df$label)
patient.df$batch.var <- factor(patient.df$batch.var)
# foo <- HarmonyMatrix(as.matrix(cpm.pb[rowSums(cpm.pb) > 0,]), patient.df, "batch.var", do_pca=TRUE, npcs=10)
foo <- HarmonyMatrix(as.matrix(cpm.pb[odg,]), patient.df, "batch.var", do_pca=TRUE, npcs=10)
plot(foo[,1],foo[,2])
text(foo[,1], foo[,2], patient.df$label)
}

```




Configure variables that point to location of images and directories where analyses and plots will be stored.


```{r}
# Read in the filtered and unfiltered matrices and append the tissue positions information to the metadata:
#filtered.objs <- create.visium.seurat.objects(spaceranger_dirs, filter.spots = TRUE)
#unfiltered.objs <- create.visium.seurat.objects(spaceranger_dirs, filter.spots = FALSE)
```

```{r}
# Perform normalization of counts using SCTransform (which fits a negative binomial to the count data)
# This adds a new assay "SCT" to the returned Seurat object. That assay has slots "counts" (the corrected counts),
# "data" (log1p(counts)), and "scale.data" (the "pearson residuals").
# These would be accessible via GetAssayData(filtered.objs[[1]], slot = "data", assay = "SCT")
# Running with default parameters (the most interesting of which look to be variable.features.n and/or variable.features.rv.th)
# filtered.objs <- apply.sctransform(filtered.objs)
```

```{r}
if(FALSE) {
cols <- llply(filtered.objs, .fun = function(obj) rowSums(GetAssayData(obj, slot="data", assay="Spatial")))
pb <- do.call(cbind, cols)
library(edgeR)
cpm.pb <- cpm(pb)
library(uwot)
rs <- rowSums(as.matrix(cpm.pb))
expr.genes <- names(rs)[log(rs) > 3]
umap.pb <- umap(t(cpm.pb[expr.genes,]), scale=TRUE)
# foo <- HarmonyMatrix(as.matrix(cpm.pb[rowSums(cpm.pb) > 0,]), patient.df, "label", do_pca=TRUE, npcs=8)
cpm.pb <- read.table("cpm-pb.tsv", sep="\t", header=TRUE)
patient.df <- read.table("patient-df.tsv", sep="\t", header=TRUE)
patient.df$label <- factor(patient.df$label)
rownames(patient.df) <- patient.df$sample

write.table(file="cpm-pb.tsv", cpm.pb, row.names=TRUE, col.names=TRUE, sep="\t", quote=FALSE)
write.table(file="patient-df.tsv", patient.df, row.names=TRUE, col.names=TRUE, sep="\t", quote=FALSE)
plot(umap.pb[,1], umap.pb[,2])
text(umap.pb[,1], umap.pb[,2], patient.df[colnames(pb),"label"])
text(umap.pb[,1], umap.pb[,2], colames(pb))
# TO DO
# - note findvariablefeatures functions
# - compute all markers for TNBC data -- use this in downstream analysis
# - getOverdispersedGenes
# - note that I calculated variance in log10; STdeconolve calculates log variance, what does edgeR do
# - harmonize based on sequencing batch
# - for example pseudo bulk
#   - fit a gaussian -> expressed genes
#   see plotmm: https://rdrr.io/cran/plotmm/man/plot_mix_comps_normal.html
#   - look at overdispersed
# - take union of all overdispersed
# - do pca with labels
# - do harmony with labels
# - how do we generalize "expressed" for spots?
odg <- getOverdispersedGenes(GetAssayData(filtered.objs[[1]], assay="Spatial")[expr.genes,], plot=TRUE)
bar <- getOverdispersedGenes(as.matrix(cpm.pb)[expr.genes,], plot=TRUE)
umap.pb <- umap(t(cpm.pb[odg,]), scale=TRUE)
}
```


```{r}
indx <- 100
vec <- GetAssayData(filtered.objs[[1]], slot="data", assay="Spatial")[,indx]
tbl <- table(vec)
df <- data.frame(cnt = as.numeric(names(tbl)), freq = cumsum(as.numeric(tbl))/sum(tbl))
plot(df$cnt[df$cnt<50], df$freq[df$cnt<50])
tbl1 <- table(vec[vec>0])
plot(tbl1)
```



```{r}
# Run RCTD spot deconvolution
rctds <- 
  llply(datasets, .parallel = FALSE,
        .fun = function(dataset) {
          print(dataset)
          rds.file <- paste0(analysis_dir, "/", dataset, "-rctd.rds")
          myRCTD <- rctd.wrapper(filtered.objs[[dataset]], tnbc.cnts, tnbc.cell.types, rds.output.file = rds.file, run.rctd = TRUE, intersect.sc.and.st.genes = FALSE)
          gc()
          myRCTD
        })
```


```{r}
plot.gene.pop.correlation <- function(objs, rctds, sample.name, gene, pop) {
  mat <- GetAssayData(objs[[sample.name]], slot = "data", assay = "SCT")
  mat <- cpm(mat, log = TRUE)
  expr.df <- data.frame(gene = as.numeric(mat[gene,]), spot = colnames(mat))
  rctd.tbl <- format.rctd.output_(rctds[[sample.name]], normalize=FALSE)
  rctd.df <- data.frame(pop = rctd.tbl[, pop], spot = rownames(rctd.tbl))
  expr.df <- merge(expr.df, rctd.df)
  return(expr.df)
}
```


```{r}
gene <- "CDKN2A"
```


```{r}
# stop("stop")
```


```{r}
# To do
# Basic QC: reads, umis
# Plot bio/tech replicates
# Cluster bio/tech replicates (w/o batch correction)
# Deconvolve
# Took at senescence markers
# Check for off by 1 in get.per.spot.saturation.stats
# get.per.spot.saturation.stats
```

```{r}
align.metrics <- get.all.per.spot.alignment.metrics(spaceranger_dirs, prefix = analysis_dir)
```


```{r}
indices <- 1:nrow(patient.df)
names(indices) <- patient.df$sample
top.gs <- llply(indices, 
                .parallel = FALSE, 
                .fun = function(i) {
                  sample <- patient.df[i, "sample"]
                  short.sample <- patient.df[i, "short.sample"]
                  patient <- patient.df[i, "patient"]
                  status <- patient.df[i, "tissue"]
                  title <- paste0(status, " patient: ", patient, "\n(", sample, ")")
                  g <- plot.top.genes(as.matrix(GetAssayData(filtered.objs[[sample]], assay="Spatial", slot="counts")))
                  g <- g + ggtitle(title)
                })
```

```{r}
pts <- c("1127","1330A","1863B")
g <- plot_grid(plotlist=top.gs[patient.df$sample[patient.df$patient %in% pts]])
png(paste0(plots_dir, "top-genes-", paste(pts,collapse="-"), ".png"), width = 2*480, height=2*480)
print(g)
d <- dev.off()

pts <- c("2171", "4401B")
g <- plot_grid(plotlist=top.gs[patient.df$sample[patient.df$patient %in% pts]])
png(paste0(plots_dir, "top-genes-", paste(pts,collapse="-"), ".png"), width = 2*480, height=2*480)
print(g)
d <- dev.off()

pts <- c("4700")
g <- plot_grid(plotlist=top.gs[patient.df$sample[patient.df$patient %in% pts]])
png(paste0(plots_dir, "top-genes-", paste(pts,collapse="-"), ".png"), width = 2*480, height=2*480)
print(g)
d <- dev.off()

pts <- c("9990")
g <- plot_grid(plotlist=top.gs[patient.df$sample[patient.df$patient %in% pts]])
png(paste0(plots_dir, "top-genes-", paste(pts,collapse="-"), ".png"), width = 2*480, height=2*480)
print(g)
d <- dev.off()

pts <- c("6110","6970","7031")
g <- plot_grid(plotlist=top.gs[patient.df$sample[patient.df$patient %in% pts]])
png(paste0(plots_dir, "top-genes-", paste(pts,collapse="-"), ".png"), width = 2*480, height=2*480)
print(g)
d <- dev.off()

# plot.features(filtered.objs[["SC2200259_9990"]], features=c("IGKC","MT-CO2"),include.hne=TRUE)
# plot.features(filtered.objs[["SC2300234_JP4401B"]], features=c("IGKC","CD19", "CD8B", "GZMB"))
# plot.features(filtered.objs[["SC2300231_JP1863B"]], features=c("IGKC","CD19", "CD8B"))
# plot.features(filtered.objs[[sample.name]], features=c("IGKC","EEF1A1", "GAPDH", "TUBB", "FTH1"),include.hne=TRUE,include.umi.cnts=TRUE)

obj <- filtered.objs[["SC2300231_JP1863B"]]
mat <- GetAssayData(obj, assay="Spatial", slot="counts")
# norm.mat <- log1p.sf.norm(as.matrix(mat))
norm.mat <- edgeR::cpm(as.matrix(mat), log=FALSE)
ret <- MCPcounter.estimate(expression=norm.mat, featuresType="HUGO_symbols")
obj <- add.metadata.to.seurat.obj(obj, t(ret))

cms <- predictCMS(norm.mat)
df.cms <- data.frame(cms = as.character(cms))
rownames(df.cms) <- colnames(norm.mat)
obj <- add.metadata.to.seurat.obj(obj, df.cms)
plot.features(obj, features=c("B.lineage"))
plot.features(obj, features=c("CD19", "CD79A", "MS4A1"))
plot.features(obj, features=c("CD19", "CD79A", "MS4A1", "BANK1", "CD22", "CR2", "FCRL2", "PAX5"))
plot.features(obj, features=c("CD19", "CD79A", "MS4A1", "IGKC", "B.lineage", "CD8B"))

# In veins
indx <- 10
plot.features(filtered.objs[[indx]], features=c("IGKC"), include.umi.cnts=TRUE)

indx <- 12
plot.features(filtered.objs[[indx]], features=c("IGKC", "Epithelial"), include.umi.cnts=TRUE)

indx <- 15
plot.features(filtered.objs[[indx]], features=c("IGKC", "Epithelial"), include.umi.cnts=TRUE)

indx <- 17
plot.features(filtered.objs[[indx]], features=c("IGKC", "Epithelial"), include.umi.cnts=TRUE)
plot.features(filtered.objs[[indx]], features=c("IGKC", "Epithelial", "EPCAM"), include.umi.cnts=TRUE)
plot(log(mat.cpm["EPCAM",]),log(mat.cpm["IGKC",]))
```


```{r}
stop("stop")
```




```{r}
plot.features(filtered.objs[[11]], features=c("nCount_Spatial"),include.hne=TRUE)
```




```{r}
gs <-
  dlply(patient.df,
        .variables = c("patient"),
        .fun = function(df) {
          df <- df[order(df$label),]
          plts <- 
            llply(1:nrow(df),
                  .fun = function(indx) {
                    print(df[indx,"sample"])
                    # g <- plot.features(unfiltered.objs[[df[indx,"sample"]]], features=c("nCount_Spatial"), feature.names = c("nUMIs"), include.hne=TRUE)
                    g <- plot.features(unfiltered.objs[[df[indx,"sample"]]], features=NULL, include.umi.cnts = TRUE, include.hne=TRUE)
                    g <- add.title.to.plot(g, paste0("Patient: ", df[indx, "patient"], " Sample: ", df[indx, "short.sample"], "\n", df[indx, "label"]), size=24, rel_heights=c(0.1,0.4))
                    g
                  })
          # plot_grid(plotlist = plts, nrow=length(plts))
          nr <- min(2, length(plts))
          g <- plot_grid(plotlist = plts, nrow=nr)
          nm <- df[1, "patient"]
          nc <- ceiling(length(plts) / nr)
          png(paste0(plots_dir, "/", nm, "-nUMIs.png"), height = nr * 250, width = nc * 480)
          print(g)
          d <- dev.off()

        })
if(FALSE) {
l_ply(names(gs),
      .fun = function(nm) {
        png(paste0(plots_dir, "/", nm, "-nUMIs.png"), width = 2 * 480, height = 2 * 480)
        print(gs[[nm]])
        d <- dev.off()
      })
}
```

```{r}
tbl <- acast(patient.df, patient ~ label)
tbl <- tbl[order(tbl[,1], tbl[,2], tbl[,3], decreasing=TRUE),]
expt.design <- as.data.frame(tbl)
expt.design <- apply(expt.design, 2, as.character)
expt.design <- cbind("Patient" = rownames(tbl), expt.design)
expt.design[expt.design == "0"] <- ""
png(paste0(plots_dir, "/tnbc-expt-design.png"), height = 0.5 * 480)
grid.table(expt.design)
d <- dev.off()

```



```{r}
json.path = "/projects/compsci/jgeorge/whitebr/tnbc/hov/SC2200259_9990/json/SC2200259-pyramid-fake.json"
json.type.info.path <- "/projects/chuang-lab/USERS/whitebr/hover_net/type_info.json"
tbl <- extract.cell.info.from.hovernet.output(json.path)[["df"]]
cell.info.tbl <- extract.hovernet.cell.info(json.type.info.path)
stbl <- merge(tbl, cell.info.tbl, by.x="type", by.y="id")
```


```{r}
suppressPackageStartupMessages(p_load(reticulate))
get.wsi.dimensions <- function(wsi.file) {
  openslide <- import("openslide")
  slide <- openslide$OpenSlide(wsi.file)
  dims <- unlist(slide$dimensions)
  return(dims)
}
```

```{r}
# get.wsi.dimensions("/projects/compsci/jgeorge/whitebr/tnbc/SC2200259_9990/img/SC2200259.tiff")
# get.wsi.dimensions("/projects/compsci/jgeorge/whitebr/tnbc/SC2200259_9990/img/hov/SC2200259-pyramid-fake.svs")
```


```{r}
# Map the centroids to spot row/columns
```


```{r}
# plot.features(filtered.objs[["SC2200259_9990"]], features=c("PTPRC"), include.hne=TRUE)
```



```{r}
stop("stop")
```

```{r}
# This is a plot for my R21
sample <- "SC2200259_9990" 
obj <- filtered.objs[[sample]]
DefaultAssay(obj) <- "Spatial"

#g0 <- plot.hne(obj)
#g2 <- plot.spatial(obj, features = c("EPCAM"), legend.name = "EPCAM", rescale.legend = FALSE) + theme(legend.text = element_text(size=10))
g <- plot.features(obj, features=c("EPCAM"), include.hne=TRUE)
png(paste0(plots_dir,"epcam-hne.png"),height=1*480, width=1*480)
print(g)
d <- dev.off()

```


```{r}
# Plot reads per spot (across samples)
cnt.tbl <- ldply(filtered.objs, .fun = function(obj) obj[[]][, c("nCount_Spatial"), drop=FALSE])
colnames(cnt.tbl)[1] <- "sample"
breaks <- 2^seq(from=log2(32), to=log2(131072), by=2)
g <- ggplot(data = cnt.tbl, aes(x = sample, y = nCount_Spatial)) + ylab("nUMIs") + geom_violin() + scale_y_continuous(trans='log2', breaks=breaks) + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1), text = element_text(size = 20))
png(paste0(plots_dir,"nUMIs-vs-sample.png"),height=1*480, width=2*480)
print(g)
d <- dev.off()
```


```{r}



# Find mixed spots including the two co-localized cell types A and B.
# Such spots should have fractional A content >= min.cell.type.a and similarly for B and
# a max fractional content of other cell types of max.other (i.e., A + B >= 1 - max.other)
# df is assumed created by format.rctd.output
find.mixed.spots <- function(df, cell.type.a, cell.type.b, min.cell.type.a = 0.3, min.cell.type.b = 0.3, max.other = 0.1) {
  flag.a <- df[, cell.type.a] >= min.cell.type.a
  flag.b <- df[, cell.type.b] >= min.cell.type.b
  flag.other <- 
    unlist(apply(df[, c(cell.type.a, cell.type.b)], 1,
           function(row) sum(row) >= (1 - max.other)))
  # print(table(flag.a))
  # print(table(flag.b))
  # print(table(flag.other))
  df[flag.a & flag.b & flag.other, , drop = FALSE]
}

# df.mixed <- find.mixed.spots(df, "iCAFs", "Epithelial", min.cell.type.a = 0.3, min.cell.type.b = 0.3, max.other = 0.25)

# For each spot having cell type A (at a proportion >= min.cell.type.A), find neighboring
# spots within a (square) radius having cell type B (at a proportion >= min.cell.type.b)
find.neighboring.spots <- function(df, cell.type.a, cell.type.b, min.cell.type.a = 0.3, min.cell.type.b = 0.3, radius = 2, exclude.spot.with.a = FALSE) {
  flag.a <- df[, cell.type.a] >= min.cell.type.a
  df.a <- df[flag.a, , drop = FALSE]  
  flag.b <- df[, cell.type.b] >= min.cell.type.b
  df.b <- df[flag.b, , drop = FALSE]  
  neighborhood <- as.data.frame(expand.grid(seq(-radius,radius),seq(-radius,radius)))
  colnames(neighborhood) <- c("x", "y")
  if(exclude.spot.with.a) {
    neighborhood <- subset(neighborhood, !((x == 0) & (y == 0)))
  }
  df.neighborhood <-
    apply(df.a[, c("x", "y")], 1, function(row) {
      data.frame(x = as.numeric(row[1]) + neighborhood$x, y = as.numeric(row[2]) + neighborhood$y)
    })
  df.neighborhood <- unique(do.call("rbind", df.neighborhood))
  df.neighborhood.b <- merge(df.neighborhood, df.b)
  m <- merge(df.a, df.neighborhood.b)
  return(m)
}

# find.neighboring.spots(df, "Epithelial", "myCAFs")
for(nm in names(rctds)) {
  df <- format.rctd.output(rctds[[nm]])
  print(nm)
  print(colSums(df[,1:20]))
  cat("\n")
}
indx <- 3
df <- format.rctd.output(rctds[[indx]])
obj <- filtered.objs[[indx]]
rctd <- rctds[[indx]]
mat <- Seurat::GetAssayData(obj, assay="Spatial")
common.spots <- intersect(rownames(df),colnames(mat))
mat <- mat[, common.spots]
df <- df[common.spots,]
library(edgeR)
colsms <- colSums(as.matrix(mat))
l.cpms <- cpm(as.matrix(mat), log = TRUE)
cpms <- cpm(as.matrix(mat), log = FALSE)
# plot(df[, c("Epithelial_Basal")] * df[, c("iCAFs")])
# plot(cpms["FGFR2",] + cpms["MYC",], df[, c("Epithelial_Basal")] * df[, c("iCAFs")])
plot(df[, c("Epithelial_Basal")] * df[, c("iCAFs")], cpms["FGFR2",] + cpms["FGF7",])
# scale by umis?
plot(df[, c("Epithelial_Basal_Cycling")] * df[, c("iCAFs")], cpms["FGFR2",] + cpms["FGF7",])
plot(pmin(df[, c("Epithelial_Basal_Cycling")], df[, c("iCAFs")]), cpms["BMP7",] + cpms["BMPR1B",])
plot(density(pmin(df[, c("Epithelial_Basal_Cycling")], df[, c("iCAFs")])))

# questions:
# impute?
# normalize by counts?
# spatial correlation?
# product / sum / min
# plot spatially
# what is depth of these ligands / receptors in published data
```

```{r}
l_ply(datasets, .parallel = FALSE,
        .fun = function(nm) {
          print(nm)
          md.df <- format.rctd.output(rctds[[nm]])
          md.df <- md.df[, !(colnames(md.df) %in% c("x", "y"))]
          write.table(md.df, file = paste0(analysis_dir, "/", nm, "-rctd.tsv"), row.names = TRUE, col.names = TRUE, quote = FALSE, sep = "\t")
        })
```





```{r}
# MISTy analysis
p_load(mistyR)
p_load(future)

# data manipulation
p_load(dplyr)
p_load(purrr)
p_load(distances)


plan(multisession)

sample.name <- "SC2200259_9990"
obj <- filtered.objs[[sample.name]]
# rctd.df <- format.rctd.output(rctds[[sample.name]])
rctd.df <- format.rctd.output_(rctds[[sample.name]])
rctd.df <- rctd.df[, !(colnames(rctd.df) %in% c("x", "y"))]
obj <- add.metadata.to.seurat.obj(obj, rctd.df)
p_load(sctransform)
sct.data <- vst(GetAssayData(
  object = obj,
  slot = "counts",
  assay = "Spatial"
),
verbosity = 0
)

colnames(rctd.df) <- make.names(colnames(rctd.df))
colnames(rctd.df) <- gsub(colnames(rctd.df), pattern="_", replacement=".")
obj[["SCT"]] <- CreateAssayObject(data = rbind(sct.data$y, t(rctd.df)))

seurat.vs <- obj

# Filtering genes that are expressed in at least 5% of spots

gene.expression <- GetAssayData(seurat.vs, assay = "SCT")
coverage <- rowSums(gene.expression > 0) / ncol(gene.expression)
slide.markers <- names(which(coverage >= 0.05))

slide.markers <- c("IGKC", colnames(rctd.df))

# Define assay for each view
view.assays <- list(
  "main" = "SCT",
  "para.igkc" = "SCT"
)

# Define features for each view
view.features <- list(
  "main" = slide.markers,
  "para.igkc" = slide.markers
)

# Define spatial context for each view
view.types <- list(
  "main" = "intra",
  "para.igkc" = "para"
)

# Define additional parameters (l in the case of paraview)
view.params <- list(
  "main" = NULL,
  "para.igkc" = 10
)

misty.out <- "vignette_model_seurat"

p_load(tidyverse)
setwd("/home/whitebr/local/gsl-2.5/lib/")
misty.results <- run_misty_seurat(
  visium.slide = seurat.vs,
  view.assays = view.assays,
  view.features = view.features,
  view.types = view.types,
  view.params = view.params,
  spot.ids = NULL, # Using the whole slide
  out.alias = misty.out
)
```

```{r}
res <-  collect_results(misty.results)
res %>% plot_improvement_stats("gain.R2")
res %>% plot_view_contributions()
res %>% plot_interaction_heatmap(view = "intra")
res$importances.aggregated %>% 
  filter(view == "intra", Target == "IGKC") %>%
  arrange(-Importance)
SpatialFeaturePlot(seurat.vs, features = c("IGKC", "Plasma.Cells"))
res %>% plot_interaction_heatmap(view = "para.igkc_10")
SpatialFeaturePlot(seurat.vs, features = c("IGKC", "Endothelial"))
SpatialFeaturePlot(seurat.vs, features = c("Plasma.Cells", "Endothelial"))
SpatialFeaturePlot(seurat.vs, features = c("iCAFs", "Myoepithelial"))
```




```{r}
if(FALSE) {
  g <- plot.biotypes.across.samples(filtered.objs)
  png(paste0(plots_dir,"read-proportion-biotype-vs-sample.png"),height=1*480, width=2*480)
  print(g)
  d <- dev.off()
}
```

```{r}
deltas = get.visium.spot.distance.separation(filtered.objs[["SC2200259_9990"]])
dx <- deltas[1]
dy <- deltas[2]
```

```{r}
scale <- 2
stbl$col <- unlist(lapply(stbl$centroid.x, function(x) (floor(x * scale / dx ) + 1 - 15)))
stbl$row <- unlist(lapply(stbl$centroid.y, function(y) (floor(y * scale / dy ) + 1 - 9)))
all.cell.types <- unique(stbl$label)
stbl$pos.id <- paste0(stbl$row, "-", stbl$col)

cnt.tbl <- acast(stbl[, c("pos.id", "label")], pos.id ~ label)
pct.tbl <- t(apply(cnt.tbl, 1, function(row) row / sum(row)))
cnt.tbl <- cbind(cnt.tbl, total = rowSums(cnt.tbl))
colnames(pct.tbl) <- paste0(colnames(pct.tbl), ".frac")
all.tbl <- rbind(reshape2::melt(cnt.tbl), reshape2::melt(pct.tbl))
colnames(all.tbl) <- c("pos.id", "label", "value")
mat <- ddply(all.tbl, .variables = c("pos.id"), .fun = function(df) { vec <- df$value; names(vec) <- df$label; vec})
mat$pos.id <- as.character(mat$pos.id)
mat$row <- unlist(lapply(mat$pos.id, function(str) as.numeric(strsplit(str, split="-")[[1]][1])))
mat$col <- unlist(lapply(mat$pos.id, function(str) as.numeric(strsplit(str, split="-")[[1]][2])))


```


```{r}
#g <- create.feature.strip.plot(obj, features = c("Epithelial", "Myeloid", "CD14", "CD2", "LY75"), order.by = c("Epithelial", "Myeloid"))
#g$g
#g <- create.feature.strip.plot(obj, features = c("Epithelial", "Myeloid", "TLR4", "CD163", "SIGLEC1"), order.by = c("Epithelial", "Myeloid"))
```

```{r}
# From Karolina:
# CD8, CD103 (ITGAE), and CXCL13 (T cells) are essential for treatment response
# CD8+CD103+ T cells derived from chemokines might orchestrate response to therapy
# sCD14+ (stromal macrophages): CD14+CD2+LY75+ high macrophages have improved survival relative to low 
# iCD14+ (intratumoral macrophages): CD14+TLR4+CD163+SIGLEC
genes <- unique(c("CD8A", "CD14", "CD2", "LY75", "TLR4", "CD163", "SIGLEC1", "PTPRC", "CD3E", "CD8A", "ITGAE", "CXCL13"))
for(obj in filtered.objs) {
  g <- plot.gene.expression.distribution.relative.to.quantiles(obj, genes)
  sample <- obj[[]]$orig.ident[1]
  # g <- add.title.to.plot(g, sample)
  png(paste0(plots_dir, "/", sample, "-myeloid-gene-histograms.png"))
  print(g)
  d <- dev.off()
}
```

```{r}
# Output Myeloid cell genes of interest to Karolina
l_ply(datasets,
      .fun = function(dataset) {
        file <- paste0(plots_dir, "/", "myeloid-genes-", dataset, ".png")
        png(file, width = 2 * 480, height = 1 * 480)
        # g <- plot.features(filtered.objs[[dataset]], features = c("Epithelial", "CD8..T.cells", "Myeloid", "CD14", "CD2", "LY75", "TLR4", "CD163", "SIGLEC1"), include.hne = TRUE, include.umi.cnts = TRUE, include.feature.cnts = TRUE)
        # sCD14+ (stromal macrophages): CD14+CD2+LY75+ high macrophages have improved survival relative to low 
        # iCD14+ (intratumoral macrophages): CD14+TLR4+CD163+SIGLEC
        g <- plot.features(filtered.objs[[dataset]], features = c("Epithelial", "CD8..T.cells", "CD8A", "Myeloid", "CD14", "CD2", "LY75", "TLR4", "CD163", "SIGLEC1"), feature.names = c("Epithelial Fraction", "CD8 T Fraction", "CD8A", "Myeloid Fraction", "CD14 (monocytes)", "CD2 (sCD14+)", "LY75 (sCD14+)", "TLR4 (iCD14+)", "CD163 (iCD14+)", "SIGLEC1 (iCD14+)"), include.hne = TRUE, include.umi.cnts = TRUE, include.feature.cnts = FALSE)
        g <- add.title.to.plot(g, dataset)
        print(g)
        d <- dev.off()
      })
```

```{r}
# Output T cell genes of interest to Karolina
l_ply(datasets,
      .fun = function(dataset) {
        file <- paste0(plots_dir, "/", "cd8-t-cell-genes-", dataset, ".png")
        png(file, width = 2 * 480, height = 1 * 480)
        # ITGAE = CD103
        g <- plot.features(filtered.objs[[dataset]], features = c("Epithelial", "CD8..T.cells", "PTPRC", "CD3E", "CD8A", "ITGAE", "CXCL13", "Myeloid"), feature.names = c("Epitethial Fraction", "CD8 T Fraction", "CD45 (pan-immune)", "CD3E (T cell)", "CD8A", "CD103", "CXCL13", "Myeloid Fraction"), include.hne = TRUE, include.umi.cnts = TRUE, include.feature.cnts = FALSE)
        g <- add.title.to.plot(g, dataset)
        print(g)
        d <- dev.off()
      })
```





```{r}
# To do:
# 1. Cluster within each replicate
# 2. Limit to epithelial clusters.
# 3. Find markers of epi
# 4. Do fgsea on msidb.
# See here: https://crazyhottommy.github.io/scRNA-seq-workshop-Fall-2019/scRNAseq_workshop_3.html

# 1. Define signature for pathways (ssGSEA?)
# 2. Overlap for some pathways -- in particular, immune related. Also show immune and epi plots.

```


```{r}
biological.replicates <-
  list("9990" = c("SC2200259_9990", "SC2200260_9990"),
       "7031" = c("SC2200261_7031", "SC2200262_7031"),
       "4700" = c("SC2200263_4700", "SC2200264_4700"),
       "2171" = c("SC2200265_2171", "SC2200266_2171"))
```

```{r}
run.pca.umap <- function(obj, n.pcs = 50, features = NULL) {
  DefaultAssay(obj) <- "SCT"
  reduction <- "pca"
  obj <- RunPCA(obj, features = features, verbose = FALSE, npcs=n.pcs)
  n.pcs <- min(20, ncol(obj@reductions[[1]]@cell.embeddings))
  obj <- FindNeighbors(obj, reduction = reduction, dims = 1:n.pcs)
  obj <- FindClusters(obj, verbose = FALSE)
  obj <- RunUMAP(obj, reduction = reduction, dims = 1:n.pcs)
  obj
}

run.umap.on.pca <- function(obj, dims = 1:50, features = NULL) {
  DefaultAssay(obj) <- "SCT"
  reduction <- "pca"
  obj <- FindNeighbors(obj, reduction = reduction, dims = dims)
  obj <- FindClusters(obj, verbose = FALSE)
  obj <- RunUMAP(obj, reduction = reduction, dims = dims)
  obj
}
```

```{r}
# Redo the above analysis restricted to epithelial cells. From a density plot, choose
# a cutoff of >0.6 to label epithelial cells.
epi.objs <-
  llply(filtered.objs,
        .fun = function(obj) {
          subset(x=obj, Epithelial > 0.8)
        })

# plot.features(epi.objs[[indx-1]], features=c("Epithelial"), include.hne=TRUE)
```

```{r}
bio.names <- c("9990", "4700", "2171")
nms <- names(biological.replicates[bio.names])
names(nms) <- nms
epi.only.bio.objs <-
  llply(nms,
        .fun = function(bio.repl) {
          tech.replicates <- biological.replicates[[bio.repl]]
          objs <- epi.objs[names(epi.objs) %in% tech.replicates]
          all.objs <- Reduce(merge, objs)
          Idents(all.objs) <- all.objs$orig.ident
          
          meta <- all.objs[[]]
          meta$row.name <- rownames(meta)
          meta$patient <- bio.repl
          rownames(meta) <- meta$row.name
          meta <- meta[, !(colnames(meta) %in% c("row.name"))]
          all.objs <- add.metadata.to.seurat.obj(all.objs, meta)
          
          all.objs <- apply.sctransform_(all.objs, use.v2 = TRUE)
          
          all.objs <- run.pca.umap(all.objs)
        })

epi.only.marker.tbls <-
  llply(epi.only.bio.objs,
        .fun = function(obj) {
          FindAllMarkers(obj, slot = "scale.data", assay = "SCT")
        })

suppressPackageStartupMessages(p_load(msigdbr))
suppressPackageStartupMessages(p_load(fgsea))

# Do gene set enrichment analysis against the hallmark gene sets from msigdb
m_df <- msigdbr(species = "Homo sapiens", category = "H")
fgsea_sets <- m_df %>% split(x = .$gene_symbol, f = .$gs_name)


hallmark.epi.only.res <-
  ldply(epi.only.marker.tbls,
        .fun = function(tbl) {
          ddply(tbl, .variables = c("cluster"),
                .fun = function(df) {
                  genes <- df %>% 
                    arrange(dplyr::desc(avg_diff), dplyr::desc(p_val)) %>%
                    dplyr::select(gene, avg_diff)
                  ranks <- tibble::deframe(genes)
                  fgseaRes <- fgsea(fgsea_sets, stats = ranks, nperm = 1000)
                  fgseaResTidy <- fgseaRes %>%
                    as_tibble() %>%
                    arrange(dplyr::desc(NES))
                  
                  res <- fgseaResTidy %>%
                    dplyr::select(-leadingEdge, -ES, -nMoreExtreme) %>% 
                    arrange(padj)
                  as.data.frame(res)
                })
        })
colnames(hallmark.epi.only.res)[1] <- "patient"
# working
```

```{r}
bio.names <- c("9990", "4700", "2171")
for(bio.name in bio.names) {
  rep1 <- biological.replicates[[bio.name]][1]
  rep2 <- biological.replicates[[bio.name]][2]

  p1 <- plot.hne(epi.objs[[rep1]])
  p1 <- p1 + ggtitle(rep1)
  p2 <- plot.hne(epi.objs[[rep2]])
  p2 <- p2 + ggtitle(rep2)
  
  p.top <- plot_grid(p1,p2,nrow=1)
  
  p3 <- SpatialFeaturePlot(epi.objs[[rep1]], features=c("Epithelial"))
  p4 <- SpatialFeaturePlot(epi.objs[[rep2]], features=c("Epithelial"))

  p.bottom <- plot_grid(p3, p4, nrow=1)
  g <- plot_grid(p.top, p.bottom, nrow=2)
  
  png(paste0(plots_dir, "/hne-vs-epi-pt-", bio.name, ".png"))
  print(g)
  d <- dev.off()
}
```

```{r}
all.epi.only.bio.objs <- merge.sctransform.pca.umap(epi.only.bio.objs)
```

```{r}
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
gg <- DimPlot(all.epi.only.bio.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette)
gg <- gg + ggtitle("")
png(paste0(plots_dir, "/epi-only-umap.png"))
print(gg)
d <- dev.off()
```


```{r}
bio.names <- c("9990", "4700", "2171")
for(bio.name in bio.names) {

  rep1 <- biological.replicates[[bio.name]][1]
  rep2 <- biological.replicates[[bio.name]][2]
  p1 <- plot.hne(epi.objs[[rep1]])
  p1 <- p1 + ggtitle(rep1)
  p2 <- plot.hne(epi.objs[[rep2]])
  p2 <- p2 + ggtitle(rep2)

  p.top <- plot_grid(p1,p2,nrow=1)

  p.bottom <- SpatialDimPlot(epi.only.bio.objs[[bio.name]])
  g <- plot_grid(p.top, p.bottom, nrow=2)
  png(paste0(plots_dir, "/hne-vs-cluster-pt-", bio.name, ".png"))
  print(g)
  d <- dev.off()
}
```


```{r}
hallmark.epi.only.res$id <- paste0(hallmark.epi.only.res$patient, "-", hallmark.epi.only.res$cluster)
# Only plot pathways that are significant in _some_ cluster
sig.pathways <- unique(subset(hallmark.epi.only.res, padj < 0.05)$pathway)
tmp <- subset(hallmark.epi.only.res, pathway %in% sig.pathways)
mat <- reshape2::dcast(tmp[, c("pathway", "id", "NES")], pathway ~ id)
rownames(mat) <- gsub(mat$pathway, pattern="HALLMARK_", replacement="")
mat <- mat[, !(colnames(mat) %in% c("pathway"))]
mat[is.na(mat)] <- 0
sig.mat <- reshape2::dcast(tmp[, c("pathway", "id", "padj")], pathway ~ id)
rownames(sig.mat) <- gsub(sig.mat$pathway, pattern="HALLMARK_", replacement="")
sig.mat <- sig.mat[, !(colnames(sig.mat) %in% c("pathway"))]
sig.mat[is.na(sig.mat)] <- 1

col.pt.ids <- unlist(lapply(colnames(mat), function(str) unlist(strsplit(str, split="-"))[1]))
colnames(mat) <- NULL
uniq.pts <- rev(unique(col.pt.ids))
pt_cols = viridis::viridis(n = length(uniq.pts),option = 'C')
names(pt_cols) <- uniq.pts

cell_fun = function(j, i, x, y, w, h, fill) {
  txt <- stars.pval(sig.mat[i,j])
  if(txt == ".") { txt <- ""}
  grid.text(txt, x, y - h/4)
}

png(paste0(plots_dir, "/epi-only-cluster-0.8-hallmark.png"), width = 2 * 480, height = 1  * 480)
Heatmap(as.matrix(mat), cell_fun = cell_fun, heatmap_legend_param = list(title = "NES"),
        row_names_gp = gpar(fontsize = 10), column_km = 2, row_km = 3,
        top_annotation = HeatmapAnnotation(patient = col.pt.ids, col = list(patient = pt_cols)))
d <- dev.off()
```
```{r}
obj <- filtered.objs[[1]]
obj <- epi.only.bio.objs[[2]]
# fgsea_sets$HALLMARK_INTERFERON_GAMMA_RESPONSE

sets <- 
  list("HALLMARK_APOPTOSIS" = "APOPTOSIS",
       "HALLMARK_INFLAMMATORY_RESPONSE" = "INFLAMMATORY_RESPONSE",
       "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" = "EMT",
       "HALLMARK_E2F_TARGETS" = "E2F_TARGETS",
       "HALLMARK_COAGULATION" = "COAGULATION",
       "HALLMARK_HYPOXIA" = "HYPOXIA",
       "HALLMARK_ANGIOGENESIS" = "ANGIOGENESIS",
       "HALLMARK_IL2_STAT5_SIGNALING" = "IL2_STAT5_SIGNALING",
       "HALLMARK_INTERFERON_ALPHA_RESPONSE" = "INTERFERON_ALPHA_RESPONSE",
       "HALLMARK_INTERFERON_GAMMA_RESPONSE" = "INTERFERON_GAMMA_RESPONSE",
       "HALLMARK_KRAS_SIGNALING_DN" = "KRAS_SIGNALING_DN",
       "HALLMARK_MTORC1_SIGNALING" = "MTORC1_SIGNALING",
       "HALLMARK_MYC_TARGETS_V1" = "MYC_TARGETS_V1",
       "HALLMARK_MYC_TARGETS_V2" = "MYC_TARGETS_V2",
       "HALLMARK_NOTCH_SIGNALING" = "NOTCH_SIGNALING")
sets <- rownames(mat)
names(sets) <- paste0("HALLMARK_", sets)
       

set.name <- "HALLMARK_APOPTOSIS"
short.set.name <- "APOP_PATH"
set.name <- "HALLMARK_INFLAMMATORY_RESPONSE"
short.set.name <- "INFLAM_PATH"
set.name <- "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION"
short.set.name <- "EMT_PATH"
set.name <- "HALLMARK_E2F_TARGETS"
short.set.name <- "E2F_PATH"
set.name <- "HALLMARK_COAGULATION"
short.set.name <- "COAG_PATH"
set.name <- "HALLMARK_HYPOXIA"
short.set.name <- "HYPOXIA_PATH"
set.name <- "HALLMARK_ANGIOGENESIS"
short.set.name <- "ANGIOGENESIS_PATH"

for(pt in names(epi.only.bio.objs)) {
  obj <- epi.only.bio.objs[[pt]]
  for(set.name in names(sets)) {
    short.set.name <- sets[[set.name]]
    set <- list(fgsea_sets[[set.name]][fgsea_sets[[set.name]] %in% rownames(obj)])
    obj <- AddModuleScore(obj, features = set, ctrl = 5, name = short.set.name, nbin=5)
    png(paste0(plots_dir, "/mod-score-", short.set.name, "-pt-", pt, ".png"))
    g <- SpatialFeaturePlot(obj, features=c(paste0(short.set.name, "1")))
    print(g)
    d <- dev.off()
  }
}

```


```{r}
# Exclude non-epi cells
epi.cell.cutoffs <- list("9990" = 0.75, "4700" = 0.75, "2171" = 0.75)
# Subset to clusters whose median RCTD epithelial proportion is
# above a threshold
nms <- names(epi.cell.cutoffs)
names(nms) <- nms
epi.objs <- 
  llply(nms,
        .fun = function(bio.repl) {
          obj <- bio.objs[[bio.repl]]
          med.epi.tbl <-
            ddply(obj[[]], .variables=c("seurat_clusters"), 
                  .fun = function(df) 
                    data.frame(med.epi = median(df$Epithelial)))
          med.epi.tbl <- 
            subset(med.epi.tbl, med.epi > epi.cutoffs[[bio.repl]])
          epi.bio.obj <- 
            subset(x = obj, subset = seurat_clusters %in% med.epi.tbl$seurat_clusters)
        })
  
```

```


```{r}
# Perform normalization, clustering across biological replicates
# Do this to separate out epithelial cells
nms <- names(biological.replicates)
names(nms) <- nms
bio.objs <-
  llply(nms,
        .fun = function(bio.repl) {
          tech.replicates <- biological.replicates[[bio.repl]]
          objs <- filtered.objs[names(filtered.objs) %in% tech.replicates]
          all.objs <- Reduce(merge, objs)
          Idents(all.objs) <- all.objs$orig.ident
          
          meta <- all.objs[[]]
          meta$row.name <- rownames(meta)
          meta$patient <- bio.repl
          rownames(meta) <- meta$row.name
          meta <- meta[, !(colnames(meta) %in% c("row.name"))]
          all.objs <- add.metadata.to.seurat.obj(all.objs, meta)
          
          all.objs <- apply.sctransform_(all.objs, use.v2 = TRUE)
          
          all.objs <- run.pca.umap(all.objs)
        })
```

```{r}
indx <- 1
gg <- DimPlot(bio.objs[[indx]], reduction = "umap", group.by = c("ident"))
gg <- FeaturePlot(bio.objs[[indx]], reduction = "umap", features = c("Epithelial"))
gg <- SpatialDimPlot(bio.objs[[indx]], group.by = c("seurat_clusters"))
VlnPlot(bio.objs[[indx]], features=c("Epithelial"), split.by=c("seurat_clusters")) + geom_boxplot() + geom_hline(yintercept = 0.6)
```


```{r}
merge.sctransform.pca.umap <- function(objs) {
  all.objs <- Reduce(merge, objs)
  Idents(all.objs) <- all.objs$orig.ident
  all.objs <- apply.sctransform_(all.objs, use.v2 = TRUE)
  all.objs <- run.pca.umap(all.objs)
  all.objs
}
```


```{r}
# We will exclude patient 7031, which has a high stromal content
epi.cutoffs <- list("9990" = 0.7, "4700" = 0.7, "2171" = 0.6)
# Subset to clusters whose median RCTD epithelial proportion is
# above a threshold
nms <- names(epi.cutoffs)
names(nms) <- nms
epi.bio.objs <- 
  llply(nms,
        .fun = function(bio.repl) {
          obj <- bio.objs[[bio.repl]]
          med.epi.tbl <-
            ddply(obj[[]], .variables=c("seurat_clusters"), 
                  .fun = function(df) 
                    data.frame(med.epi = median(df$Epithelial)))
          med.epi.tbl <- 
            subset(med.epi.tbl, med.epi > epi.cutoffs[[bio.repl]])
          epi.bio.obj <- 
            subset(x = obj, subset = seurat_clusters %in% med.epi.tbl$seurat_clusters)
        })
  
```

```{r}
epi.marker.tbls <-
  llply(epi.bio.objs,
        .fun = function(obj) {
          FindAllMarkers(obj, slot = "scale.data", assay = "SCT")
        })
```

```{r}
suppressPackageStartupMessages(p_load(msigdbr))
suppressPackageStartupMessages(p_load(fgsea))

# Do gene set enrichment analysis against the hallmark gene sets from msigdb
m_df <- msigdbr(species = "Homo sapiens", category = "H")
fgsea_sets <- m_df %>% split(x = .$gene_symbol, f = .$gs_name)


```

```{r}
hallmark.res <-
  ldply(epi.marker.tbls,
        .fun = function(tbl) {
          ddply(tbl, .variables = c("cluster"),
                .fun = function(df) {
                  genes <- df %>% 
                    arrange(dplyr::desc(avg_diff), dplyr::desc(p_val)) %>%
                    dplyr::select(gene, avg_diff)
                  ranks <- tibble::deframe(genes)
                  fgseaRes <- fgsea(fgsea_sets, stats = ranks, nperm = 1000)
                  fgseaResTidy <- fgseaRes %>%
                    as_tibble() %>%
                    arrange(dplyr::desc(NES))
                  
                  res <- fgseaResTidy %>%
                    dplyr::select(-leadingEdge, -ES, -nMoreExtreme) %>% 
                    arrange(padj)
                  as.data.frame(res)
                })
        })
colnames(hallmark.res)[1] <- "patient"
```

```{r}
hallmark.res$id <- paste0(hallmark.res$patient, "-", hallmark.res$cluster)
# Only plot pathways that are significant in _some_ cluster
sig.pathways <- unique(subset(hallmark.res, padj < 0.05)$pathway)
tmp <- subset(hallmark.res, pathway %in% sig.pathways)
mat <- reshape2::dcast(tmp[, c("pathway", "id", "NES")], pathway ~ id)
rownames(mat) <- gsub(mat$pathway, pattern="HALLMARK_", replacement="")
mat <- mat[, !(colnames(mat) %in% c("pathway"))]
sig.mat <- reshape2::dcast(tmp[, c("pathway", "id", "padj")], pathway ~ id)
rownames(sig.mat) <- gsub(sig.mat$pathway, pattern="HALLMARK_", replacement="")
sig.mat <- sig.mat[, !(colnames(sig.mat) %in% c("pathway"))]
```

```{r}
stop("stop")
```

```{r}
obj <- filtered.objs[[1]]
obj <- epi.bio.objs[[2]]
# fgsea_sets$HALLMARK_INTERFERON_GAMMA_RESPONSE
set <- list(fgsea_sets$HALLMARK_INTERFERON_GAMMA_RESPONSE[fgsea_sets$HALLMARK_INTERFERON_GAMMA_RESPONSE %in% rownames(obj)])
obj <- AddModuleScore(obj, features = set, ctrl = 5, name = "IFNG_PATH", nbin=5)
SpatialFeaturePlot(obj, features=c("IFNG_PATH1", "Epithelial"))

set <- list(fgsea_sets$HALLMARK_OXIDATIVE_PHOSPHORYLATION[fgsea_sets$HALLMARK_OXIDATIVE_PHOSPHORYLATION %in% rownames(obj)])

obj <- AddModuleScore(obj, features = set, ctrl = 5, name = "OXPHOS_PATH", nbin=5)
SpatialFeaturePlot(obj, features=c("OXPHOS_PATH1", "Epithelial"))




```


```{r}
col.pt.ids <- unlist(lapply(colnames(mat), function(str) unlist(strsplit(str, split="-"))[1]))
colnames(mat) <- NULL
uniq.pts <- rev(unique(col.pt.ids))
pt_cols = viridis::viridis(n = length(uniq.pts),option = 'C')
names(pt_cols) <- uniq.pts

cell_fun = function(j, i, x, y, w, h, fill) {
  txt <- stars.pval(sig.mat[i,j])
  if(txt == ".") { txt <- ""}
  grid.text(txt, x, y - h/4)
}

png(paste0(plots_dir, "/epi-cluster-hallmark.png"), width = 2 * 480, height = 1  * 480)
Heatmap(mat, cell_fun = cell_fun, heatmap_legend_param = list(title = "NES"),
        row_names_gp = gpar(fontsize = 10), column_km = 2, row_km = 3,
        top_annotation = HeatmapAnnotation(patient = col.pt.ids, col = list(patient = pt_cols)))
d <- dev.off()
```


```{r}
genes <-
  epi.marker.tbls[[1]] %>%
    dplyr::filter(cluster == "0") %>%
    arrange(dplyr::desc(avg_diff), dplyr::desc(p_val)) %>%
    dplyr::select(gene, avg_diff)

ranks <- tibble::deframe(genes)
```

```{r}
fgseaRes<- fgsea(fgsea_sets, stats = ranks, nperm = 1000)
```

```{r}
fgseaResTidy <- fgseaRes %>%
  as_tibble() %>%
  arrange(dplyr::desc(NES))


fgseaResTidy %>% 
  dplyr::select(-leadingEdge, -ES, -nMoreExtreme) %>% 
  arrange(padj) %>% 
  head()
```


```{r}
non.epi.bio.objs <- 
  llply(nms,
        .fun = function(bio.repl) {
          obj <- bio.objs[[bio.repl]]
          med.epi.tbl <-
            ddply(obj[[]], .variables=c("seurat_clusters"), 
                  .fun = function(df) 
                    data.frame(med.epi = median(df$Epithelial)))
          med.epi.tbl <- 
            subset(med.epi.tbl, med.epi < epi.cutoffs[[bio.repl]])
          non.epi.bio.obj <- 
            subset(x = obj, subset = seurat_clusters %in% med.epi.tbl$seurat_clusters)
        })
all.non.epi.bio.objs <- merge.sctransform.pca.umap(non.epi.bio.objs)
```


```{r}
all.epi.bio.objs <- merge.sctransform.pca.umap(epi.bio.objs)
```

```{r}
gg <- DimPlot(all.epi.bio.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette)
```

```{r}
gg <- DimPlot(all.non.epi.bio.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette)
```

```{r}
Idents(all.epi.bio.objs) <- "patient"
marker.tbl <- FindAllMarkers(all.epi.bio.objs, slot = "scale.data", assay = "SCT")
```

```{r}
Idents(all.non.epi.bio.objs) <- "patient"
non.epi.marker.tbl <- FindAllMarkers(all.non.epi.bio.objs, slot = "scale.data", assay = "SCT")
```

```{r}
Idents(all.non.epi.bio.objs) <- "orig.ident"
marker.tbl.2171 <- FindMarkers(all.non.epi.bio.objs, slot = "scale.data", assay = "SCT", ident.1 = "SC2200265_2171", ident.2 = "SC2200266_2171")
```


```{r}
obj <- all.epi.bio.objs

obj <- run.harmony.umap(obj, var = "patient")
gg <- DimPlot(obj, reduction = "harmony", group.by = c("orig.ident"), cols = cbbPalette)
```


```{r}
# Exclude any gene differentially expressed in the non-epithelial compartment
# from the variable epithelial genes and re-run PCA, etc. (which will use
# variable genes)
obj <- all.epi.bio.objs
#exclude <- non.epi.marker.tbl$gene
exclude <- c()
exclude <- unique(c(exclude,grep(rownames(obj), pattern="^MT-", value = TRUE)))
exclude <- unique(c(exclude,grep(rownames(obj), pattern="^RP[SL]", value = TRUE)))
obj <- obj[!(rownames(obj) %in% exclude),]
VariableFeatures(obj) <- VariableFeatures(obj)[!(VariableFeatures(obj) %in% exclude)]
# obj <- run.pca.umap(obj)
obj <- RunPCA(obj, npcs=20)
obj <- run.umap.on.pca(obj, dims=10:20)
gg <- DimPlot(obj, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette)
# gg <- DimPlot(obj, reduction = "pca", dims = c(3,4), group.by = c("orig.ident"), cols = cbbPalette)
# kruskal.test(weight ~ group, data = my_data)
```

```{r}
obj <- run.harmony.umap(obj, var = "patient")
gg <- DimPlot(obj, reduction = "harmony", group.by = c("orig.ident"), cols = cbbPalette)
```


```{r}
# To do:
# 1. Do non-epi?
# 2. kmeans of all.epi.bio.objs
# 3. What are markers of these different patient/clusters?
```


```{r}
# 2. UMAP -- color by sample. Is there a batch effect?
# 3. Subset to cancer. UMAP. Is there a batch effect?
# 4. Correct batch if necessary.
# 5. Cluster
```

```{r}
# Exclude 7031, which looks to have a lot of stromal
subset.objs <- filtered.objs[!grepl(names(filtered.objs), pattern="7031")]
all.subset.objs <- Reduce(merge, subset.objs)
Idents(all.subset.objs) <- all.subset.objs$orig.ident

VariableFeatures(all.subset.objs, assay="SCT") <- unique(unname(unlist(lapply(subset.objs, function(x) VariableFeatures(x, assay="SCT")))))
```


```{r}
run.harmony.umap <- function(obj, var = make.names("orig ident")) {
  DefaultAssay(obj) <- "SCT"
  obj <- RunHarmony(obj, group.by.vars = var)
  reduction <- "harmony"
  obj <- FindNeighbors(obj, reduction = reduction, dims = 1:20)
  obj <- FindClusters(obj, verbose = FALSE)
  obj <- RunUMAP(obj, reduction = reduction, dims = 1:20)
  obj
}
```


```{r}
all.subset.objs <- run.pca.umap(all.subset.objs)
```

```{r}
gg <- DimPlot(all.subset.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:6])
```

```{r}
all.subset.objs <- run.harmony.umap(all.subset.objs)
```

```{r}
gg <- DimPlot(all.subset.objs, reduction = "harmony", group.by = c("orig.ident"), cols = cbbPalette[1:6])
```


```{r}
all.filtered.objs <- Reduce(merge, filtered.objs)
Idents(all.filtered.objs) <- all.filtered.objs$orig.ident
DefaultAssay(all.filtered.objs) <- "SCT"
VariableFeatures(all.filtered.objs, assay="SCT") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="SCT")))))

```

```{r}
all.filtered.objs <- run.pca.umap(all.filtered.objs)
```

```{r}
objs.4700 <- subset(x = all.filtered.objs, subset = orig.ident %in% c("SC2200263_4700", "SC2200264_4700"))
gg <- DimPlot(objs.4700, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:2])
```

```{r}
gg <- FeaturePlot(all.filtered.objs, reduction = "umap", features = c("Stromal"))
```


```{r}
gg <- DimPlot(all.filtered.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8])
gg <- DimPlot(all.filtered.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8], split.by = c("orig.ident")) + facet_wrap(~ orig.ident)
gg <- FeaturePlot(objs.4700, reduction = "umap", features = c("Stromal"), split.by = c("orig.ident"))
gg <- FeaturePlot(all.filtered.objs, reduction = "umap", features = c("Epithelial"), split.by = c("orig.ident"), combine = F)
gg <- FeaturePlot(all.filtered.objs, reduction = "umap", features = c("Stromal"), split.by = c("orig.ident"), combine = F)
plot_grid(plotlist=gg, ncol=2)
```


```{r}
sc.all.filtered.objs <- all.filtered.objs
sc.all.filtered.objs <- apply.sctransform(list(sc.all.filtered.objs))[[1]]
sc.all.filtered.objs <- run.pca.umap(sc.all.filtered.objs)
```

```{r}
gg <- DimPlot(sc.all.filtered.objs, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8])
```

```{r}
meta <- sc.all.filtered.objs[[]]
meta$row.name <- rownames(meta)
meta$patient <- unlist(lapply(meta$orig.ident, function(str) strsplit(str,split="_")[[1]][2]))
rownames(meta) <- meta$row.name
meta <- meta[, !(colnames(meta) %in% c("row.name"))]
sc.all.filtered.objs <- add.metadata.to.seurat.obj(sc.all.filtered.objs, meta)
```

```{r}
sc.all.filtered.objs <- run.harmony.umap(sc.all.filtered.objs, var = "patient")
```

```{r}
all.filtered.objs <- run.harmony.umap(all.filtered.objs, var = "patient")
```

```{r}
gg <- DimPlot(sc.all.filtered.objs, reduction = "harmony", group.by = c("orig.ident"), cols = cbbPalette[1:8])
```

```{r}
gg <- DimPlot(all.filtered.objs, reduction = "harmony", group.by = c("orig.ident"), cols = cbbPalette[1:8])
```


```{r}
meta <- all.filtered.objs[[]]
meta$row.name <- rownames(meta)
meta$patient <- unlist(lapply(meta$orig.ident, function(str) strsplit(str,split="_")[[1]][2]))
rownames(meta) <- meta$row.name
meta <- meta[, !(colnames(meta) %in% c("row.name"))]
all.filtered.objs <- add.metadata.to.seurat.obj(all.filtered.objs, meta)
```


```{r}
obj.sct <- all.filtered.objs
DefaultAssay(obj.sct) <- "SCT"
VariableFeatures(obj.sct, assay="SCT") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="SCT")))))
obj.sct <- RunPCA(obj.sct, verbose = FALSE)
ElbowPlot(obj.sct, ndims = 40)
mat <- Seurat::GetAssayData(obj.sct, assay = "SCT")
pca <- obj.sct[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(as.matrix(mat)))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance
cumVarExplained <- cumsum(varExplained)


```

```{r}
reduction <- "pca"
obj.sct <- FindNeighbors(obj.sct, reduction = reduction, dims = 1:20)
obj.sct <- FindClusters(obj.sct, verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = reduction, dims = 1:20)
```

```{r}
# There is a batch effect without harmony
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
gg <- DimPlot(obj.sct, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8])
```

```{r}
# Run harmony
obj.sct <- RunHarmony(obj.sct, group.by.vars = make.names("orig ident"))
```

```{r}
reduction <- "harmony"
obj.sct <- FindNeighbors(obj.sct, reduction = reduction, dims = 1:20)
obj.sct <- FindClusters(obj.sct, verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = reduction, dims = 1:20)
```
```{r}
# Immune cells are clustered together
gg <- FeaturePlot(obj.sct, reduction = "umap", features = c("Immune"))
```

```{r}
# Redo the above analysis restricted to epithelial cells. From a density plot, choose
# a cutoff of >0.6 to label epithelial cells.
epi.objs <-
  llply(filtered.objs,
        .fun = function(obj) {
          subset(x=obj, Epithelial > 0.7)
        })
```

```{r}
epi.objs <- apply.sctransform(epi.objs)
```
```{r}
sv.epi.objs <- epi.objs
```

```{r}
# Exclude some MALAT1, MT, RP, and IGH genes from matrix and variable genes and run PCA
epi.objs <-
  llply(epi.objs, 
        .fun = function(obj) {
          obj <- obj[!grepl("MALAT1", rownames(obj)), ]
          
          # Filter Mitocondrial
          obj <- obj[!grepl("^MT-", rownames(obj)), ]
          
          # Filter Ribossomal gene (optional if that is a problem on your data) data.filt
          obj <- obj[ ! grepl('^RP[SL]', rownames(obj)), ]
          
          obj <- obj[ ! grepl('^IGH', rownames(obj)), ]
          obj <- obj[ ! grepl('^IGK', rownames(obj)), ]
          obj <- obj[ ! grepl('^IGL', rownames(obj)), ]
          
          vf.all <- VariableFeatures(obj)

          exclude <- grepl(vf.all, pattern="^MT-")
          exclude <- exclude | grepl(vf.all, pattern="^IGH")
          exclude <- exclude | grepl(vf.all, pattern="^IGL")
          exclude <- exclude | grepl(vf.all, pattern="^IGK")
          exclude <- exclude | grepl(vf.all, pattern="^RP[SL]")
          exclude <- exclude | ("MALAT1" %in% vf.all)
          
          vf.use <- vf.all[!exclude]
          vf.use <- vf.use[vf.use %in% rownames(obj)]
          VariableFeatures(obj) <- vf.use

          n.pcs <- pmin(length(vf.use), round(0.15*ncol(obj)), round(0.15*nrow(obj)), 200)
          obj <- RunPCA(obj, verbose = FALSE, npcs=n.pcs, features=vf.use)
          obj
        })
```

```{r}
# Run PCA and UMAP on filtered
filtered.objs <-
  llply(filtered.objs, 
        .fun = function(obj) {
          reduction <- "pca"
          n.pcs <- pmin(round(0.15*ncol(obj)), round(0.15*nrow(obj)), 200)
          obj <- RunPCA(obj, verbose = FALSE, npcs=n.pcs, features=vf.use)
          n.pcs <- min(20, ncol(obj@reductions[[1]]@cell.embeddings))
          obj <- FindNeighbors(obj, reduction = reduction, dims = 1:n.pcs)
          obj <- FindClusters(obj, verbose = FALSE)
          obj <- RunUMAP(obj, reduction = reduction, dims = 1:n.pcs)
          obj
        })
```


```{r}
# Run UMAP on everything
epi.objs <-
  llply(epi.objs, 
        .fun = function(obj) {
          reduction <- "pca"
          n.pcs <- min(20, ncol(obj@reductions[[1]]@cell.embeddings))
          obj <- FindNeighbors(obj, reduction = reduction, dims = 1:n.pcs)
          obj <- FindClusters(obj, verbose = FALSE)
          obj <- RunUMAP(obj, reduction = reduction, dims = 1:n.pcs)
          obj
        })

```

```{r}
# Find all markers for all clusters in all samples
markers.tbl <-
  ldply(epi.objs, .parallel = FALSE,
        .fun = function(obj) {
          print(obj[[]]$orig.ident[1])
          FindAllMarkers(obj, assay = "SCT", slot = "scale.data")
        })
colnames(markers.tbl)[1] <- "orig.ident"
```

```{r}
my.dup <- function(x) duplicated(x, fromLast=TRUE) | duplicated(x, fromLast=FALSE)
```

```{r}
# Only keep significant markers that are specific to a cluster (within a sample)
sig.markers.tbl <- subset(markers.tbl, p_val_adj < 0.05)
sig.markers.tbl <-
  ddply(sig.markers.tbl, .variables = c("orig.ident"),
        .fun = function(df) {
          df[!my.dup(df$gene),,drop=FALSE]
          
        })
# Count the number of markers in each cluster
sig.markers.tbl <-
  ddply(sig.markers.tbl, .variables = c("orig.ident", "cluster"),
        .fun = function(df) {
          df$cnt <- nrow(df)
          df
        })


```

```{r}
overlaps <-
  ddply(sig.markers.tbl[, c("orig.ident", "cluster", "gene")], .variables = c("orig.ident", "cluster"),
        .fun = function(df1) {
          ret <- ddply(sig.markers.tbl[, c("orig.ident", "cluster", "gene")], .variables = c("orig.ident", "cluster"),
                .fun = function(df2) {
                  sample1 <- df1[1,"orig.ident"]
                  sample2 <- df2[1,"orig.ident"]
                  cluster1 <- df1[1, "cluster"]
                  cluster2 <- df2[1, "cluster"]
                  n1 <- nrow(df1)
                  n2 <- nrow(df2)
                  n.int <- length(intersect(df1$gene, df2$gene))
                  data.frame(
                    # sample1 = sample1, cluster1 = cluster1, 
                    # sample2 = sample2, cluster2 = cluster2,
                             n1 = n1, n2 = n2, n.intersect = n.int)
                    
                })
          colnames(ret) <- c("sample2", "cluster2", "n1", "n2", "n.intersect")
          ret
        })
colnames(overlaps)[1:2] <- c("sample1", "cluster1")
```


```{r}
overlaps <- overlaps[order(overlaps$sample1, overlaps$cluster1),]
overlaps <- subset(overlaps, n1 > 5 & n2 > 5)
overlaps$id1 <- paste0(overlaps$sample1, "-", overlaps$cluster1)
overlaps$id2 <- paste0(overlaps$sample2, "-", overlaps$cluster2)
lvls <- unique(overlaps$id1)
overlaps$id1 <- factor(overlaps$id1, levels=lvls)
overlaps$id2 <- factor(overlaps$id2, levels=lvls)
overlaps$frac1 <- overlaps$n.intersect / overlaps$n1
flag <- overlaps$id1 == overlaps$id2
# overlaps[flag, "frac1"] <- 0
g <- ggplot() + geom_tile(data = overlaps, aes(x = id1, y = id2, fill = frac1))
```

```{r}
foo <- ddply(overlaps, .variables = c("sample1", "cluster1"), 
      .fun =function(df) {
        ddply(df[, c("sample2", "cluster2", "frac1")], .variables = c("sample2"),
              .fun = function(df.in) {
                df.in[which.max(df.in$frac1)[1],,drop=F]
              })
        })
foo <- subset(foo, !((sample1 == sample2) & (cluster1 == cluster2)))
ddply(foo, .variables = c("sample1", "cluster1"), .fun = function(df) data.frame(min = min(df$frac1)))
# Consider sankey plot
```


```{r}
mat <- acast(overlaps[, c("id1", "id2", "frac1")], id1 ~ id2)
col.cluster <- unlist(lapply(colnames(mat), function(str) unlist(strsplit(str, split="-"))[2]))
col.ids <- unlist(lapply(colnames(mat), function(str) unlist(strsplit(str, split="-"))[1]))
col.sample.ids <- unlist(lapply(col.ids, function(str) unlist(strsplit(str, split="_"))[1]))
col.pt.ids <- unlist(lapply(col.ids, function(str) unlist(strsplit(str, split="_"))[2]))
rownames(mat) <- NULL
colnames(mat) <- NULL
# Heatmap(mat, cluster_rows = FALSE, cluster_columns = FALSE, row_split = col.pt.ids, column_split = col.pt.ids)
uniq.samples <- rev(unique(col.sample.ids))
uniq.pts <- rev(unique(col.pt.ids))
# Heatmap(mat, cluster_rows = FALSE, cluster_columns = FALSE, row_split = col.pt.ids, column_split = col.pt.ids, top_annotation = HeatmapAnnotation(sample = col.sample.ids, patient = col.pt.ids), right_annotation = rowAnnotation(sample = col.sample.ids, patient = col.pt.ids))
sample_cols = viridis::viridis(n = length(uniq.samples),option = 'C')
names(sample_cols) <- uniq.samples

Heatmap(mat, cluster_rows = FALSE, cluster_columns = FALSE, row_split = col.pt.ids, column_split = col.pt.ids, 
        top_annotation = HeatmapAnnotation(#patient = anno_block(gp = gpar(fill = 2:(2+length(uniq.pts)-1)), labels = uniq.pts, labels_gp = gpar(col = "white", fontsize=10)),
                                           sample = col.sample.ids, col = list(sample = sample_cols)),
        right_annotation = rowAnnotation(#patient = anno_block(gp = gpar(fill = 2:(2+length(uniq.pts)-1)), labels = uniq.pts, labels_gp = gpar(col = "white", fontsize=10)),
                                         sample = col.sample.ids, col = list(sample = sample_cols), show_legend=c(F,F,F)))
        
                                                                                                                                                                      

```


```{r}
# Plots:
# 1. all data (rough overlapping of stroma)
# 2. 4700 (shows no batch effect)



# 1. analyze/merge replicates together (without harmony) -> cluster
# 2. define cluster signatures (top genes -> GSVA or singleR or sum -> cpm -> correlation)
# 3. plot clusters spatially (confirm with cluster label)
# 4. median scale?
# 5. how many sequencing lanes? i.e., where are batch effects?
```


```{r}
exclude.b.cells <- rownames(subset(obj[[]], seurat_clusters == 8))
keep.cells <- rownames(subset(obj[[]], seurat_clusters != 8))
```


```{r}
obj <- epi.objs[[1]]

obj <- obj[!grepl("MALAT1", rownames(obj)), ]

# Filter Mitocondrial
obj <- obj[!grepl("^MT-", rownames(obj)), ]

# Filter Ribossomal gene (optional if that is a problem on your data) data.filt
obj <- obj[ ! grepl('^RP[SL]', rownames(obj)), ]

obj <- obj[ ! grepl('^IGH', rownames(obj)), ]
obj <- obj[ ! grepl('^IGK', rownames(obj)), ]
obj <- obj[ ! grepl('^IGL', rownames(obj)), ]

obj <- subset(obj, cells = keep.cells)

vf.all <- VariableFeatures(obj)


exclude <- grepl(vf.all, pattern="^MT-")
exclude <- exclude | grepl(vf.all, pattern="^IGH")
exclude <- exclude | grepl(vf.all, pattern="^IGL")
exclude <- exclude | grepl(vf.all, pattern="^IGK")
vf.use <- vf.all[!exclude]
vf.use <- vf.use[vf.use %in% rownames(obj)]
VariableFeatures(obj) <- vf.use

obj <- RunPCA(obj, verbose = FALSE, npcs=200, features=vf.use)

reduction <- "pca"
obj <- FindNeighbors(obj, reduction = reduction, dims = 1:20)
obj <- FindClusters(obj, verbose = FALSE)
obj <- RunUMAP(obj, reduction = reduction, dims = 1:20)
# gg <- DimPlot(obj, reduction = "umap")
gg <- DimPlot(obj, reduction = "umap", group.by = c("ident"), label=TRUE, label.size=8)
#               cols = cbbPalette, label.size=8)
# obj.markers <- FindAllMarkers(obj)
obj.markers <- FindAllMarkers(obj, slot="scale.data", assay="SCT")
# head(subset(obj.markers, cluster==0),n=20)

# SpatialDimPlot(obj, group.by=c("seurat_clusters"))
# tnbc.markers <- c("AZGP1", "KRT19", "RPS11", "SFRP1", "EPCAM", "TACSTD2", "MGP", "SFN", "GATA3", "S100A8", "CHI3L1", "KRT15", "KRT14", "NPY1R", "ASPN", "PEG3", "SCGB2A2")
# Markers of heterogeneity:
# https://pubmed.ncbi.nlm.nih.gov/28911002/
# "EGFR", "CCND1", "MYC"
```


```{r}
all.epi.objs <- Reduce(merge, epi.objs)
Idents(all.epi.objs) <- all.epi.objs$orig.ident
```
```{r}
obj.sct <- all.epi.objs

DefaultAssay(obj.sct) <- "SCT"
VariableFeatures(obj.sct, assay="SCT") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="SCT")))))

vf.all <- VariableFeatures(obj.sct)
exclude <- grepl(vf.all, pattern="^MT-")
exclude <- exclude | grepl(vf.all, pattern="^IGH")
exclude <- exclude | grepl(vf.all, pattern="^IGL")
exclude <- exclude | grepl(vf.all, pattern="^IGK")
vf.use <- vf.all[!exclude]

obj.sct <- RunPCA(obj.sct, verbose = FALSE, npcs=200, features=vf.use)
ElbowPlot(obj.sct, ndims = 40)
mat <- Seurat::GetAssayData(obj.sct, assay = "SCT")
pca <- obj.sct[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(as.matrix(mat[vf.use,])))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance
cumVarExplained <- cumsum(varExplained)

```

```{r}
reduction <- "pca"
obj.sct <- FindNeighbors(obj.sct, reduction = reduction, dims = 1:20)
obj.sct <- FindClusters(obj.sct, verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = reduction, dims = 1:20)

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
gg <- DimPlot(obj.sct, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8])
```

```{r}
obj.sct <- RunHarmony(obj.sct, group.by.vars = make.names("orig ident"))

reduction <- "harmony"
obj.sct <- FindNeighbors(obj.sct, reduction = reduction, dims = 1:20)
obj.sct <- FindClusters(obj.sct, verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = reduction, dims = 1:20)

gg <- DimPlot(obj.sct, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8])
```
```{r}
n.pcs <- 5
obj.sct <- FindNeighbors(obj.sct, reduction = reduction, dims = 1:n.pcs)
obj.sct <- FindClusters(obj.sct, resolution = 3, verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = reduction, dims = 1:n.pcs, n.neighbors=30L, min.dist=0.001, spread=3)

gg <- DimPlot(obj.sct, reduction = "umap", group.by = c("orig.ident"), cols = cbbPalette[1:8])
# gg <- FeaturePlot(obj.sct, reduction = "umap", features=c("Epithelial"))
```


```{r}
sample <- "SC2200259_9990" 
obj <- filtered.objs[[sample]]
meta <- obj[[]]
meta$row.name <- rownames(meta)
meta <- merge(meta[, c("row.name", "row", "col")], mat, by = c("row", "col"), all.x=TRUE)
rownames(meta) <- meta$row.name
meta <- meta[, !(colnames(meta) %in% c("row.name"))]
meta[is.na(meta)] <- 0
obj <- add.metadata.to.seurat.obj(obj, meta)
obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = "^MT-")
plot.features(obj, features="connec.frac")
# plot.features(obj, features=c("connec.frac", "COL1A1"), include.hne = TRUE)
# plot.features(obj, features=c("inflam.frac", "PTPRC"), include.hne = TRUE)
# plot.features(obj, features=c("neopla.frac", "EPCAM"), include.hne = TRUE)
# plot.features(obj, features=c("necros.frac", "total"), include.hne = TRUE)
# plot(obj[[]]$connec.frac, log(obj[[]]$nCount_Spatial))
# plot.features(obj, features=c("nCount_Spatial", "nFeature_Spatial", "COL1A1", "total", "connec.frac"), include.hne = TRUE)
g <- plot.features(obj, features=c("nCount_Spatial", "nFeature_Spatial", "COL1A1", "total", "connec.frac", "Stromal"), feature.names = c("nUMIs", "nGenes", "COL1A1", "Total Hovernet cells", "Fraction Stromal Cells (Hovernet)", "Fraction Stromal Cells (RCTD)"), include.hne = TRUE)
g <- add.title.to.plot(g, paste0("Stromal signals (", sample, ")"))
png(paste0(plots_dir, "/stromal-signals-", sample, ".png"), width = 2 * 480, height = 1  * 480)
print(g)
d <- dev.off()

g <- plot.features(obj, features = c("neopla.frac", "EPCAM"), feature.names = c("Fraction Neoplastic Cells (Hovernet)", "EPCAM"), include.hne = TRUE)
g <- add.title.to.plot(g, paste0("Tumor signals (", sample, ")"))
png(paste0(plots_dir, "/tumor-signals-", sample, ".png"), width = 2 * 480, height = 1  * 480)
print(g)
d <- dev.off()

g <- plot.features(obj, features = c("necros.frac", "percent.mt", "HMGB1", "nCount_Spatial", "nFeature_Spatial", "total"), feature.names = c("Fraction Necrotic Cells (Hovernet)", "Percent MT", "HMGB1", "nUMIs", "nGenes", "Total Hovernet cells"), include.hne = TRUE)
g <- add.title.to.plot(g, paste0("Necrosis signals (", sample, ")"))
png(paste0(plots_dir, "/necrosis-signals-", sample, ".png"), width = 2 * 480, height = 1  * 480)
print(g)
d <- dev.off()

g <- plot.features(obj, features = c("PTPRC", "inflam.frac", "CD3E", "T_Cells", "CD19", "B_Cells"), feature.names = c("CD45 (pan-immue)", "Fraction Immune Cells (Hovernet)",  "CD3E (T cell)", "Fraction T Cells (RCTD)", "CD19 (B cell)", "Fraction B Cells (RCTD)"), include.hne = TRUE, nrow=2)
g <- add.title.to.plot(g, paste0("Immune signals (", sample, ")"))
png(paste0(plots_dir, "/immune-signals-", sample, ".png"), width = 2 * 480, height = 1  * 480)
print(g)
d <- dev.off()
```

```{r}

# Make plots of hne, stroma vs tumor, and individual genes in CD14+ spots
#sample <- "SC2200259_9990" 
#obj <- filtered.objs[[sample]]

df <- obj[[]]
df$status <- "tumor"
df[df$neopla.frac < 0.5,"status"] <- "stroma"

#df$status <- "other"
#df[df$CD8..T.cells > 0.01,"status"] <- "CD8T"
#df[df$Myeloid > 0.01,"status"] <- "myeloid"

df$status <- factor(df$status)
obj <- AddMetaData(obj, df[, "status", drop=FALSE])

expr <- GetAssayData(obj, assay="Spatial", slot="counts")
md <- obj[[]]
common <- intersect(colnames(expr), rownames(md))
expr <- expr[, common]
md <- md[common,]
# sCD14+ (stromal macrophages): CD14+CD2+LY75+ high macrophages have improved survival relative to low 
# iCD14+ (intratumoral macrophages): CD14+TLR4+CD163+SIGLEC
genes <- c( "EPCAM", "PTPRC", "CD14", "CD163","CD2", "LY75", "TLR4", "SIGLEC1")
names(genes) <- genes
df <- merge(md, t(expr[genes, ]), by = "row.names")

flag <- df[,"CD14"] > 0
df <- df[flag, ]
g <- ggplot(data = df, aes(x = status, y = SIGLEC1)) + geom_violin()

g0 <- plot.hne(obj)
g1 <- SpatialPlot(obj, group.by=c("status")) + theme(legend.text = element_text(size=10)) + guides(fill = guide_legend(override.aes = list(size = 5)))
plts <- llply(genes, .fun = function(gene) ggplot(data = df, aes_string(x = "status", y = gene)) + geom_boxplot() + theme(text = element_text(size = 20)))

gtot <- plot_grid(plotlist=c(list(g0), list(g1), plts), nrow=2)
png(paste0(plots_dir, "/", sample, "-tumor-vs-stroma-expression.png"), width = 3 * 480, height = 2 * 480)
print(gtot)
d <- dev.off()

g <- ggplot(data = df, aes(x = status, y = nCount_Spatial)) + geom_violin() + xlab("region") + ylab("nUMIs") + theme(text = element_text(size = 20))
png(paste0(plots_dir, "/", sample, "-umis-vs-region.png"), width = 2 * 480, height = 1 * 480)
gtot <- plot_grid(g0, g1, g, nrow=1, labels = "AUTO")
print(gtot)
d <- dev.off()
```


```{r}
# This requires SCT be run
if(FALSE) {
plot(density(as.numeric(GetAssayData(obj,slot="data",assay="SCT")["EPCAM",])))
plot(density(as.numeric(GetAssayData(obj,slot="counts",assay="SCT")["EPCAM",])))
plot(density(as.numeric(GetAssayData(obj,slot="scale.data",assay="SCT")["EPCAM",])))
plot(density(obj[[]]$neopla.frac))
plot(hist(obj[[]]$Epithelial))

vals <- list(
  "raw counts" = as.numeric(GetAssayData(obj,slot="counts",assay="Spatial")["EPCAM",]),
  "SCT (counts)" = as.numeric(GetAssayData(obj,slot="counts",assay="SCT")["EPCAM",]),
  "SCT (data)" = as.numeric(GetAssayData(obj,slot="data",assay="SCT")["EPCAM",]),
  "SCT (scale.data)" = as.numeric(GetAssayData(obj,slot="scale.data",assay="SCT")["EPCAM",]),
  "RCTD Epithelial Fraction" = obj[[]]$Epithelial,
  "Hovernet Neoplastic Fraction" = obj[[]]$neopla.frac)

nms <- names(vals)
names(nms) <- nms
plts <- 
  llply(nms,
        .fun = function(nm) {
          g <- ggplot(data = data.frame(val = vals[[nm]]), aes(x = val)) + geom_histogram()
          g <- g + ggtitle(nm)
          g <- g + xlab("EPCAM")
          g
        })
  
             

df <- obj[[]]
#df$status <- 0
#df[df$neopla.frac < 0.5,"status"] <- 1
df$status <- "tumor"
#df[df$neopla.frac < 0.5,"status"] <- "stroma"
df[df$Epithelial < 0.5,"status"] <- "stroma"
df$status <- factor(df$status)
obj <- AddMetaData(obj, df[, "status", drop=FALSE])
# plot.features(obj, features=c("status"), include.hne=TRUE)
# g <- SpatialPlot(obj, group.by=c("status")) + theme(text = element_text(size=20))
g1 <- SpatialPlot(obj, group.by=c("status")) + theme(legend.text = element_text(size=10)) + guides(fill = guide_legend(override.aes = list(size = 5))) + labs(fill = "RCTD\nPrediction")
g1 <- g1 + ggtitle("Stroma = RCTD Epithelial < 0.5")

df$status <- "tumor"
df[df$neopla.frac < 0.5,"status"] <- "stroma"
df$status <- factor(df$status)
obj <- AddMetaData(obj, df[, "status", drop=FALSE])

g2 <- SpatialPlot(obj, group.by=c("status")) + theme(legend.text = element_text(size=10)) + guides(fill = guide_legend(override.aes = list(size = 5)))
g2 <- g2 + ggtitle("Stroma = Hovernet Neoplastic Fraction < 0.5")

g0 <- plot.hne(obj)

gtot <- plot_grid(plotlist=c(plts, list(g0), list(g1), list(g2)), labels="AUTO")
png(paste0(plots_dir, "/tumor-signal-epcam-rctd-hov.png"), width = 2 * 480, height = 2  * 480)
print(gtot)
d <- dev.off()
}
```

```{r}
sample <- "SC2200259_9990" 
obj <- filtered.objs[[sample]]

df <- obj[[]]
df$status <- "Tumor"
df[df$Epithelial < 0.5,"status"] <- "Stroma"
df$status <- factor(df$status)
obj <- AddMetaData(obj, df[, "status", drop=FALSE])

DefaultAssay(obj) <- "Spatial"

#g1 <- SpatialPlot(obj, group.by=c("status")) + theme(legend.text = element_text(size=10)) + guides(fill = guide_legend(override.aes = list(size = 5))) + labs(fill = "RCTD\nPrediction")

g1 <- plot.spatial(obj, features = c("Epithelial"), legend.name = "RCTD\nEpithelial\nFraction", rescale.legend = FALSE)

g.stromal <- plot.spatial(obj, features = c("Stromal"), legend.name = "RCTD\nStromal\nFraction", rescale.legend = FALSE)

g2 <- plot.spatial(obj, features = c("EPCAM"), legend.name = "EPCAM", rescale.legend = FALSE) + theme(legend.text = element_text(size=10))
  

g3 <- plot.spatial(obj, features = c("PTPRC"), legend.name = "CD45", rescale.legend = FALSE) + theme(legend.text = element_text(size=10))

meta <- obj[[]]
meta$row.name <- rownames(meta)
meta <- merge(meta[, c("row.name", "row", "col")], mat, by = c("row", "col"), all.x=TRUE)
rownames(meta) <- meta$row.name
meta <- meta[, !(colnames(meta) %in% c("row.name"))]
meta[is.na(meta)] <- 0
obj <- add.metadata.to.seurat.obj(obj, meta)

g4 <- plot.spatial(obj, features = c("connec.frac"), legend.name = "Hover-Net\nStromal\nFraction", rescale.legend = FALSE)

g.vim <- plot.spatial(obj, features = c("VIM"), legend.name = "VIM", rescale.legend = FALSE)

g.immune <- plot.spatial(obj, features = c("Immune"), legend.name = "RCTD\nImmune\nFraction", rescale.legend = FALSE)

g0 <- plot.hne(obj, keep.invisible.legend = TRUE)

gtot <- plot_grid(NULL, g0, NULL, g2, g.vim, g3, g1, g.stromal, g.immune, nrow=3, labels=c("","a","","b","c","d","e","f","g"))
png(paste0(plots_dir, "/tumor-stromal-immune-markers-and-deconv.png"), width = 1.5 * 480, height = 1 * 480)
print(gtot)
d <- dev.off()

gtot <- plot_grid(g0, g2, g1, g3, nrow=2, labels="auto")
png(paste0(plots_dir, "/tumor-stromal-immune-signals.png"), width = 2 * 480, height = 1.5  * 480)
print(gtot)
d <- dev.off()

gtot <- plot_grid(g0, g4, nrow=1, labels="auto")
png(paste0(plots_dir, "/hovernet-stromal-signal.png"), width = 2 * 480, height = 0.75  * 480)
print(gtot)
d <- dev.off()
```

```{r}
gtot <- plot_grid(g0, g2, nrow=1, labels="AUTO")
png(paste0(plots_dir, "/hovernet-epcam-signal.png"), width = 2 * 480, height = 0.75  * 480)
print(gtot)
d <- dev.off()

pdf(paste0(plots_dir, "/hovernet-epcam-signal.pdf"), width = 2 * 480, height = 0.75  * 480)
print(gtot)
d <- dev.off()
```

```{r}
stop("stop")
```


```{r}
# Let's try to recapitulate interactions from 
# https://www.embopress.org/doi/full/10.15252/embj.2019104063
# (see Dataset EV3 and supp fig S4)
# which uses ligand-receptor pairs from Ramilowski 2015:
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4525178/
# See https://fantom.gsc.riken.jp/5/suppl/Ramilowski_et_al_2015/
# and specifically
# https://fantom.gsc.riken.jp/5/suppl/Ramilowski_et_al_2015/data/PairsLigRec.txt
# Subset PairsLigRec.txt to those in the above EV3 dataset
all.lr.df <- fread("PairsLigRec.txt")
tnbc.lr.df <- read.xlsx("Dataset_EV3.xlsx", sheet=1)
tnbc.lr.df <- merge(tnbc.lr.df, unique(all.lr.df[, c("Pair.Name", "Ligand.ApprovedSymbol", "Receptor.ApprovedSymbol")]), by.x = c("interaction"), by.y = c("Pair.Name"))

# Read in the receptor / ligand pairs highlighted in Fig 5 of the above paper
tnbc.fig5.lr.df <- read.xlsx("Wu_EMBOJ_Fig5.xlsx", sheet=1)
```

```{r}
# working
tnbc.lr.df$Ligand.ApprovedSymbol %in% rownames(Seurat::GetAssayData(obj, assay="Spatial"))
tnbc.lr.df$Receptor.ApprovedSymbol %in% rownames(Seurat::GetAssayData(obj, assay="Spatial"))

# to do:
# average expression of scaled data per cell type
```

```{r}
set_element_size <- 
function (p = NULL, element, g = ggplot2::ggplotGrob(p), file = NULL, 
    margin = unit(1, "mm"), width = unit(4, "cm"), height = unit(4, 
        "cm")) 
{
    panels <- grep(element, g$layout$name)
    panel_index_w <- unique(g$layout$l[panels])
    panel_index_h <- unique(g$layout$t[panels])
    nw <- length(panel_index_w)
    nh <- length(panel_index_h)
    g$widths[panel_index_w] <- rep(width, nw)
    g$heights[panel_index_h] <- rep(height, nh)
    if (!is.null(file)) {
        ggplot2::ggsave(file, g, width = grid::convertWidth(sum(g$widths) + 
            margin, unitTo = "in", valueOnly = TRUE), height = grid::convertHeight(sum(g$heights) + 
            margin, unitTo = "in", valueOnly = TRUE))
    }
    g
}

get_element_size <- 
function (p = NULL, element, g = ggplot2::ggplotGrob(p), file = NULL, 
    margin = unit(1, "mm"), width = unit(4, "cm"), height = unit(4, 
        "cm")) 
{
    panels <- grep(element, g$layout$name)
    panel_index_w <- unique(g$layout$l[panels])
    panel_index_h <- unique(g$layout$t[panels])
    nw <- length(panel_index_w)
    nh <- length(panel_index_h)
    return(list("widths" = g$widths[panel_index_w], "heights" = g$heights[panel_index_h]))
}

```


```{r}
plot.ligand.receptor <- function(rctd, pop.weights, expr, ligand.pop, receptor.pop, ligand.gene, receptor.gene, expr.legend.name = "CPM") {
  g1 <- plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(pop.weights)[, ligand.pop], size = 1, ylimit = c(0, max(pop.weights[,ligand.pop])))
  g1 <- g1 + theme_void() + scale_y_reverse()
  g1 <- g1 + ggtitle(paste0("Ligand cell type: ", ligand.pop))
  g1 <- g1 + labs(color="fraction")
  g2 <- plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(pop.weights)[, receptor.pop], size = 1, ylimit = c(0, max(pop.weights[,receptor.pop])))
  g2 <- g2 + theme_void() + scale_y_reverse()
  g2 <- g2 + ggtitle(paste0("Receptor cell type: ", receptor.pop))
  g2 <- g2 + labs(color="fraction")
  g3 <- plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(expr)[ligand.gene,], size = 1, ylimit = c(0, max(expr[ligand.gene,])))
  g3 <- g3 + theme_void() + scale_y_reverse()
  g3 <- g3 + ggtitle(paste0("Ligand: ", ligand.gene))
  g3 <- g3 + labs(color=expr.legend.name)
  g4 <- plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(expr)[receptor.gene,], size = 1, ylimit = c(0, max(expr[receptor.gene,])))
  g4 <- g4 + theme_void() + scale_y_reverse()
  g4 <- g4 + ggtitle(paste0("Receptor: ", receptor.gene))
  g4 <- g4 + labs(color=expr.legend.name)
  plot_grid(g1,g2,g3,g4, nrow=2)
}


```

```{r}
# g <- plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(pop.weights)[, pop], size = 1, ylimit = c(0, mx))
# g <- plot.population.weights(rctd, pop.weights, cell.types.to.plot, obj = obj, show.hne = TRUE, use.absolute.scale = TRUE)
```


```{r}
myRCTD <- rctds[[1]]
barcodes <- colnames(myRCTD@spatialRNA@counts)
weights <- myRCTD@results$weights
norm_weights <- normalize_weights(weights)
cell_types <- c("Epithelial_Basal_Cycling", "myCAFs", "iCAFs")
print(head(norm_weights[,cell_types])) # observe weight values
# plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(d)f[, pop]) 
plot_puck_continuous(myRCTD@spatialRNA, barcodes, norm_weights[,'Epithelial_Basal_Cycling'], 
                     ylimit = c(0,1), 
                     title ='plot of Epithelial_Basal_Cycling weights') 
max.pops <- apply(norm_weights,1,function(row) colnames(norm_weights)[which.max(row)])
#plot_class(myRCTD@spatialRNA, barcodes,factor(max.pops))

pop <- "Epithelial_Basal_Cycling"
plot_puck_continuous(rctd@spatialRNA, colnames(rctd@spatialRNA@counts), as.matrix(df)[, pop], size = 1, ylimit = c(0, max(df[,pop])))

plot.population <- function(rctd, pop) {
  weights <- rctd@results$weights
  barcodes <- colnames(rctd@spatialRNA@counts)
  norm_weights <- normalize_weights(weights)
  max.pops <- apply(norm_weights,1,function(row) colnames(norm_weights)[which.max(row)])
  pops <- rep("other", length(max.pops))
  names(pops) <- names(max.pops)
  pops[max.pops == pop] <- pop
  plot_class(rctd@spatialRNA, barcodes, factor(pops)) + scale_y_reverse()
  
}

plot.populations <- function(rctd, pop.list) {
  weights <- rctd@results$weights
  barcodes <- colnames(rctd@spatialRNA@counts)
  norm_weights <- normalize_weights(weights)
  max.pops <- apply(norm_weights,1,function(row) colnames(norm_weights)[which.max(row)])
  pops <- rep("other", length(max.pops))
  names(pops) <- names(max.pops)
  for(pop.name in names(pop.list)) {
    flag <- unlist(lapply(max.pops, function(x) x %in% pop.list[[pop.name]]))
    pops[flag] <- pop.name
  }
  plot_class(rctd@spatialRNA, barcodes, factor(pops)) + scale_y_reverse()
  
}

```


```{r}
# make.ligand.receptor.plots(rctds[[i]], filtered.objs.[[i]], tnbc.fig5.lr.df)

make.ligand.receptor.plots <- function(rctd, obj, lr.df, sample.name, output.dir) {
  library(edgeR)
  pop.weights <- format.rctd.output(rctd)
  mat <- Seurat::GetAssayData(obj, assay="Spatial")
  common.spots <- intersect(rownames(pop.weights),colnames(mat))
  mat <- mat[, common.spots]
  pop.weights <- pop.weights[common.spots,]
  expr <- cpm(as.matrix(mat), log = FALSE)
  flag <- ( lr.df$ligand %in% rownames(expr) ) & ( lr.df$receptor %in% rownames(expr) ) 
  lr.df <- lr.df[flag, ]
  for(i in 1:nrow(lr.df)) {
    ligand.pop <- lr.df[i, "ligand.cell.type"]
    receptor.pop <- lr.df[i, "receptor.cell.type"]
    ligand.gene <- lr.df[i, "ligand"]
    receptor.gene <- lr.df[i, "receptor"]
    title <- paste0(sample.name, ": ", ligand.gene, " (", ligand.pop, ") - ", receptor.gene, " (", receptor.pop, ")")
    print(title)
    g <- plot.ligand.receptor(rctd, pop.weights, expr, ligand.pop, receptor.pop, ligand.gene, receptor.gene)
    g <- add.title.to.plot(g, title) 
    file <- make.names(paste0("lr-",sample.name, "-",ligand.pop,"-",receptor.pop,"-",ligand.gene,"-",receptor.gene))
    file <- paste0(output.dir, "/", file, ".tif")
    png(file, width = 2 * 480)
    print(g)
    d <- dev.off()
  }
  
}

```

```{r}
calculate.ligand.receptor.interaction.spatial.correlation <- function(rctd, obj, lr.df) {
  library(edgeR)
  
  pop.weights <- format.rctd.output(rctd)
  pos <- obj[[]][, c("row", "col")]
  mat <- Seurat::GetAssayData(obj, assay="Spatial")

  common.spots <- intersect(rownames(pos), rownames(pop.weights))
  common.spots <- intersect(common.spots,colnames(mat))

  mat <- mat[, common.spots]
  pos <- pos[common.spots,]
  pop.weights <- pop.weights[common.spots,]

  expr <- cpm(as.matrix(mat), log = FALSE)
  #W <- 1/as.matrix(dist(pos))
  #diag(W) <- 0
  W <- gausskernel(pos,sigma=1)

  flag <- ( lr.df$ligand %in% rownames(expr) ) & ( lr.df$receptor %in% rownames(expr) ) 
  lr.df <- lr.df[flag, ]
  lr.df$bivar.morans.i <- NA
  p.vals <- 
    unlist(llply(1:nrow(lr.df), .parallel = TRUE,
                 .fun = function(i) {
    ligand.pop <- lr.df[i, "ligand.cell.type"]
    receptor.pop <- lr.df[i, "receptor.cell.type"]
    ligand.gene <- lr.df[i, "ligand"]
    receptor.gene <- lr.df[i, "receptor"]
    min.pop <- unlist(apply(pop.weights[, c(ligand.pop, receptor.pop)], 1, min))
    df <- data.frame(min.pop = min.pop, g1 = expr[ligand.gene,,drop=TRUE], g2 = expr[receptor.gene,,drop=TRUE])
    rownames(df) <- common.spots

    res1 <- BivariateMoransI(df[,c("min.pop","g1")], W)
    res2 <- BivariateMoransI(df[,c("min.pop","g2")], W)
    p.max <- max(res1$p.val["min.pop","g1"], res2$p.val["min.pop","g2"])
    p.max
                 }))
  lr.df$bivar.morans.i <- p.vals
  lr.df <- lr.df[order(lr.df$bivar.morans.i, decreasing=FALSE),]
  lr.df
}

calculate.population.spatial.correlation <- function(rctd, obj) {

  pop.weights <- format.rctd.output(rctd)
  pos <- obj[[]][, c("row", "col")]

  common.spots <- intersect(rownames(pos), rownames(pop.weights))

  pos <- pos[common.spots,]
  pop.weights <- pop.weights[common.spots,]

  W <- gausskernel(pos,sigma=2)

  cols <- colnames(pop.weights)
  cols <- cols[!(cols %in% c("x","y"))]
  df <- as.data.frame(t(combn(cols,2)))
  colnames(df) <- c("pop1", "pop2")
  flag <- df$pop1 != df$pop2
  df$pop1 <- as.character(df$pop1)
  df$pop2 <- as.character(df$pop2)
  df <- df[flag,]
  
  p.vals <- 
    unlist(llply(1:nrow(df), .parallel = TRUE,
                 .fun = function(i) {
    pop1 <- df[i, "pop1"]
    pop2 <- df[i, "pop2"]
    mat <- pop.weights[, c(pop1, pop2)]
    res <- BivariateMoransI(mat, W)
    res$p.val[pop1, pop2]
                 }))
  df$bivar.morans.i <- p.vals
  df <- df[order(df$bivar.morans.i, decreasing=FALSE),]
  df
}

```
g1 <- ggscatter(obj[[]], x = "nCount_Spatial", y = "percent.ribo",
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE # Add confidence interval
   )
```{r}
nms <- names(filtered.objs)
names(nms) <- nms
scor.file <- paste0(plots_dir, "/scor.csv")
if(!file.exists(scor.file)) {
scor <-
  ldply(nms,
        .fun = function(nm) {
          rctd <- rctds[[nm]]
          obj <- filtered.objs[[nm]]
          lr.df <- tnbc.fig5.lr.df
          calculate.ligand.receptor.interaction.spatial.correlation(rctd, obj, lr.df)
        })
colnames(scor)[1] <- "sample"
scor <- scor[order(scor$bivar.morans.i, decreasing=FALSE),]
write.table(file=scor.file, scor, sep=",", row.names=FALSE, col.names=TRUE, quote=FALSE)
}
scor <- read.table(scor.file, sep=",", header=TRUE)

```

```{r}
nms <- names(filtered.objs)
names(nms) <- nms
pop.file <- paste0(plots_dir, "/pop-scor.csv")
if(!file.exists(pop.file)) {
pop.scor <-
  ldply(nms,
        .fun = function(nm) {
          rctd <- rctds[[nm]]
          obj <- filtered.objs[[nm]]
          calculate.population.spatial.correlation(rctd, obj)
        })
colnames(pop.scor)[1] <- "sample"
pop.scor <- pop.scor[order(pop.scor$bivar.morans.i, decreasing=FALSE),]
write.table(file=pop.file, pop.scor, sep=",", row.names=FALSE, col.names=TRUE, quote=FALSE)
}
pop.scor <- read.table(pop.file, sep=",", header=TRUE)
```


```{r}
scor.meta <- ddply(scor, .variables = c("interaction", "ligand", "receptor", "ligand.cell.type", "receptor.cell.type"), .fun = function(df) data.frame(pval.max = max(df$bivar.morans.i)))
scor.meta <- scor.meta[order(scor.meta$pval.max, decreasing=FALSE),]
```

```{r}
pop.scor.meta <- ddply(pop.scor, .variables = c("pop1", "pop2"), .fun = function(df) data.frame(pval.max = max(df$bivar.morans.i)))
pop.scor.meta <- pop.scor.meta[order(pop.scor.meta$pval.max, decreasing=FALSE),]
```

```{r}

```


```{r}
# WORKING
bar <- (expr[c("MYC","ITGAE"),])
foo <- reshape2::melt(bar)
foo$Var2 <- factor(foo$Var2, levels = lvls)
ggplot(data = foo) + geom_col(aes(x = Var2, y = log2(value))) + facet_wrap(~Var1, scales="free")
ii<-do.call('order', as.data.frame(t(bar)))
bar <- bar[,ii]
lvls <- colnames(bar)
# TODO:
# 1. Strip plots (columns are spots) of: -- also add cancer and order spots by cancer, then myeloid, then CD14, then etc. 
# 1a. iCD14+ (CD14-TLR4-CD163-SIGLEC); sCD14+ (CD14-CD2-LY75)
# 1b. CD8+CD103+CXCL13+ T cells in tumor nests
# 3. Sort stroma vs cancer spots (whether cancer > 50%?) -- look at CD14/etc within these
# 4. Look for T cell siglling involving CXCL13 and either myeloid or cancer cells
# 5. Look for interactions with myeloid cells
# 6. Can we do de novo discovery? Previously was using those from publication.

features <- c("Epithelial", "Myeloid", "CD14", "CD2", "LY75", "TLR4", "CD163", "SIGLEC1")
order.by <- features
m <- create.feature.split.plot(obj, features, order.by)

# TODO:
genes <- unique(c("CD8A", "CD14", "CD2", "LY75", "TLR4", "CD163", "SIGLEC1", "PTPRC", "CD3E", "CD8A", "ITGAE", "CXCL13"))
                                                                  
# 1. Function that:
#    1a. Plots gene (row) boxplots (expr col)
#    1b. Plots density along with quintiles (bottom panel)
# 2. Function that does above over samples
# 3. Call on Karolina genes
# 4. Call on LR genes
# 5. Call on transcription factor genes
# 1. Compute all LR expressions in a sample
# 2. Try computing boxplot of all LR within a sample with quantiles
# 3. Compute median and ranges within sample
# 4. Concatenate across all samples
# 5. Output as table
# 3. 
# 1. Calculate bivariateMoran'sI between min(pop1,pop2), gene1 and min(pop1,pop2), gene2 and take max pvalue
# 2. Plot distribution of ligand-receptor pairs from pub relative to quintiles? FPKMs?

flag <- merged["Myeloid", ] > 0.2
tmp <- merged[, flag]
flag <- !(rownames(tmp) %in% c("Myeloid", "Epithelial"))
tmp[flag, ] <- t(apply(tmp[flag,], 1, "/", as.numeric(tmp["Myeloid",])))
m <- reshape2::melt(as.matrix(tmp))

  colnames(m) <- c("feature", "sample", "value")
  if(!is.null(order.by)) {
    tmp <- rbind(mat[rownames(mat) %in% order.by,], t(meta[, colnames(meta) %in% order.by]))
    order.by <- order.by[order.by %in% rownames(tmp)]
    tmp <- tmp[order.by,]
    ii <- do.call('order', as.data.frame(t(tmp)))
    lvls <- colnames(tmp)[ii] 
    m$sample <- factor(m$sample, levels = lvls)
    m$feature <- factor(m$feature, levels = rev(c(order.by, features[!(features %in% order.by)])))
  }
  g <- ggplot(data = m) + geom_col(aes(x = sample, y = value)) + facet_wrap(~feature, scales="free", ncol = 1)
  g <- g + ylab("") + xlab("") + theme(axis.ticks.x = element_blank(), axis.text.x = element_blank())
  
i <- 2
rctd <- rctds[[i]]
obj <- filtered.objs[[i]]
lr.df <- tnbc.fig5.lr.df

pop.weights <- format.rctd.output(rctd)
pos <- obj[[]][, c("row", "col")]
mat <- Seurat::GetAssayData(obj, assay="Spatial")

common.spots <- intersect(rownames(pos), rownames(pop.weights))
common.spots <- intersect(common.spots,colnames(mat))

mat <- mat[, common.spots]
pos <- pos[common.spots,]
pop.weights <- pop.weights[common.spots,]

expr <- cpm(as.matrix(mat), log = FALSE)
W <- 1/as.matrix(dist(pos))
diag(W) <- 0
W <- gausskernel(pos,sigma=1)

g1 <- "CXCL9"
g2 <- "CXCR3"
pop1 <- "Stromal"
pop2 <- "CD4+ T-cells"

g1 <- "BMP4"
g2 <- "BMPR1A"
pop1 <- "Stromal"
pop2 <- "Epithelial_Basal_Cycling"

min.pop <- unlist(apply(pop.weights[, c(pop1, pop2)], 1, min))
df <- data.frame(min.pop = min.pop, g1 = expr[g1,,drop=TRUE], g2 = expr[g2,,drop=TRUE])
rownames(df) <- common.spots

res1 <- BivariateMoransI(df[,c("min.pop","g1")], W)
res2 <- BivariateMoransI(df[,c("min.pop","g2")], W)
p.max <- max(res1$p.val["min.pop","g1"], res2$p.val["min.pop","g2"])

```


```{r}
for(i in 1:length(filtered.objs)) {
  sample.name <- names(filtered.objs)[i]
  rctd <- rctds[[i]]
  obj <- filtered.objs[[i]]
  lr.df <- tnbc.fig5.lr.df
  output.dir <- paste0(plots_dir, "/", "lr/", sample.name, "/")
  dir.create(output.dir, showWarnings = FALSE, recursive = TRUE)
  print(output.dir)
  # make.ligand.receptor.plots(rctd, obj, lr.df, sample.name, output.dir)
  
  pop.weights <- format.rctd.output(rctd)
  # cell.types.to.plot <- c("Epithelial", "T_Cells", "B_Cells", "Myeloid", "iCAFs", "myCAFs", "PVL", "Endothelial")
  cell.types.to.plot <- c("Epithelial", "T_Cells", "B_Cells", "Myeloid", "Stromal")
  g <- plot.population.weights(rctd, pop.weights, cell.types.to.plot, obj = obj, show.hne = TRUE, use.absolute.scale = TRUE)
  g <- add.title.to.plot(g, sample.name, size = 20)
  ncol <- ceiling(length(cell.types.to.plot)/3)
  output.dir <- paste0(plots_dir, "/", "pops/")
  dir.create(output.dir, showWarnings = FALSE, recursive = TRUE)
  png(paste0(output.dir, "/", sample.name, "-populations.png"), width = 3 * 480, height = ncol  * 480)
  print(g)
  d <- dev.off()
}
```

```{r}

```

```{r}

```


```{r}
all.pop.weights <- 
  ldply(rctds, format.rctd.output)
colnames(all.pop.weights)[1] <- "sample"
```

```{r}
g <- plot.population.fractions.across.samples(all.pop.weights, sample.col = "sample")
png(paste0(plots_dir, "/pops/", "population-distributions.png"), width = 2 * 480, height = 1  * 480)
print(g)
d <- dev.off()
```


```{r}
expressed.genes <- 
  llply(filtered.objs,
        .fun = function(obj) {
          mat <- Seurat::GetAssayData(obj, assay="Spatial")
          rownames(mat)[rowSums(mat) > 0]
        })

num.expressed.genes <-
  llply(expressed.genes, .fun = function(lst) length(lst))

num.expressed.genes <- data.frame(sample = names(num.expressed.genes), metric = "Total.Genes.Detected", value = as.vector(unlist(num.expressed.genes)))

```



```{r}
# Read in the spaceranger summaries
summary.tbl <- 
  ldply(datasets, 
        .fun = function(dataset) {
          # json.summary.file <- paste0(spaceranger_dirs[[dataset]], "/", "summary.json")
          # json.summary <- fromJSON(file=json.summary.file)
          # json.summary
          seq.metrics.file <- paste0(spaceranger_dirs[[dataset]], "/", "metrics_summary.csv")
          tbl <- read.table(seq.metrics.file, sep=",", header=TRUE, as.is=TRUE)
          #rename.cols <- list("Reads.Mapped.Confidently.to.Probe.Set" = "Reads.Mapped.Confidently.to.Genome", "Number.of.Panel.Genes....10.UMIs" = "Total.Genes.Detected")
          rename.cols <- list("Reads.Mapped.Confidently.to.Probe.Set" = "Reads.Mapped",
                              "Reads.Mapped.Confidently.to.Genome"= "Reads.Mapped" ,"Number.of.Panel.Genes....10.UMIs" = "Total.Genes.Detected")

          for(col in names(rename.cols)) {
            flag <- colnames(tbl) == col
            colnames(tbl)[flag] <- rename.cols[[col]]
          }
          tbl
        })
colnames(summary.tbl)[1] <- "sample"

# cols <- c("Total.Genes.Detected", "Reads.Mapped.Confidently.to.Genome",  "Number.of.Reads",  "Number.of.Spots.Under.Tissue", "Fraction.of.Spots.Under.Tissue", "Median.Genes.per.Spot", "Median.UMI.Counts.per.Spot", "Fraction.Reads.in.Spots.Under.Tissue", "Sequencing.Saturation")
#cols <- c("Reads.Mapped.Confidently.to.Genome",  "Number.of.Reads",  "Number.of.Spots.Under.Tissue", "Fraction.of.Spots.Under.Tissue", "Median.Genes.per.Spot", "Median.UMI.Counts.per.Spot", "Fraction.Reads.in.Spots.Under.Tissue", "Sequencing.Saturation")
cols <- c("Number.of.Reads", "Reads.Mapped", "Number.of.Spots.Under.Tissue", "Fraction.of.Spots.Under.Tissue", "Median.Genes.per.Spot", "Median.UMI.Counts.per.Spot", "Fraction.Reads.in.Spots.Under.Tissue", "Sequencing.Saturation")
summary.tbl <- summary.tbl[, c("sample", cols)]
summary.tbl <- melt(summary.tbl, id.vars = c("sample"))
colnames(summary.tbl) <- c("sample", "metric", "value")
summary.tbl <- rbind(summary.tbl, num.expressed.genes)
summary.tbl$metric <- gsub(summary.tbl$metric, pattern="\\.", replacement=" ")
cols <- gsub(cols, pattern="\\.", replacement=" ")
summary.tbl$metric <- factor(summary.tbl$metric, levels = c("Total Genes Detected",cols))
# summary.tbl$sample <- factor(summary.tbl$sample, levels=sample.lvls)
# summary.tbl <- merge(summary.tbl, dataset.metadata.df, by.x = "sample", by.y ="sample.name")


g <- ggplot(data = subset(summary.tbl, metric == "Fraction Reads in Spots Under Tissue"), aes(x = sample, y = value, fill=type)) + geom_bar(stat="identity")
# scale_fill_manual(values= unname(unlist(color_list)))
g <- g + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
g <- g + ylab("Fraction Reads in Spots\nUnder Tissue") + xlab("")
g <- g + theme(text = element_text(size = 20))
png(paste0(plots_dir, "/", analysis_file_prefix, "frac-reads-in-spots.png"))
print(g)
d <- dev.off()

g <- ggplot(data = subset(summary.tbl, !(metric %in% c("Fraction Reads in Spots Under Tissue", "Number of Spots Under Tissue"))), aes(x = sample, y = value, fill=type)) + geom_bar(stat="identity") + facet_wrap(~ metric, scales="free", labeller = label_wrap_gen())
  # scale_fill_manual(values= unname(unlist(color_list))) + facet_wrap(~ metric, scales="free", labeller = label_wrap_gen())
g <- g + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
g <- g + ylab("")
png(paste0(plots_dir, "/", analysis_file_prefix, "summary.png"), width = 2 * 480)
print(g)
d <- dev.off()
```

```{r}
# Perform normalization of counts using SCTransform (which fits a negative binomial to the count data)
# This adds a new assay "SCT" to the returned Seurat object. That assay has slots "counts" (the corrected counts),
# "data" (log1p(counts)), and "scale.data" (the "pearson residuals").
# These would be accessible via GetAssayData(filtered.objs[[1]], slot = "data", assay = "SCT")
# Running with default parameters (the most interesting of which look to be variable.features.n and/or variable.features.rv.th)
filtered.objs <-
  llply(filtered.objs,
        .fun = function(obj) {
          use.v2 <- TRUE
          if(use.v2) { 
            obj <- SCTransform(obj, assay = "Spatial", verbose = FALSE, vst.flavor = "v2", method = "glmGamPoi")
          } else {
            obj <- SCTransform(obj, assay = "Spatial", verbose = FALSE)
          }
          return(obj)
        })
```

```{r}
filtered.objs <-
  llply(filtered.objs,
        .fun = function(obj) {
          obj <- RunPCA(obj, assay = "SCT", verbose = FALSE)
          # obj <- FindNeighbors(obj, reduction = "pca", dims = 1:30)
          # obj <- FindClusters(obj, verbose = FALSE)
          # obj <- RunUMAP(obj, reduction = "pca", dims = 1:30)
          obj
        })
```

```{r}
nms <- names(filtered.objs)
names(nms) <- nms
elbow.plots <-
  llply(nms,
        .fun = function(nm) {
          obj <- filtered.objs[[nm]]
          g <- ElbowPlot(obj, ndims = 40)
          g <- g + ggtitle(nm)
          g
        })
plot_grid(plotlist=elbow.plots)
```


```{r}
filtered.objs <-
  llply(filtered.objs,
        .fun = function(obj) {
          # obj <- RunPCA(obj, assay = "SCT", verbose = FALSE)
          obj <- FindNeighbors(obj, reduction = "pca", dims = 1:30)
          obj <- FindClusters(obj, verbose = FALSE)
          obj <- RunUMAP(obj, reduction = "pca", dims = 1:30)
          obj
        })

```

```{r}
all.markers <-
  llply(nms,
        .fun = function(nm) {
          obj <- filtered.objs[[nm]]
          cat(paste0("Finding DE for ", nm))
          # FindAllMarkers(obj, test.use="DESeq2", slot="counts")
          FindAllMarkers(obj, assay="SCT", slot="data", test.use="wilcox")
        })
```

```{r}
marker.tbl <- ldply(all.markers)
colnames(marker.tbl)[1] <- "sample"
top.markers <-
  ddply(marker.tbl, .variables = c("sample", "cluster"),
        .fun = function(df) {
          o <- order(df$p_val, decreasing = FALSE)
          df <- df[o,]
          df[1:5,]
        })
```


```{r}
suppressPackageStartupMessages(p_load(msigdbr))
suppressPackageStartupMessages(p_load(fgsea))
```

```{r}
# See https://www.biostars.org/p/339934/
# Retrieve human H (hallmark) gene set
msigdbr_df <- msigdbr(species = "Homo sapiens", category = "H")

# Retrieve human KEGG gene set
# msigdbr_df <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG")

# fixing format to work with fgsea
pathwaysH = split(x = msigdbr_df$human_gene_symbol, f = msigdbr_df$gs_name)

all.fgsea <- 
  llply(all.markers, .parallel = TRUE,
        .fun = function(marker.tbl) {
          ddply(all.markers[[1]], .variables = c("cluster"), .parallel= FALSE,
                .fun = function(df) {
                  # run fgsea enrichment
                  o <- order(df$avg_log2FC)
                  df <- df[o,]
                  ranks <- df$avg_log2FC
                  names(ranks) <- df$gene
                  fgseaRes <- suppressWarnings(fgsea(pathways=pathwaysH, ranks, maxSize = 500))
                  o <- order(fgseaRes$pval, decreasing=FALSE)
                  fgseaRes <- fgseaRes[o,]
                  fgseaRes
                })
        })
                   

```


```{r}
all.filtered.objs <- Reduce(merge, filtered.objs)
Idents(all.filtered.objs) <- all.filtered.objs$orig.ident
```

```{r}
#ATR, BRCA, MYC, NRAS, Ki-67
# See https://pubmed.ncbi.nlm.nih.gov/30146351/
bl1.markers <- list("ATR" = "ATR", "BRCA1" = "BRCA1", "BRCA2" = "BRCA2", "MYC" = "MYC", "NRAS" = "NRAS", "MKI67" = "Ki-67")
bl2.markers <- list("EGFR" = "EGFR", "MET" = "MET", "EPHA2" = "EPHA2", "TP53" = "TP53")
im.markers <- list("JAK1" = "JAK1", "JAK2" = "JAK2", "STAT1" = "STAT1", "STAT4" = "STAT4", "IRF1" = "IRF1", "IRF7" = "IRF7", "IRF8" = "IRF8", "TNF" = "TNF")
m.markers <- list(Wnt, ALK, TGF-β)
msl.markers <- list(EGFR, PDGFR, ERK1/2, VEGFR2)
lar.markers <- list(AR, FOXA1, KRT18, XBP1)
```


```{r}
# SpatialFeaturePlot(all.filtered.objs, features = c("NRAS"), combine = FALSE)
# SpatialFeaturePlot(filtered.objs[[1]], features = names(im.markers), combine = TRUE)
## Genes upregulated in TNBC
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6513966/

# TNBC subtypes
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3127435/
# TNBC tumor subtypes display differential expression of both basal-like cytokeratins (KRT5, KRT6A, KRT6B, KRT14, KRT16, KRT17, KRT23, and KRT81) and luminal cytokeratins (KRT7, KRT8, KRT18, and KRT19)
DefaultAssay(all.filtered.objs) <- "SCT"
luminal.cytos <- c("KRT7", "KRT8", "KRT18", "KRT19")
basal.cytos <- c("KRT5", "KRT6A", "KRT6B", "KRT14", "KRT16", "KRT17", "KRT23", "KRT81")

# TNBC subyptes
# https://www.sciencedirect.com/science/article/pii/S0305737218300999

tnbc.markers <- c("AZGP1", "KRT19", "RPS11", "SFRP1", "EPCAM", "TACSTD2", "MGP", "SFN", "GATA3", "S100A8", "CHI3L1", "KRT15", "KRT14", "NPY1R", "ASPN", "PEG3", "SCGB2A2")
gene <- "PTPRC"
gene <- "CD79A"
gene <- "PDGFRA"
gene <- "CD68"
gene <- tnbc.markers[indx]

# apply(GetAssayData(all.filtered.objs, slot = "counts")[tnbc.markers,],1,max)
diff.tnbc.markers <- c("KRT19", "KRT15", "MGP")

plot.gene.overlays <- function(obj, gene) {
  mx <- max(GetAssayData(obj, slot = "counts")[gene,])
  plts <- SpatialFeaturePlot(obj, features = c(gene), combine = FALSE, slot = "counts")
  plts <- 
    llply(plts,
          .fun = function(g) {
            i <- which(sapply(g$scales$scales, function(x) 'fill' %in% x$aesthetics))
            g$scales$scales[[i]] <- NULL
            g <- g + scale_fill_gradientn(name = gene, colours = Seurat:::SpatialColors(n = 100), limits=c(0,mx))
            g
          })
  # plot_grid(plotlist = plts)
  g <- plot_grid(plotlist = plts)
  g
}

# DefaultAssay(all.filtered.objs) <- "Spatial"
#plts <- SpatialFeaturePlot(all.filtered.objs, features = c(gene), combine = FALSE, slot = "counts") 
#plot_grid(plotlist = plts)
g1 <- plot.gene.overlays(all.filtered.objs, "EPCAM")
#g1 <- add.title.to.plot(g1, "Basal TNBC")
g2 <- plot.gene.overlays(all.filtered.objs, "KRT19")
#g2 <- add.title.to.plot(g2, "Luminal TNBC")
g.tot <- plot_grid(g1,g2)
png(paste0(plots_dir,"tnbc-markers.png"), width = 2*480, height = 480)
print(g.tot)
d <- dev.off()

cell.markers <- list("CD8 T cells" = c("CD3E", "CD8A"), "macrophages" = c("CD68", "CD80"), "B cells" = c("CD79A", "MS4A1"), "fibroblasts" = c("PDGFRA", "FAP"))
plot.pair <- function(obj, genes) {
  gene1 <- genes[1]
  gene2 <- genes[2]
  g1 <- plot.gene.overlays(obj, gene1)
  g2 <- plot.gene.overlays(obj, gene2)
  g.tot <- plot_grid(g1,g2)
  g.tot
}

for(cell.type in names(cell.markers)) {
#cell.type <- "CD8 T cell"
g <- plot.pair(all.filtered.objs, cell.markers[[cell.type]])
g <- add.title.to.plot(g, cell.type)
png(paste0(plots_dir,"tnbc-", make.names(cell.type), "-markers.png"), width = 2*480, height = 480)
print(g)
d <- dev.off()
}

```


```{r}
stop("stop")
```


```{r}
# Also apply scran deconvolution-based normalization.
# scran uses SingleCellExperiment objects, so we will have to convert back and forth between SCEs and Seurat objects.
# See notes on interoperability here: https://satijalab.org/seurat/archive/v3.1/conversion_vignette.html

filtered.objs <-
  llply(filtered.objs, .parallel = FALSE,
        .fun = function(obj) {
          
          # Convert from a Seurat object to a SingleCellExperiment
          sce <- as.SingleCellExperiment(obj, assay = "Spatial")

          
          # Perform the scran normalization (see https://bioconductor.org/packages/devel/bioc/vignettes/scran/inst/doc/scran.html)
          clusters <- quickCluster(sce)
          sce <- computeSumFactors(sce, clusters=clusters)
          sce <- logNormCounts(sce)
          
          # Convert back from SingleCellExperiment to Seurat object. 
          tmp <- as.Seurat(sce, counts = "counts", data = "logcounts", assay="scran")
          obj[["scran"]] <- tmp[["scran"]]
          obj <- FindVariableFeatures(obj, assay="scran")
          obj
        })
          
```


```{r}
# Merge the unfiltered objs into one Seurat object
all.unfiltered.objs <- Reduce(merge, unfiltered.objs)
Idents(all.unfiltered.objs) <- all.unfiltered.objs$orig.ident
```


```{r}
all.filtered.objs <- Reduce(merge, filtered.objs)
Idents(all.filtered.objs) <- all.filtered.objs$orig.ident
```


```{r}
obj.sct <- all.filtered.objs
DefaultAssay(obj.sct) <- "SCT"
VariableFeatures(obj.sct, assay="SCT") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="SCT")))))
obj.sct <- RunPCA(obj.sct, verbose = FALSE)
ElbowPlot(obj.sct, ndims = 40)
mat <- Seurat::GetAssayData(obj.sct, assay = "SCT")
pca <- obj.sct[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(as.matrix(mat)))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance
cumVarExplained <- cumsum(varExplained)

obj.sct <- RunHarmony(obj.sct, group.by.vars = make.names("orig ident"))

# Pick the number of dimensions based on a flattening of the elbow plot
obj.sct <- FindNeighbors(obj.sct,reduction = "harmony", dims = 1:20)
obj.sct <- FindClusters(obj.sct, reduction = "harmony",verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = "harmony",dims = 1:20)
png(paste0(plots_dir,"clusters-merged-UMAP-sct.png"),width=1400,height =600)
obj.sct$Sample=obj.sct$orig.ident
obj.sct$Cluster=obj.sct@active.ident
gg <- DimPlot(obj.sct, reduction = "umap", group.by = c("Cluster","Sample")) 
print(gg)
d <- dev.off()

per_id_per_cluster_tbl<-table(obj.sct@meta.data$seurat_clusters, obj.sct@meta.data$orig.ident)

foo <- (melt(per_id_per_cluster_tbl))
colnames(foo) <- c("cluster", "sample", "cnt")

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

for(target_sample in biological.replicates) {
  bar <- subset(foo, grepl(sample, pattern=target_sample))
  bar <- subset(bar, cnt != 0)
  bar <- melt(acast(bar, cluster ~ sample, fill = 0))
  colnames(bar) <- c("cluster", "sample", "cnt")
  bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
  bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
  png(paste0(plots_dir,target_sample,"-cluster-proportions-sct.png"))
  g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
  g <- g + ylab("Fraction") + xlab("Cluster")
  g <- g + theme(text = element_text(size = 20))
  print(g)
  d <- dev.off()
}

bar <- subset(foo, cnt != 0)
bar <- melt(acast(bar, cluster ~ sample, fill = 0))
colnames(bar) <- c("cluster", "sample", "cnt")
bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
png(paste0(plots_dir,"all-cluster-proportions-sct.png"))
g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
g <- g + ylab("Fraction") + xlab("Cluster")
g <- g + theme(text = element_text(size = 20))
print(g)
d <- dev.off()

png(paste0(plots_dir,"all-cluster-proportions-heatmap-sct.png"),width=980, height=980)

color_list<-list('FFPE'="#d8b365" , 'Frozen'='#5ab4ac')
colSide <- as.vector(unlist(color_list[unlist(dataset.labels[levels(bar$sample)])]))

heatmap.2(acast(bar[, c("cluster","sample","frac")], cluster ~ sample),row_title="Cluster",column_title="Sample",heatmap_legend_param=list(title="Proportion"), ColSideColors = colSide ,col =rev( colorRampPalette(brewer.pal(8, "RdBu"))(25)),xlab="Cluster", ylab="Sample",margins=c(12,8),trace="none",lhei=c(1, 6),keysize=1,key.title="Proportion")
d <- dev.off()
```

```{r}

```


```{r}

ffpe.genes <- unique(Reduce(c,expressed.genes[ffpe.datasets]))
frozen.genes <- unique(Reduce(c,expressed.genes[frozen.datasets]))

x <- list(FFPE = ffpe.genes, frozen = frozen.genes)
g <- ggVennDiagram(x, label_size = 10, set_size = 10)
g <- g + theme(legend.position = "none") 
png(paste0(plots_dir,"ffpe-frozen-venn.png"))
print(g)
d <- dev.off()

# Get the genes that are only highly expressed in fresh frozen samples
# and output their "biotype" -- i.e., whether are coding genes, etc.
frozen.only <- frozen.genes[!(frozen.genes %in% ffpe.genes)]

library(biomaRt)
if (species_sample[1]=='Human'){
    gene_db = useMart("ensembl",dataset="hsapiens_gene_ensembl")
} else {
  gene_db = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
}

gb <- getBM(attributes=c("external_gene_name", "gene_biotype"),filters = c("external_gene_name"), values=frozen.only, mart=gene_db)

frozen.only.biotypes <- as.data.frame(table(gb$gene_biotype))
colnames(frozen.only.biotypes) <- c("biotype", "Freq")
o <- order(frozen.only.biotypes$Freq, decreasing=TRUE)
frozen.only.biotypes <- frozen.only.biotypes[o,]

png(paste0(plots_dir,"frozen-biotypes.png"))
grid.table(frozen.only.biotypes,rows=NULL)
d <- dev.off()

ffpe.only <- ffpe.genes[!(ffpe.genes %in% frozen.genes)]

gb <- getBM(attributes=c("external_gene_name", "gene_biotype"),filters = c("external_gene_name"), values=ffpe.only, mart=gene_db)

ffpe.only.biotypes <- as.data.frame(table(gb$gene_biotype))
colnames(ffpe.only.biotypes) <- c("biotype", "Freq")
o <- order(ffpe.only.biotypes$Freq, decreasing=TRUE)
ffpe.only.biotypes <- ffpe.only.biotypes[o,]

png(paste0(plots_dir,"ffpe-biotypes.png"))
grid.table(ffpe.only.biotypes,rows=NULL)
d <- dev.off()
```


```{r}
obj.scran <- all.filtered.objs
DefaultAssay(obj.scran) <- "scran"
obj.scran <- ScaleData(obj.scran, assay="scran")
VariableFeatures(obj.scran, assay="scran") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="scran")))))
obj.scran <- RunPCA(obj.scran, verbose = FALSE)
ElbowPlot(obj.scran, ndims = 40)
mat <- Seurat::GetAssayData(obj.scran, assay = "scran")
pca <- obj.scran[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(as.matrix(mat)))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance
cumVarExplained <- cumsum(varExplained)

obj.scran <- RunHarmony(obj.scran, group.by.vars = make.names("orig ident"))

obj.scran <- FindNeighbors(obj.scran,reduction = "harmony", dims = 1:20)
obj.scran <- FindClusters(obj.scran, reduction = "harmony", verbose = FALSE)
obj.scran <- RunUMAP(obj.scran, reduction = "harmony", dims = 1:20)
png(paste0(plots_dir,"clusters-merged-UMAP-scran.png"),width=1400,height =600)
obj.scran$Sample=obj.scran$orig.ident
obj.scran$Cluster=obj.scran@active.ident
gg <- DimPlot(obj.scran, reduction = "umap", group.by = c("Cluster","Sample")) 
print(gg)
d <- dev.off()

per_id_per_cluster_tbl<-table(obj.scran@meta.data$seurat_clusters, obj.scran@meta.data$orig.ident)

foo <- (melt(per_id_per_cluster_tbl))
colnames(foo) <- c("cluster", "sample", "cnt")

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

for(target_sample in biological.replicates) {
  bar <- subset(foo, grepl(sample, pattern=target_sample))
  bar <- subset(bar, cnt != 0)
  bar <- melt(acast(bar, cluster ~ sample, fill = 0))
  colnames(bar) <- c("cluster", "sample", "cnt")
  bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
  bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
  png(paste0(plots_dir,target_sample,"-cluster-proportions-scran.png"))
  g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
  g <- g + ylab("Fraction") + xlab("Cluster")
  g <- g + theme(text = element_text(size = 20))
  print(g)
  d <- dev.off()
}

bar <- subset(foo, cnt != 0)
bar <- melt(acast(bar, cluster ~ sample, fill = 0))
colnames(bar) <- c("cluster", "sample", "cnt")
bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
png(paste0(plots_dir,"all-cluster-proportions-scran.png"))
g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
g <- g + ylab("Fraction") + xlab("Cluster")
g <- g + theme(text = element_text(size = 20))
print(g)
d <- dev.off()

color_list<-list('FFPE'="#d8b365" , 'Frozen'='#5ab4ac')
colSide <- as.vector(unlist(color_list[unlist(dataset.labels[levels(bar$sample)])]))
par(cex.main=80)
png(paste0(plots_dir,"all-cluster-proportions-heatmap-scran.png"),width=680, height=980)
heatmap.2(acast(bar[, c("cluster","sample","frac")], cluster ~ sample),row_title="Cluster",column_title="Sample",heatmap_legend_param=list(title="Proportion"), ColSideColors = colSide ,col =rev( colorRampPalette(brewer.pal(8, "RdBu"))(25)),ylab="Cluster", xlab="Sample",margins=c(13,6),trace="none",lhei=c(1,8),keysize=2,key.title="Proportion",cexRow = 2.5,cexCol = 2.5) 
#title('ddddddd', cex.main = 15 * op[["cex.main"]])
 ## this will affect also legend title font size

#g<- g + title(main, cex.main = 1.5 * op[["cex.main"]])
d <- dev.off()

```



```{r}
# Add simplified sample names
sample.name.df <- data.frame(all.unfiltered.objs@meta.data[, c("orig.ident"), drop = FALSE])
sample.name.df$sample.name <- unlist(lapply(sample.name.df$orig.ident, function(str) unlist(strsplit(str, split="_"))[1]))
all.unfiltered.objs <- AddMetaData(all.unfiltered.objs, sample.name.df[, c("sample.name"), drop = FALSE])
```


```{r}

```


```{r}
# Plot the number of UMI counts per spot for unfiltered data (in files *unfiltered-spot-counts.png.png)
unfiltered.count.plots <-
  llply(datasets,
        .fun = function(dataset) {
          g <- plot.spatial(unfiltered.objs[[dataset]], features = c("nCount_Spatial"), legend.name = "UMI Count (k)")
          g <- g + theme(legend.text=element_text(size=15))
          g
        })
```

```{r}
# Plot the number of feature counts per spot for unfiltered data (in files *unfiltered-spot-features.png)
unfiltered.feature.plots <-
  llply(datasets,
        .fun = function(dataset) {
          g <- plot.spatial(unfiltered.objs[[dataset]], features = c("nFeature_Spatial"), legend.name = "Gene Count (k)")
          g <- g + theme(legend.text=element_text(size=15))
          g
        })
```

```{r}
# Plot the raw H&E images (in files *hne.png)
hne.plots <-
  llply(datasets,
        .fun = function(dataset) {
          g <- plot.hne(unfiltered.objs[[dataset]], keep.invisible.legend = TRUE)
          g
        })
```

```{r}
# Make plots of H&E and UMI and feature count overlays
for(pt in names(samples.by.patient)) {
  plts <- llply(samples.by.patient[[pt]],
                .fun = function(sample) {
                  g <- plot_grid(hne.plots[[sample]], unfiltered.count.plots[[sample]], unfiltered.feature.plots[[sample]], byrow=FALSE, ncol=3)
                  g <- add.title.to.plot(g, sample, size = 20)
                  g
                })
  g <- plot_grid(plotlist = plts, ncol=1)
  png(paste0(plots_dir, "/", analysis_file_prefix, pt, "-hne-umis-and-features.png"), width = 3 * 480, height = 2 * 480)
  print(g)
  d <- dev.off()
}
```


```{r}
#' Plot distribution of a response variable (e.g., UMI count) across spots relative to a dependent variable (e.g., tissue vs background spot status)
#' 
#' Create violin/boxplots showing distribution across spots of a user-specified response variable relative to a dependent variable and facted by sample.
#'
#' @param df A data.frame holding the response, depenndent, and faceting variables.
#' @param response.var The variable whose distribution over spots will be plotted.
#' @param facet.var The faceting variable.
#' @param dependent.var The variable that the response variable will be plotted as a function of.
#' @return A ggplot
plot.distributions.vs.cell.type <- function(df, response.var = "nCount_Spatial", facet.var = "sample.name", dependent.var = "spot_type") {
  lvls <- unique(df[, facet.var, drop=TRUE])
  df[,facet.var] <- factor(df[,facet.var], levels=lvls)
  stat.test <- df %>% group_by_at(facet.var) %>% wilcox_test(as.formula(paste0(response.var, " ~ ", dependent.var)), p.adjust.method = "none")
  stat.test$p.adj <- p.adjust(stat.test$p, method = "bonferroni")
  stat.test <- stat.test %>% add_xy_position(x = dependent.var)
  stat.test$y.position <- log2(stat.test$y.position)
  stat.test$label <- stars.pval(stat.test$p.adj)
  g <- ggviolin(df, dependent.var, response.var, facet.by = facet.var, add = "boxplot")
  g <- g + yscale("log2") + stat_pvalue_manual(stat.test, label="label") + xlab("Spot Type")
  g
}
```


```{r}
# Plot the distribution of UMI counts and gene counts over spots, as a function of whether those spots and within the tissue or outside of it (in file *count-and-feature-dist.png)
tbl <- all.unfiltered.objs@meta.data
tbl <- merge(tbl, dataset.metadata.df)
# tbl <- tbl[order(tbl$sample.name, tbl$type, tbl$sample.name, decreasing=TRUE),]
tbl$sample <- factor(tbl$sample, levels = sample.lvls)
tbl$sample.label <- paste0(tbl$sample.name, "\n", tbl$type)
g.cnt <- plot.distributions.vs.cell.type(tbl, response.var = "nCount_Spatial", facet.var = "sample.label") + ylab("UMI Counts (log2)")
g.feature <- plot.distributions.vs.cell.type(tbl, response.var = "nFeature_Spatial", facet.var = "sample.label") + ylab("Feature Counts (log2)")
g <- plot_grid(g.cnt, g.feature, nrow=1, labels = "AUTO")
png(paste0(plots_dir, "/", analysis_file_prefix, "count-and-feature-dist.png"), width = 2 * 480)
print(g)
d <- dev.off()

```
```{r}
#' Return count matrix from a Seurat object
#' 
#' @param obj A Seurat object.
#' @return A (sparse) matrix holding the spot counts (i.e., from the "counts" slot)
get.count.matrix <- function(obj) {
  as.matrix(x = GetAssayData(object = obj, assay = "Spatial", slot = "counts"))
}

#' Downsample each column of a matrix to a desired total count.
#'
#' A function that, independently for each column/cell, uses a multinomial distribution, parameterized 
#' by the frequency of each gene within that column/cell and the desired total count, to sample a vector of gene counts.
#' This is in contrast to related functions such as SampleUMI (in Seurat), which applies a binomial to each gene (!?)
#' and thus only approximates the desired total count, and downsampleMatrix (in DropletUtils), which downsamples to
#' a fraction of the original number of reads.
#'
#' @param expr_mat A (possibly sparse) matrix of counts.
#' @param tot_cnt The desired number of counts _for each column_
#' @return A downsample matrix
downsample.matrix <- function (expr_mat, tot_cnt) 
{
    down_sample <- function(x) {
        prob <- x/sum(x)
        return(rmultinom(1, tot_cnt, prob))
    }
    down_sampled_mat <- apply(expr_mat, 2, down_sample)
    return(down_sampled_mat)
}

#' Compute the number of expressed genes/features in a downsampled matrix.
#' 
#' A function to downsample the input matrix such that each cell/column has tot_cnt reads and
#' that reports the _median_ (across cells/columns) number of genes/features with non-zero counts.
#'
#' @param expr_mat A (possibly sparse) matrix of counts.
#' @param tot_cnt The desired number of counts _for each column_
#' @return The median (across cells/columns) number of genes/features with non-zero counts in the downsampled matrix.
compute.num.features.at.total.reads <- function(expr_mat, tot_cnt) {
  ds <- downsample.matrix(expr_mat, tot_cnt)
  return(median(colSums(ds > 0)))
}
```

```{r}
# Calculate the median number of reads (across spots) for each sample
# NB: using filtered data here
median.num.reads <- llply(filtered.objs, .fun = function(obj) median(colSums(get.count.matrix(obj))))
```

```{r}
# Perform a sensitivity analysis -- i.e., show the number of detected genes/features as a function
# of total UMI counts per spot. More precisely, we will plot the median (across spots) number of
# detected genes vs the median (across spots) UMI count.

all.downsample.cnts <- round(seq(from=0.1,to=0.9,by=0.1)*max(unlist(median.num.reads)))
names(all.downsample.cnts) <- all.downsample.cnts
downsample.feature.df <-
  ldply(filtered.objs,
        .parallel = FALSE,
        .fun = function(obj) {
          expr_mat <- get.count.matrix(obj)
          median.cnts <- median(colSums(expr_mat))
          downsample.cnts <- all.downsample.cnts[all.downsample.cnts < median.cnts]
          tbl <- 
            ldply(downsample.cnts, .parallel = TRUE,
                  .fun = function(tot_cnt) {
                    data.frame(num.features = compute.num.features.at.total.reads(expr_mat, tot_cnt))
                  })
          colnames(tbl)[1] <- "downsample.count"
          tbl
        })
colnames(downsample.feature.df)[1] <- "sample.name" 
downsample.feature.df$downsample.count <- as.numeric(downsample.feature.df$downsample.count)
downsample.feature.df <- merge(downsample.feature.df, dataset.metadata.df)
```

```{r}
# Plot the sensitivity (# of detected genes/features vs # of reads; in file *num-features-vs-num-downsampled-reads.png)
g <- ggplot(downsample.feature.df, aes(x = downsample.count, y = num.features, colour = sample.name, shape = type))
g <- g + geom_point()
g <- g + xlab("Spot Read Count (Median)") + ylab("Spot Feature Count (Median)")
g <- g + theme(text = element_text(size = 20))
png(paste0(plots_dir, "/", analysis_file_prefix, "num-features-vs-num-downsampled-reads.png"))
print(g)
d <- dev.off()
            
```


```{r}
#' Return most highly-expressed genes
#' 
#' A function to return the most highly-expressed genes (i.e., those with highest value) from a matrix.
#'
#' @param mat A (sparse) matrix.
#' @param n.top The number of genes to return.
#' @param assay The assay from which to access the gene exprssion/values in the Seurat object.
#' @param slot The slot in the assay form which to access the gene expression/values.
#' @return A vector of the highest-expressed genes.
get.top.genes.matrix <- function(mat, n.top = 20, assay = "Spatial", slot = "data") {
  rs <- rowSums(mat)
  rs <- rs[order(rs, decreasing=TRUE)]
  top.genes <- names(rs)[1:n.top]
  top.genes
}

#' Return most highly-expressed genes
#' 
#' A function to return the most highly-expressed genes (i.e., those with highest value) from a Seurat assay.
#'
#' @param obj A Seurat object.
#' @param n.top The number of genes to return.
#' @param assay The assay from which to access the gene exprssion/values in the Seurat object.
#' @param slot The slot in the assay form which to access the gene expression/values.
#' @return A vector of the highest-expressed genes.
get.top.genes <- function(obj, n.top = 20, assay = "Spatial", slot = "data") {
  mat <- GetAssayData(obj, assay = assay, slot = slot)
  get.top.genes.matrix(mat, n.top = n.top, assay = assay, slot = slot)
}

#' Return data subsetted by spot tissue status
#' 
#' A function to return the subset of the data corresponding to spots that are (or are not) in the tissue
#'
#' @param obj A Seurat object.
#' @param tissue.val Spots with tissue.val for the tissue.col metadata field will be retained.
#' @param tissue.col The metadata column of the Seurat object holding the tissue status
#' @param assay The assay from which to access the gene exprssion/values in the Seurat object.
#' @param slot The slot in the assay form which to access the gene expression/values.
#' @return A (sparse) matrix of spots that are (or are not) in tissue
subset.matrix.based.on.tissue.status <- function(obj, tissue.val, tissue.col = "tissue", assay = "Spatial", slot = "data") {
  cell.subset <- rownames((obj@meta.data)[(obj@meta.data)[,tissue.col] == tissue.val,])
  mat <- GetAssayData(obj, assay = assay, slot = slot)
  mat[,cell.subset]
}
```

```{r}

```


```{r}
# Get the most prevalent genes expressed in the background ...
top.genes.background <-
  llply(datasets,
        .fun = function(data.set) {
          obj <- unfiltered.objs[[data.set]]
          mat <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 0, assay = "Spatial", slot = "counts"))
          mat <- sweep(mat, 2, colSums(mat), "/")
          top.genes <- get.top.genes.matrix(mat, n.top = 20)
          top.genes
        })

# ... and in the tissue
top.genes.tissue <-
  llply(datasets,
        .fun = function(data.set) {
          obj <- unfiltered.objs[[data.set]]
          mat <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          mat <- sweep(mat, 2, colSums(mat), "/")
          top.genes <- get.top.genes.matrix(mat, n.top = 20)
          top.genes
        })

```

```{r}
# Find genes that are common between the (union of) background genes and the (union of) tissue genes
all.background.genes <- unique(Reduce("c", top.genes.background))
all.tissue.genes <- unique(Reduce("c", top.genes.tissue))
common.genes <- intersect(all.background.genes, all.tissue.genes)

intersect.background.genes <- unique(Reduce("intersect", top.genes.background))
intersect.tissue.genes <- unique(Reduce("intersect", top.genes.tissue))


flag <- dataset.labels == "FFPE"
ffpe.background.genes <- unique(Reduce("c", top.genes.background[flag]))
ffpe.tissue.genes <- unique(Reduce("c", top.genes.tissue[flag]))
common.ffpe.genes <- intersect(ffpe.background.genes, ffpe.tissue.genes)
intersect.tissue.ffpe.genes <- unique(Reduce("intersect", top.genes.tissue[flag]))

```


```{r}
```


```{r}
# Create plots showing the top 20 most prevalent genes in the background -- highlighting (in bold) the
# genes that are common to the background and tissue
top.genes.background.plts <-
  llply(datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          background.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 0, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(background.sub.matrix, n.top = 20, highlight.genes = intersect.background.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.background.plts)
g.all <- add.title.to.plot(g.all, "Background Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-background-spot.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

# Do the same for spots in the tissue
top.genes.tissue.plts <-
  llply(datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          tissue.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(tissue.sub.matrix, n.top = 20, highlight.genes = intersect.tissue.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.tissue.plts)
g.all <- add.title.to.plot(g.all, "Tissue Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-tissue-spot.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

# Repeat both of the above, but only for FFPE
# Create plots showing the top 20 most prevalent genes in the background -- highlighting (in bold) the
# genes that are common to the background and tissue
top.genes.background.ffpe.plts <-
  llply(ffpe.datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          background.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 0, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(background.sub.matrix, n.top = 20, highlight.genes = common.ffpe.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.background.ffpe.plts)
g.all <- add.title.to.plot(g.all, "Background Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-background-spot-ffpe-only.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

# Do the same for spots in the tissue
top.genes.tissue.ffpe.plts <-
  llply(ffpe.datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          tissue.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(tissue.sub.matrix, n.top = 20, highlight.genes = common.ffpe.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.tissue.ffpe.plts)
g.all <- add.title.to.plot(g.all, "Tissue Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-tissue-spot-ffpe-only.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

top.genes.intersect.tissue.ffpe.plts <-
  llply(ffpe.datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          tissue.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(tissue.sub.matrix, n.top = 20, highlight.genes = intersect.tissue.ffpe.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.intersect.tissue.ffpe.plts)
g.all <- add.title.to.plot(g.all, "Tissue Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-tissue-spot-intersect-ffpe-only.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()



```


```{r}
mylist_qval<-list()
mylist_top50_LLR<-list()
mylist_top100_LLR<-list()
for (i in names(long.dataset.names)){
  r<-read.csv(file = paste0(base_dir, "/automatic_analysis/results/",i,"/stSpatialDE.csv"), header = TRUE, as.is = TRUE, row.names = 1)
  r  <-r[r$qval==0,]
  mm <-sort(r$LLR,decreasing= TRUE,index.return = TRUE)
  
  mylist_qval[[ i ]]<-r$g.1
  mylist_top50_LLR[[ i ]]<-r$g.1[mm$ix[1:50]]
  mylist_top100_LLR[[ i ]]<-r$g.1[mm$ix[1:100]]
}
dictionary_terms<-c(unlist(unique(dataset.labels)),unlist(biological.replicates),"")
for (temp in dictionary_terms){
temp_list1 <- list()
temp_list2 <- list()
temp_list3 <- list()

#temp<-dictionary_terms[1]
if ((temp==dictionary_terms[1]|temp==dictionary_terms[2])&(length(mylist_qval[dataset.labels==temp])<=4 & length(mylist_qval[dataset.labels==temp])>=2)){
  temp_list1<-mylist_qval[dataset.labels==temp]
  temp_list2<-mylist_top50_LLR[dataset.labels==temp]
  temp_list3<-mylist_top100_LLR[dataset.labels==temp]
}else if((temp==dictionary_terms[3] | temp==dictionary_terms[4]) & (length(mylist_qval[dataset.labels==temp]) <=4 & length(mylist_qval[dataset.labels==temp])>=2)) {
  temp_list1<-mylist_qval[grepl(datasets, pattern=temp)]
  temp_list2<-mylist_top50_LLR[grepl(datasets, pattern=temp)]
  temp_list3<-mylist_top100_LLR[grepl(datasets, pattern=temp)]
}else if (temp=="" & ( length(mylist_qval)<=4 & length(mylist_qval)>2)){
  temp_list1<-mylist_qval
  temp_list2<-mylist_top50_LLR
  temp_list3<-mylist_top100_LLR
}
if (length(temp_list1)!=0){
  print(temp)
g <- ggVennDiagram(temp_list1)
g <- g + ggtitle(paste0("Spatially Differentially Expressed genes\n with 0 p-value in ",curr_datatypes, " ",temp)) 
g <- g + theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
g <- g + scale_x_continuous(expand = expansion(mult = .2))
png(paste0(plots_dir, "/", analysis_file_prefix, "venn_SpatialDE_pval_", temp,".png"),width = 480, height = 480)
print(g)
d <- dev.off()

g <- ggVennDiagram(temp_list2)
g <- g + ggtitle(paste0("Top 50 Spatially Differentially Expressed \ngenes  in ",curr_datatypes, " ",temp)) 
g <- g + theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
g <- g + scale_x_continuous(expand = expansion(mult = .2))
png(paste0(plots_dir, "/", analysis_file_prefix, "venn_SpatialDE_top50_", temp,".png"),width = 480, height = 480)
print(g)
d <- dev.off()

g <- ggVennDiagram(temp_list3)
g <- g + ggtitle(paste0("Top 100 Spatially Differentially Expressed \ngenes  in ",curr_datatypes, " ",temp)) 
g <- g + theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
g <- g + scale_x_continuous(expand = expansion(mult = .2))
png(paste0(plots_dir, "/", analysis_file_prefix, "venn_SpatialDE_top100_", temp,".png"),width = 480, height = 480)
print(g)
d <- dev.off()
}
}
#}
```





