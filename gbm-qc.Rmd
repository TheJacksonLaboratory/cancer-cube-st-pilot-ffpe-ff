---
title: "GBM ST QC"
output: html_notebook
---

```{r}
# pacman is a "package manager" that defines the p_load function.
# p_load automatically installs a library if it is not already installed.
# This often, but doesn't always, works.
suppressPackageStartupMessages(library(pacman)) 
suppressPackageStartupMessages(library(Seurat))
# devtools::install_github("dmcable/spacexr", build_vignettes = FALSE)
suppressPackageStartupMessages(p_load(spacexr))
suppressPackageStartupMessages(p_load(hdf5r))
suppressPackageStartupMessages(p_load(ggplot2))
suppressPackageStartupMessages(p_load(patchwork))
suppressPackageStartupMessages(p_load(dplyr))
suppressPackageStartupMessages(p_load(plyr))
suppressPackageStartupMessages(p_load(cowplot))
# suppressPackageStartupMessages(p_load(scales))
suppressPackageStartupMessages(p_load(reshape2))
suppressPackageStartupMessages(p_load(ggbeeswarm))
# suppressPackageStartupMessages(library(devtools))
# install_github("jokergoo/ComplexHeatmap")
suppressPackageStartupMessages(p_load(ComplexHeatmap))
# devtools::install_github("sjmgarnier/viridisLite")
suppressPackageStartupMessages(library(viridisLite))
suppressPackageStartupMessages(library(dendextend))
# suppressPackageStartupMessages(p_load(CCA))
# suppressPackageStartupMessages(p_load("sRDA"))
suppressPackageStartupMessages(p_load(PMA))
suppressPackageStartupMessages(p_load(ggpubr))
suppressPackageStartupMessages(p_load(rstatix))
suppressPackageStartupMessages(p_load(gtools))
suppressPackageStartupMessages(p_load(DropletUtils)) # for downsampling count matrices
suppressPackageStartupMessages(p_load(foreach))
suppressPackageStartupMessages(p_load(parallel))
suppressPackageStartupMessages(p_load(scran)) # for deconvolution-based normalization
suppressPackageStartupMessages(p_load(scuttle)) # for deconvolution-based normalization
suppressPackageStartupMessages(p_load(rjson))
##if (!require(devtools)) install.packages("devtools")
##devtools::install_github("gaospecial/ggVennDiagram")
suppressPackageStartupMessages(p_load(ggVennDiagram))
suppressPackageStartupMessages(p_load(gridExtra))
suppressPackageStartupMessages(p_load(openxlsx))
suppressPackageStartupMessages(p_load(data.table))
library("gplots")
library(RColorBrewer)
library(harmony)

# suppressPackageStartupMessages(p_load(spots))
# install.packages("devtools")
# devtools::install_github("stevexniu/spots")
library(spots)

suppressPackageStartupMessages(p_load(KRLS)) # for gausskernel
```

```{r}
source("utils.R")
source("plotting-utils.R")
```

Setup a parallel execution environment.

```{r}
num.cores <- setup.parallel.environment()
```


Configure variables that point to location of images and directories where analyses and plots will be stored.

```{r}
raw_base_dir <- "/projects/compsci/whitebr/kyuson/processed/"
base_dir <- "/projects/compsci/whitebr/kyuson/seurat/"
samples <- c("MYV-10")
names(samples) <- samples
spaceranger_dirs <- llply(samples, .fun = function(sample) paste0(raw_base_dir, sample, "/outs/"))
```


```{r}
# Define and create output results and plots directories
analysis_dir <- paste0(base_dir, '/analysis/')
dir.create(analysis_dir, showWarnings = FALSE, recursive = TRUE)
plots_dir <- paste0(base_dir, '/plots/')
dir.create(plots_dir, showWarnings = FALSE, recursive = TRUE)

# Prefix for all output files (results and plots)
analysis_file_prefix <- "gbm-"
```


```{r}
# Read in the filtered and unfiltered matrices and append the tissue positions information to the metadata:
filtered.objs <- create.visium.seurat.objects(spaceranger_dirs, filter.spots = TRUE)
unfiltered.objs <- create.visium.seurat.objects(spaceranger_dirs, filter.spots = FALSE)
```

```{r}
# Plot the number of UMI counts per spot for unfiltered data (in files *unfiltered-spot-counts.png)
titles <- samples
g.all <- plot.feature.across.samples(unfiltered.objs, titles, feature = "nCount_Spatial", legend.name = "# UMIs (K)")
g.all <- add.title.to.plot(g.all, "All Spots")
png(paste0(plots_dir, "/", analysis_file_prefix, "unfiltered-spot-counts.png"))
print(g.all)
d <- dev.off()
```

```{r}
# Plot the number of feature counts per spot for unfiltered data (in files *unfiltered-spot-features.png)
g.all <- plot.feature.across.samples(unfiltered.objs, titles, feature = "nFeature_Spatial", legend.name = "# Features (K)")
g.all <- add.title.to.plot(g.all, "All Spots")
png(paste0(plots_dir, "/", analysis_file_prefix, "unfiltered-spot-features.png"))
print(g.all)
d <- dev.off()
```

```{r}
stop("stop")
```


```{r}
expressed.genes <- 
  llply(filtered.objs,
        .fun = function(obj) {
          mat <- Seurat::GetAssayData(obj, assay="Spatial")
          rownames(mat)[rowSums(mat) > 0]
        })

num.expressed.genes <-
  llply(expressed.genes, .fun = function(lst) length(lst))

num.expressed.genes <- data.frame(sample = names(num.expressed.genes), metric = "Total.Genes.Detected", value = as.vector(unlist(num.expressed.genes)))

```



```{r}
# Read in the spaceranger summaries
summary.tbl <- 
  ldply(datasets, 
        .fun = function(dataset) {
          # json.summary.file <- paste0(spaceranger_dirs[[dataset]], "/", "summary.json")
          # json.summary <- fromJSON(file=json.summary.file)
          # json.summary
          seq.metrics.file <- paste0(spaceranger_dirs[[dataset]], "/", "metrics_summary.csv")
          tbl <- read.table(seq.metrics.file, sep=",", header=TRUE, as.is=TRUE)
          #rename.cols <- list("Reads.Mapped.Confidently.to.Probe.Set" = "Reads.Mapped.Confidently.to.Genome", "Number.of.Panel.Genes....10.UMIs" = "Total.Genes.Detected")
          rename.cols <- list("Reads.Mapped.Confidently.to.Probe.Set" = "Reads.Mapped",
                              "Reads.Mapped.Confidently.to.Genome"= "Reads.Mapped" ,"Number.of.Panel.Genes....10.UMIs" = "Total.Genes.Detected")

          for(col in names(rename.cols)) {
            flag <- colnames(tbl) == col
            colnames(tbl)[flag] <- rename.cols[[col]]
          }
          tbl
        })
colnames(summary.tbl)[1] <- "sample"

# cols <- c("Total.Genes.Detected", "Reads.Mapped.Confidently.to.Genome",  "Number.of.Reads",  "Number.of.Spots.Under.Tissue", "Fraction.of.Spots.Under.Tissue", "Median.Genes.per.Spot", "Median.UMI.Counts.per.Spot", "Fraction.Reads.in.Spots.Under.Tissue", "Sequencing.Saturation")
#cols <- c("Reads.Mapped.Confidently.to.Genome",  "Number.of.Reads",  "Number.of.Spots.Under.Tissue", "Fraction.of.Spots.Under.Tissue", "Median.Genes.per.Spot", "Median.UMI.Counts.per.Spot", "Fraction.Reads.in.Spots.Under.Tissue", "Sequencing.Saturation")
cols <- c("Number.of.Reads", "Reads.Mapped", "Number.of.Spots.Under.Tissue", "Fraction.of.Spots.Under.Tissue", "Median.Genes.per.Spot", "Median.UMI.Counts.per.Spot", "Fraction.Reads.in.Spots.Under.Tissue", "Sequencing.Saturation")
summary.tbl <- summary.tbl[, c("sample", cols)]
summary.tbl <- melt(summary.tbl, id.vars = c("sample"))
colnames(summary.tbl) <- c("sample", "metric", "value")
summary.tbl <- rbind(summary.tbl, num.expressed.genes)
summary.tbl$metric <- gsub(summary.tbl$metric, pattern="\\.", replacement=" ")
cols <- gsub(cols, pattern="\\.", replacement=" ")
summary.tbl$metric <- factor(summary.tbl$metric, levels = c("Total Genes Detected",cols))
# summary.tbl$sample <- factor(summary.tbl$sample, levels=sample.lvls)
# summary.tbl <- merge(summary.tbl, dataset.metadata.df, by.x = "sample", by.y ="sample.name")


g <- ggplot(data = subset(summary.tbl, metric == "Fraction Reads in Spots Under Tissue"), aes(x = sample, y = value, fill=type)) + geom_bar(stat="identity")
# scale_fill_manual(values= unname(unlist(color_list)))
g <- g + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
g <- g + ylab("Fraction Reads in Spots\nUnder Tissue") + xlab("")
g <- g + theme(text = element_text(size = 20))
png(paste0(plots_dir, "/", analysis_file_prefix, "frac-reads-in-spots.png"))
print(g)
d <- dev.off()

g <- ggplot(data = subset(summary.tbl, !(metric %in% c("Fraction Reads in Spots Under Tissue", "Number of Spots Under Tissue"))), aes(x = sample, y = value, fill=type)) + geom_bar(stat="identity") + facet_wrap(~ metric, scales="free", labeller = label_wrap_gen())
  # scale_fill_manual(values= unname(unlist(color_list))) + facet_wrap(~ metric, scales="free", labeller = label_wrap_gen())
g <- g + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
g <- g + ylab("")
png(paste0(plots_dir, "/", analysis_file_prefix, "summary.png"), width = 2 * 480)
print(g)
d <- dev.off()
```

```{r}
# Perform normalization of counts using SCTransform (which fits a negative binomial to the count data)
# This adds a new assay "SCT" to the returned Seurat object. That assay has slots "counts" (the corrected counts),
# "data" (log1p(counts)), and "scale.data" (the "pearson residuals").
# These would be accessible via GetAssayData(filtered.objs[[1]], slot = "data", assay = "SCT")
# Running with default parameters (the most interesting of which look to be variable.features.n and/or variable.features.rv.th)
filtered.objs <-
  llply(filtered.objs,
        .fun = function(obj) SCTransform(obj, assay = "Spatial", verbose = FALSE))
```

```{r}
filtered.objs <-
  llply(filtered.objs,
        .fun = function(obj) {
          obj <- RunPCA(obj, assay = "SCT", verbose = FALSE)
          # obj <- FindNeighbors(obj, reduction = "pca", dims = 1:30)
          # obj <- FindClusters(obj, verbose = FALSE)
          # obj <- RunUMAP(obj, reduction = "pca", dims = 1:30)
          obj
        })
```

```{r}
nms <- names(filtered.objs)
names(nms) <- nms
elbow.plots <-
  llply(nms,
        .fun = function(nm) {
          obj <- filtered.objs[[nm]]
          g <- ElbowPlot(obj, ndims = 40)
          g <- g + ggtitle(nm)
          g
        })
plot_grid(plotlist=elbow.plots)
```


```{r}
filtered.objs <-
  llply(filtered.objs,
        .fun = function(obj) {
          # obj <- RunPCA(obj, assay = "SCT", verbose = FALSE)
          obj <- FindNeighbors(obj, reduction = "pca", dims = 1:30)
          obj <- FindClusters(obj, verbose = FALSE)
          obj <- RunUMAP(obj, reduction = "pca", dims = 1:30)
          obj
        })

```

```{r}
all.markers <-
  llply(nms,
        .fun = function(nm) {
          obj <- filtered.objs[[nm]]
          cat(paste0("Finding DE for ", nm))
          # FindAllMarkers(obj, test.use="DESeq2", slot="counts")
          FindAllMarkers(obj, assay="SCT", slot="data", test.use="wilcox")
        })
```

```{r}
marker.tbl <- ldply(all.markers)
colnames(marker.tbl)[1] <- "sample"
top.markers <-
  ddply(marker.tbl, .variables = c("sample", "cluster"),
        .fun = function(df) {
          o <- order(df$p_val, decreasing = FALSE)
          df <- df[o,]
          df[1:5,]
        })
```


```{r}
suppressPackageStartupMessages(p_load(msigdbr))
suppressPackageStartupMessages(p_load(fgsea))
```

```{r}
# See https://www.biostars.org/p/339934/
# Retrieve human H (hallmark) gene set
msigdbr_df <- msigdbr(species = "Homo sapiens", category = "H")

# Retrieve human KEGG gene set
# msigdbr_df <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG")

# fixing format to work with fgsea
pathwaysH = split(x = msigdbr_df$human_gene_symbol, f = msigdbr_df$gs_name)

all.fgsea <- 
  llply(all.markers, .parallel = TRUE,
        .fun = function(marker.tbl) {
          ddply(all.markers[[1]], .variables = c("cluster"), .parallel= FALSE,
                .fun = function(df) {
                  # run fgsea enrichment
                  o <- order(df$avg_log2FC)
                  df <- df[o,]
                  ranks <- df$avg_log2FC
                  names(ranks) <- df$gene
                  fgseaRes <- suppressWarnings(fgsea(pathways=pathwaysH, ranks, maxSize = 500))
                  o <- order(fgseaRes$pval, decreasing=FALSE)
                  fgseaRes <- fgseaRes[o,]
                  fgseaRes
                })
        })
                   

```


```{r}
all.filtered.objs <- Reduce(merge, filtered.objs)
Idents(all.filtered.objs) <- all.filtered.objs$orig.ident
```
```{r}
#ATR, BRCA, MYC, NRAS, Ki-67
# See https://pubmed.ncbi.nlm.nih.gov/30146351/
bl1.markers <- list("ATR" = "ATR", "BRCA1" = "BRCA1", "BRCA2" = "BRCA2", "MYC" = "MYC", "NRAS" = "NRAS", "MKI67" = "Ki-67")
bl2.markers <- list("EGFR" = "EGFR", "MET" = "MET", "EPHA2" = "EPHA2", "TP53" = "TP53")
im.markers <- list("JAK1" = "JAK1", "JAK2" = "JAK2", "STAT1" = "STAT1", "STAT4" = "STAT4", "IRF1" = "IRF1", "IRF7" = "IRF7", "IRF8" = "IRF8", "TNF" = "TNF")
m.markers <- list(Wnt, ALK, TGF-β)
msl.markers <- list(EGFR, PDGFR, ERK1/2, VEGFR2)
lar.markers <- list(AR, FOXA1, KRT18, XBP1)
```


```{r}
# SpatialFeaturePlot(all.filtered.objs, features = c("NRAS"), combine = FALSE)
# SpatialFeaturePlot(filtered.objs[[1]], features = names(im.markers), combine = TRUE)
## Genes upregulated in TNBC
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6513966/

# TNBC subtypes
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3127435/
# TNBC tumor subtypes display differential expression of both basal-like cytokeratins (KRT5, KRT6A, KRT6B, KRT14, KRT16, KRT17, KRT23, and KRT81) and luminal cytokeratins (KRT7, KRT8, KRT18, and KRT19)
DefaultAssay(all.filtered.objs) <- "SCT"

# TNBC subyptes
# https://www.sciencedirect.com/science/article/pii/S0305737218300999

tnbc.markers <- c("AZGP1", "KRT19", "RPS11", "SFRP1", "EPCAM", "TACSTD2", "MGP", "SFN", "GATA3", "S100A8", "CHI3L1", "KRT15", "KRT14", "NPY1R", "ASPN", "PEG3", "SCGB2A2")
gene <- "PTPRC"
gene <- "CD79A"
gene <- "PDGFRA"
gene <- "CD68"
gene <- tnbc.markers[indx]

# apply(GetAssayData(all.filtered.objs, slot = "counts")[tnbc.markers,],1,max)
diff.tnbc.markers <- c("KRT19", "KRT15", "MGP")

plot.gene.overlays <- function(obj, gene) {
  mx <- max(GetAssayData(obj, slot = "counts")[gene,])
  plts <- SpatialFeaturePlot(obj, features = c(gene), combine = FALSE, slot = "counts")
  plts <- 
    llply(plts,
          .fun = function(g) {
            i <- which(sapply(g$scales$scales, function(x) 'fill' %in% x$aesthetics))
            g$scales$scales[[i]] <- NULL
            g <- g + scale_fill_gradientn(name = gene, colours = Seurat:::SpatialColors(n = 100), limits=c(0,mx))
            g
          })
  # plot_grid(plotlist = plts)
  g <- plot_grid(plotlist = plts)
  g
}

# DefaultAssay(all.filtered.objs) <- "Spatial"
#plts <- SpatialFeaturePlot(all.filtered.objs, features = c(gene), combine = FALSE, slot = "counts") 
#plot_grid(plotlist = plts)
g1 <- plot.gene.overlays(all.filtered.objs, "EPCAM")
#g1 <- add.title.to.plot(g1, "Basal TNBC")
g2 <- plot.gene.overlays(all.filtered.objs, "KRT19")
#g2 <- add.title.to.plot(g2, "Luminal TNBC")
g.tot <- plot_grid(g1,g2)
png(paste0(plots_dir,"tnbc-markers.png"), width = 2*480, height = 480)
print(g.tot)
d <- dev.off()

cell.markers <- list("CD8 T cells" = c("CD3E", "CD8A"), "macrophages" = c("CD68", "CD80"), "B cells" = c("CD79A", "MS4A1"), "fibroblasts" = c("PDGFRA", "FAP"))
plot.pair <- function(obj, genes) {
  gene1 <- genes[1]
  gene2 <- genes[2]
  g1 <- plot.gene.overlays(obj, gene1)
  g2 <- plot.gene.overlays(obj, gene2)
  g.tot <- plot_grid(g1,g2)
  g.tot
}

for(cell.type in names(cell.markers)) {
#cell.type <- "CD8 T cell"
g <- plot.pair(all.filtered.objs, cell.markers[[cell.type]])
g <- add.title.to.plot(g, cell.type)
png(paste0(plots_dir,"tnbc-", make.names(cell.type), "-markers.png"), width = 2*480, height = 480)
print(g)
d <- dev.off()
}

```


```{r}
stop("stop")
```


```{r}
# Also apply scran deconvolution-based normalization.
# scran uses SingleCellExperiment objects, so we will have to convert back and forth between SCEs and Seurat objects.
# See notes on interoperability here: https://satijalab.org/seurat/archive/v3.1/conversion_vignette.html

filtered.objs <-
  llply(filtered.objs, .parallel = FALSE,
        .fun = function(obj) {
          
          # Convert from a Seurat object to a SingleCellExperiment
          sce <- as.SingleCellExperiment(obj, assay = "Spatial")

          
          # Perform the scran normalization (see https://bioconductor.org/packages/devel/bioc/vignettes/scran/inst/doc/scran.html)
          clusters <- quickCluster(sce)
          sce <- computeSumFactors(sce, clusters=clusters)
          sce <- logNormCounts(sce)
          
          # Convert back from SingleCellExperiment to Seurat object. 
          tmp <- as.Seurat(sce, counts = "counts", data = "logcounts", assay="scran")
          obj[["scran"]] <- tmp[["scran"]]
          obj <- FindVariableFeatures(obj, assay="scran")
          obj
        })
          
```


```{r}
# Merge the unfiltered objs into one Seurat object
all.unfiltered.objs <- Reduce(merge, unfiltered.objs)
Idents(all.unfiltered.objs) <- all.unfiltered.objs$orig.ident
```


```{r}
all.filtered.objs <- Reduce(merge, filtered.objs)
Idents(all.filtered.objs) <- all.filtered.objs$orig.ident
```


```{r}
obj.sct <- all.filtered.objs
DefaultAssay(obj.sct) <- "SCT"
VariableFeatures(obj.sct, assay="SCT") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="SCT")))))
obj.sct <- RunPCA(obj.sct, verbose = FALSE)
ElbowPlot(obj.sct, ndims = 40)
mat <- Seurat::GetAssayData(obj.sct, assay = "SCT")
pca <- obj.sct[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(as.matrix(mat)))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance
cumVarExplained <- cumsum(varExplained)

obj.sct <- RunHarmony(obj.sct, group.by.vars = make.names("orig ident"))

# Pick the number of dimensions based on a flattening of the elbow plot
obj.sct <- FindNeighbors(obj.sct,reduction = "harmony", dims = 1:20)
obj.sct <- FindClusters(obj.sct, reduction = "harmony",verbose = FALSE)
obj.sct <- RunUMAP(obj.sct, reduction = "harmony",dims = 1:20)
png(paste0(plots_dir,"clusters-merged-UMAP-sct.png"),width=1400,height =600)
obj.sct$Sample=obj.sct$orig.ident
obj.sct$Cluster=obj.sct@active.ident
gg <- DimPlot(obj.sct, reduction = "umap", group.by = c("Cluster","Sample")) 
print(gg)
d <- dev.off()

per_id_per_cluster_tbl<-table(obj.sct@meta.data$seurat_clusters, obj.sct@meta.data$orig.ident)

foo <- (melt(per_id_per_cluster_tbl))
colnames(foo) <- c("cluster", "sample", "cnt")

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

for(target_sample in biological.replicates) {
  bar <- subset(foo, grepl(sample, pattern=target_sample))
  bar <- subset(bar, cnt != 0)
  bar <- melt(acast(bar, cluster ~ sample, fill = 0))
  colnames(bar) <- c("cluster", "sample", "cnt")
  bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
  bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
  png(paste0(plots_dir,target_sample,"-cluster-proportions-sct.png"))
  g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
  g <- g + ylab("Fraction") + xlab("Cluster")
  g <- g + theme(text = element_text(size = 20))
  print(g)
  d <- dev.off()
}

bar <- subset(foo, cnt != 0)
bar <- melt(acast(bar, cluster ~ sample, fill = 0))
colnames(bar) <- c("cluster", "sample", "cnt")
bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
png(paste0(plots_dir,"all-cluster-proportions-sct.png"))
g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
g <- g + ylab("Fraction") + xlab("Cluster")
g <- g + theme(text = element_text(size = 20))
print(g)
d <- dev.off()

png(paste0(plots_dir,"all-cluster-proportions-heatmap-sct.png"),width=980, height=980)

color_list<-list('FFPE'="#d8b365" , 'Frozen'='#5ab4ac')
colSide <- as.vector(unlist(color_list[unlist(dataset.labels[levels(bar$sample)])]))

heatmap.2(acast(bar[, c("cluster","sample","frac")], cluster ~ sample),row_title="Cluster",column_title="Sample",heatmap_legend_param=list(title="Proportion"), ColSideColors = colSide ,col =rev( colorRampPalette(brewer.pal(8, "RdBu"))(25)),xlab="Cluster", ylab="Sample",margins=c(12,8),trace="none",lhei=c(1, 6),keysize=1,key.title="Proportion")
d <- dev.off()
```

```{r}

ffpe.genes <- unique(Reduce(c,expressed.genes[ffpe.datasets]))
frozen.genes <- unique(Reduce(c,expressed.genes[frozen.datasets]))

x <- list(FFPE = ffpe.genes, frozen = frozen.genes)
g <- ggVennDiagram(x, label_size = 10, set_size = 10)
g <- g + theme(legend.position = "none") 
png(paste0(plots_dir,"ffpe-frozen-venn.png"))
print(g)
d <- dev.off()

# Get the genes that are only highly expressed in fresh frozen samples
# and output their "biotype" -- i.e., whether are coding genes, etc.
frozen.only <- frozen.genes[!(frozen.genes %in% ffpe.genes)]

library(biomaRt)
if (species_sample[1]=='Human'){
    gene_db = useMart("ensembl",dataset="hsapiens_gene_ensembl")
} else {
  gene_db = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
}

gb <- getBM(attributes=c("external_gene_name", "gene_biotype"),filters = c("external_gene_name"), values=frozen.only, mart=gene_db)

frozen.only.biotypes <- as.data.frame(table(gb$gene_biotype))
colnames(frozen.only.biotypes) <- c("biotype", "Freq")
o <- order(frozen.only.biotypes$Freq, decreasing=TRUE)
frozen.only.biotypes <- frozen.only.biotypes[o,]

png(paste0(plots_dir,"frozen-biotypes.png"))
grid.table(frozen.only.biotypes,rows=NULL)
d <- dev.off()

ffpe.only <- ffpe.genes[!(ffpe.genes %in% frozen.genes)]

gb <- getBM(attributes=c("external_gene_name", "gene_biotype"),filters = c("external_gene_name"), values=ffpe.only, mart=gene_db)

ffpe.only.biotypes <- as.data.frame(table(gb$gene_biotype))
colnames(ffpe.only.biotypes) <- c("biotype", "Freq")
o <- order(ffpe.only.biotypes$Freq, decreasing=TRUE)
ffpe.only.biotypes <- ffpe.only.biotypes[o,]

png(paste0(plots_dir,"ffpe-biotypes.png"))
grid.table(ffpe.only.biotypes,rows=NULL)
d <- dev.off()
```


```{r}
obj.scran <- all.filtered.objs
DefaultAssay(obj.scran) <- "scran"
obj.scran <- ScaleData(obj.scran, assay="scran")
VariableFeatures(obj.scran, assay="scran") <- unique(unname(unlist(lapply(filtered.objs, function(x) VariableFeatures(x, assay="scran")))))
obj.scran <- RunPCA(obj.scran, verbose = FALSE)
ElbowPlot(obj.scran, ndims = 40)
mat <- Seurat::GetAssayData(obj.scran, assay = "scran")
pca <- obj.scran[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(as.matrix(mat)))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = eigValues / total_variance
cumVarExplained <- cumsum(varExplained)

obj.scran <- RunHarmony(obj.scran, group.by.vars = make.names("orig ident"))

obj.scran <- FindNeighbors(obj.scran,reduction = "harmony", dims = 1:20)
obj.scran <- FindClusters(obj.scran, reduction = "harmony", verbose = FALSE)
obj.scran <- RunUMAP(obj.scran, reduction = "harmony", dims = 1:20)
png(paste0(plots_dir,"clusters-merged-UMAP-scran.png"),width=1400,height =600)
obj.scran$Sample=obj.scran$orig.ident
obj.scran$Cluster=obj.scran@active.ident
gg <- DimPlot(obj.scran, reduction = "umap", group.by = c("Cluster","Sample")) 
print(gg)
d <- dev.off()

per_id_per_cluster_tbl<-table(obj.scran@meta.data$seurat_clusters, obj.scran@meta.data$orig.ident)

foo <- (melt(per_id_per_cluster_tbl))
colnames(foo) <- c("cluster", "sample", "cnt")

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

for(target_sample in biological.replicates) {
  bar <- subset(foo, grepl(sample, pattern=target_sample))
  bar <- subset(bar, cnt != 0)
  bar <- melt(acast(bar, cluster ~ sample, fill = 0))
  colnames(bar) <- c("cluster", "sample", "cnt")
  bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
  bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
  png(paste0(plots_dir,target_sample,"-cluster-proportions-scran.png"))
  g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
  g <- g + ylab("Fraction") + xlab("Cluster")
  g <- g + theme(text = element_text(size = 20))
  print(g)
  d <- dev.off()
}

bar <- subset(foo, cnt != 0)
bar <- melt(acast(bar, cluster ~ sample, fill = 0))
colnames(bar) <- c("cluster", "sample", "cnt")
bar <- ddply(bar, .variables = c("cluster"), .fun = function(df) {df$frac <- df$cnt / sum(df$cnt); return(df)})
bar$cluster <- factor(as.character(bar$cluster), levels = unique(sort(bar$cluster)))
png(paste0(plots_dir,"all-cluster-proportions-scran.png"))
g <- ggplot() + geom_col(data = bar, aes(x=cluster,y=frac,fill=sample)) + scale_fill_manual(values=cbbPalette)
g <- g + ylab("Fraction") + xlab("Cluster")
g <- g + theme(text = element_text(size = 20))
print(g)
d <- dev.off()

color_list<-list('FFPE'="#d8b365" , 'Frozen'='#5ab4ac')
colSide <- as.vector(unlist(color_list[unlist(dataset.labels[levels(bar$sample)])]))
par(cex.main=80)
png(paste0(plots_dir,"all-cluster-proportions-heatmap-scran.png"),width=680, height=980)
heatmap.2(acast(bar[, c("cluster","sample","frac")], cluster ~ sample),row_title="Cluster",column_title="Sample",heatmap_legend_param=list(title="Proportion"), ColSideColors = colSide ,col =rev( colorRampPalette(brewer.pal(8, "RdBu"))(25)),ylab="Cluster", xlab="Sample",margins=c(13,6),trace="none",lhei=c(1,8),keysize=2,key.title="Proportion",cexRow = 2.5,cexCol = 2.5) 
#title('ddddddd', cex.main = 15 * op[["cex.main"]])
 ## this will affect also legend title font size

#g<- g + title(main, cex.main = 1.5 * op[["cex.main"]])
d <- dev.off()

```



```{r}
# Add simplified sample names
sample.name.df <- data.frame(all.unfiltered.objs@meta.data[, c("orig.ident"), drop = FALSE])
sample.name.df$sample.name <- unlist(lapply(sample.name.df$orig.ident, function(str) unlist(strsplit(str, split="_"))[1]))
all.unfiltered.objs <- AddMetaData(all.unfiltered.objs, sample.name.df[, c("sample.name"), drop = FALSE])
```


```{r}

```


```{r}
# Plot the number of UMI counts per spot for unfiltered data (in files *unfiltered-spot-counts.png.png)
unfiltered.count.plots <-
  llply(datasets,
        .fun = function(dataset) {
          g <- plot.spatial(unfiltered.objs[[dataset]], features = c("nCount_Spatial"), legend.name = "UMI Count (k)")
          g <- g + theme(legend.text=element_text(size=15))
          g
        })
```

```{r}
# Plot the number of feature counts per spot for unfiltered data (in files *unfiltered-spot-features.png)
unfiltered.feature.plots <-
  llply(datasets,
        .fun = function(dataset) {
          g <- plot.spatial(unfiltered.objs[[dataset]], features = c("nFeature_Spatial"), legend.name = "Gene Count (k)")
          g <- g + theme(legend.text=element_text(size=15))
          g
        })
```

```{r}
# Plot the raw H&E images (in files *hne.png)
hne.plots <-
  llply(datasets,
        .fun = function(dataset) {
          g <- plot.hne(unfiltered.objs[[dataset]], keep.invisible.legend = TRUE)
          g
        })
```

```{r}
# Make plots of H&E and UMI and feature count overlays
for(pt in names(samples.by.patient)) {
  plts <- llply(samples.by.patient[[pt]],
                .fun = function(sample) {
                  g <- plot_grid(hne.plots[[sample]], unfiltered.count.plots[[sample]], unfiltered.feature.plots[[sample]], byrow=FALSE, ncol=3)
                  g <- add.title.to.plot(g, sample, size = 20)
                  g
                })
  g <- plot_grid(plotlist = plts, ncol=1)
  png(paste0(plots_dir, "/", analysis_file_prefix, pt, "-hne-umis-and-features.png"), width = 3 * 480, height = 2 * 480)
  print(g)
  d <- dev.off()
}
```


```{r}
#' Plot distribution of a response variable (e.g., UMI count) across spots relative to a dependent variable (e.g., tissue vs background spot status)
#' 
#' Create violin/boxplots showing distribution across spots of a user-specified response variable relative to a dependent variable and facted by sample.
#'
#' @param df A data.frame holding the response, depenndent, and faceting variables.
#' @param response.var The variable whose distribution over spots will be plotted.
#' @param facet.var The faceting variable.
#' @param dependent.var The variable that the response variable will be plotted as a function of.
#' @return A ggplot
plot.distributions.vs.cell.type <- function(df, response.var = "nCount_Spatial", facet.var = "sample.name", dependent.var = "spot_type") {
  lvls <- unique(df[, facet.var, drop=TRUE])
  df[,facet.var] <- factor(df[,facet.var], levels=lvls)
  stat.test <- df %>% group_by_at(facet.var) %>% wilcox_test(as.formula(paste0(response.var, " ~ ", dependent.var)), p.adjust.method = "none")
  stat.test$p.adj <- p.adjust(stat.test$p, method = "bonferroni")
  stat.test <- stat.test %>% add_xy_position(x = dependent.var)
  stat.test$y.position <- log2(stat.test$y.position)
  stat.test$label <- stars.pval(stat.test$p.adj)
  g <- ggviolin(df, dependent.var, response.var, facet.by = facet.var, add = "boxplot")
  g <- g + yscale("log2") + stat_pvalue_manual(stat.test, label="label") + xlab("Spot Type")
  g
}
```


```{r}
# Plot the distribution of UMI counts and gene counts over spots, as a function of whether those spots and within the tissue or outside of it (in file *count-and-feature-dist.png)
tbl <- all.unfiltered.objs@meta.data
tbl <- merge(tbl, dataset.metadata.df)
# tbl <- tbl[order(tbl$sample.name, tbl$type, tbl$sample.name, decreasing=TRUE),]
tbl$sample <- factor(tbl$sample, levels = sample.lvls)
tbl$sample.label <- paste0(tbl$sample.name, "\n", tbl$type)
g.cnt <- plot.distributions.vs.cell.type(tbl, response.var = "nCount_Spatial", facet.var = "sample.label") + ylab("UMI Counts (log2)")
g.feature <- plot.distributions.vs.cell.type(tbl, response.var = "nFeature_Spatial", facet.var = "sample.label") + ylab("Feature Counts (log2)")
g <- plot_grid(g.cnt, g.feature, nrow=1, labels = "AUTO")
png(paste0(plots_dir, "/", analysis_file_prefix, "count-and-feature-dist.png"), width = 2 * 480)
print(g)
d <- dev.off()

```
```{r}
#' Return count matrix from a Seurat object
#' 
#' @param obj A Seurat object.
#' @return A (sparse) matrix holding the spot counts (i.e., from the "counts" slot)
get.count.matrix <- function(obj) {
  as.matrix(x = GetAssayData(object = obj, assay = "Spatial", slot = "counts"))
}

#' Downsample each column of a matrix to a desired total count.
#'
#' A function that, independently for each column/cell, uses a multinomial distribution, parameterized 
#' by the frequency of each gene within that column/cell and the desired total count, to sample a vector of gene counts.
#' This is in contrast to related functions such as SampleUMI (in Seurat), which applies a binomial to each gene (!?)
#' and thus only approximates the desired total count, and downsampleMatrix (in DropletUtils), which downsamples to
#' a fraction of the original number of reads.
#'
#' @param expr_mat A (possibly sparse) matrix of counts.
#' @param tot_cnt The desired number of counts _for each column_
#' @return A downsample matrix
downsample.matrix <- function (expr_mat, tot_cnt) 
{
    down_sample <- function(x) {
        prob <- x/sum(x)
        return(rmultinom(1, tot_cnt, prob))
    }
    down_sampled_mat <- apply(expr_mat, 2, down_sample)
    return(down_sampled_mat)
}

#' Compute the number of expressed genes/features in a downsampled matrix.
#' 
#' A function to downsample the input matrix such that each cell/column has tot_cnt reads and
#' that reports the _median_ (across cells/columns) number of genes/features with non-zero counts.
#'
#' @param expr_mat A (possibly sparse) matrix of counts.
#' @param tot_cnt The desired number of counts _for each column_
#' @return The median (across cells/columns) number of genes/features with non-zero counts in the downsampled matrix.
compute.num.features.at.total.reads <- function(expr_mat, tot_cnt) {
  ds <- downsample.matrix(expr_mat, tot_cnt)
  return(median(colSums(ds > 0)))
}
```

```{r}
# Calculate the median number of reads (across spots) for each sample
# NB: using filtered data here
median.num.reads <- llply(filtered.objs, .fun = function(obj) median(colSums(get.count.matrix(obj))))
```

```{r}
# Perform a sensitivity analysis -- i.e., show the number of detected genes/features as a function
# of total UMI counts per spot. More precisely, we will plot the median (across spots) number of
# detected genes vs the median (across spots) UMI count.

all.downsample.cnts <- round(seq(from=0.1,to=0.9,by=0.1)*max(unlist(median.num.reads)))
names(all.downsample.cnts) <- all.downsample.cnts
downsample.feature.df <-
  ldply(filtered.objs,
        .parallel = FALSE,
        .fun = function(obj) {
          expr_mat <- get.count.matrix(obj)
          median.cnts <- median(colSums(expr_mat))
          downsample.cnts <- all.downsample.cnts[all.downsample.cnts < median.cnts]
          tbl <- 
            ldply(downsample.cnts, .parallel = TRUE,
                  .fun = function(tot_cnt) {
                    data.frame(num.features = compute.num.features.at.total.reads(expr_mat, tot_cnt))
                  })
          colnames(tbl)[1] <- "downsample.count"
          tbl
        })
colnames(downsample.feature.df)[1] <- "sample.name" 
downsample.feature.df$downsample.count <- as.numeric(downsample.feature.df$downsample.count)
downsample.feature.df <- merge(downsample.feature.df, dataset.metadata.df)
```

```{r}
# Plot the sensitivity (# of detected genes/features vs # of reads; in file *num-features-vs-num-downsampled-reads.png)
g <- ggplot(downsample.feature.df, aes(x = downsample.count, y = num.features, colour = sample.name, shape = type))
g <- g + geom_point()
g <- g + xlab("Spot Read Count (Median)") + ylab("Spot Feature Count (Median)")
g <- g + theme(text = element_text(size = 20))
png(paste0(plots_dir, "/", analysis_file_prefix, "num-features-vs-num-downsampled-reads.png"))
print(g)
d <- dev.off()
            
```


```{r}
#' Return most highly-expressed genes
#' 
#' A function to return the most highly-expressed genes (i.e., those with highest value) from a matrix.
#'
#' @param mat A (sparse) matrix.
#' @param n.top The number of genes to return.
#' @param assay The assay from which to access the gene exprssion/values in the Seurat object.
#' @param slot The slot in the assay form which to access the gene expression/values.
#' @return A vector of the highest-expressed genes.
get.top.genes.matrix <- function(mat, n.top = 20, assay = "Spatial", slot = "data") {
  rs <- rowSums(mat)
  rs <- rs[order(rs, decreasing=TRUE)]
  top.genes <- names(rs)[1:n.top]
  top.genes
}

#' Return most highly-expressed genes
#' 
#' A function to return the most highly-expressed genes (i.e., those with highest value) from a Seurat assay.
#'
#' @param obj A Seurat object.
#' @param n.top The number of genes to return.
#' @param assay The assay from which to access the gene exprssion/values in the Seurat object.
#' @param slot The slot in the assay form which to access the gene expression/values.
#' @return A vector of the highest-expressed genes.
get.top.genes <- function(obj, n.top = 20, assay = "Spatial", slot = "data") {
  mat <- GetAssayData(obj, assay = assay, slot = slot)
  get.top.genes.matrix(mat, n.top = n.top, assay = assay, slot = slot)
}

#' Return data subsetted by spot tissue status
#' 
#' A function to return the subset of the data corresponding to spots that are (or are not) in the tissue
#'
#' @param obj A Seurat object.
#' @param tissue.val Spots with tissue.val for the tissue.col metadata field will be retained.
#' @param tissue.col The metadata column of the Seurat object holding the tissue status
#' @param assay The assay from which to access the gene exprssion/values in the Seurat object.
#' @param slot The slot in the assay form which to access the gene expression/values.
#' @return A (sparse) matrix of spots that are (or are not) in tissue
subset.matrix.based.on.tissue.status <- function(obj, tissue.val, tissue.col = "tissue", assay = "Spatial", slot = "data") {
  cell.subset <- rownames((obj@meta.data)[(obj@meta.data)[,tissue.col] == tissue.val,])
  mat <- GetAssayData(obj, assay = assay, slot = slot)
  mat[,cell.subset]
}
```

```{r}
plot.top.genes <- function(mat, n.top = 20, highlight.genes = NULL) {
  mat <- sweep(mat, 2, colSums(mat), "/")
  top.genes <- get.top.genes.matrix(mat, n.top = n.top)
  df <- melt(mat[top.genes,])
  colnames(df) <- c("gene", "spot", "value")
  df$gene <- factor(df$gene, levels = rev(top.genes))
  g <- ggplot() + geom_boxplot(data = df, aes(x = gene, y = 100 * value), fill = (scales::hue_pal())(n.top)[n.top:1]) + coord_flip()
  g <- g + ylab("% total count per cell") + xlab("")
  g <- g + theme(text = element_text(size=20), plot.title = element_text(hjust = 0.5))
  if(!is.null(highlight.genes)) {
    vec_fontface <- ifelse(levels(df$gene) %in% highlight.genes,"bold","plain")
    g <- g + theme(axis.text.y=element_text(face=vec_fontface))
  }
  g
}
```


```{r}
# Get the most prevalent genes expressed in the background ...
top.genes.background <-
  llply(datasets,
        .fun = function(data.set) {
          obj <- unfiltered.objs[[data.set]]
          mat <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 0, assay = "Spatial", slot = "counts"))
          mat <- sweep(mat, 2, colSums(mat), "/")
          top.genes <- get.top.genes.matrix(mat, n.top = 20)
          top.genes
        })

# ... and in the tissue
top.genes.tissue <-
  llply(datasets,
        .fun = function(data.set) {
          obj <- unfiltered.objs[[data.set]]
          mat <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          mat <- sweep(mat, 2, colSums(mat), "/")
          top.genes <- get.top.genes.matrix(mat, n.top = 20)
          top.genes
        })

```

```{r}
# Find genes that are common between the (union of) background genes and the (union of) tissue genes
all.background.genes <- unique(Reduce("c", top.genes.background))
all.tissue.genes <- unique(Reduce("c", top.genes.tissue))
common.genes <- intersect(all.background.genes, all.tissue.genes)

intersect.background.genes <- unique(Reduce("intersect", top.genes.background))
intersect.tissue.genes <- unique(Reduce("intersect", top.genes.tissue))


flag <- dataset.labels == "FFPE"
ffpe.background.genes <- unique(Reduce("c", top.genes.background[flag]))
ffpe.tissue.genes <- unique(Reduce("c", top.genes.tissue[flag]))
common.ffpe.genes <- intersect(ffpe.background.genes, ffpe.tissue.genes)
intersect.tissue.ffpe.genes <- unique(Reduce("intersect", top.genes.tissue[flag]))

```


```{r}
```


```{r}
# Create plots showing the top 20 most prevalent genes in the background -- highlighting (in bold) the
# genes that are common to the background and tissue
top.genes.background.plts <-
  llply(datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          background.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 0, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(background.sub.matrix, n.top = 20, highlight.genes = intersect.background.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.background.plts)
g.all <- add.title.to.plot(g.all, "Background Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-background-spot.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

# Do the same for spots in the tissue
top.genes.tissue.plts <-
  llply(datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          tissue.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(tissue.sub.matrix, n.top = 20, highlight.genes = intersect.tissue.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.tissue.plts)
g.all <- add.title.to.plot(g.all, "Tissue Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-tissue-spot.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

# Repeat both of the above, but only for FFPE
# Create plots showing the top 20 most prevalent genes in the background -- highlighting (in bold) the
# genes that are common to the background and tissue
top.genes.background.ffpe.plts <-
  llply(ffpe.datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          background.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 0, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(background.sub.matrix, n.top = 20, highlight.genes = common.ffpe.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.background.ffpe.plts)
g.all <- add.title.to.plot(g.all, "Background Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-background-spot-ffpe-only.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

# Do the same for spots in the tissue
top.genes.tissue.ffpe.plts <-
  llply(ffpe.datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          tissue.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(tissue.sub.matrix, n.top = 20, highlight.genes = common.ffpe.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.tissue.ffpe.plts)
g.all <- add.title.to.plot(g.all, "Tissue Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-tissue-spot-ffpe-only.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()

top.genes.intersect.tissue.ffpe.plts <-
  llply(ffpe.datasets,
        .fun = function(dataset) {
          obj <- unfiltered.objs[[dataset]]
          tissue.sub.matrix <- as.matrix(subset.matrix.based.on.tissue.status(obj, tissue.val = 1, assay = "Spatial", slot = "counts"))
          g <- plot.top.genes(tissue.sub.matrix, n.top = 20, highlight.genes = intersect.tissue.ffpe.genes)
          title <- paste0(dataset, "\n" , dataset.labels[[dataset]])
          g <- g + ggtitle(title)
          g
        })
g.all <- plot_grid(plotlist=top.genes.intersect.tissue.ffpe.plts)
g.all <- add.title.to.plot(g.all, "Tissue Spots", size = 25)
png(paste0(plots_dir, "/", analysis_file_prefix, "most-prevalent-genes-tissue-spot-intersect-ffpe-only.png"), width = 2 * 480, height = 2 * 480)
print(g.all)
d <- dev.off()



```


```{r}
mylist_qval<-list()
mylist_top50_LLR<-list()
mylist_top100_LLR<-list()
for (i in names(long.dataset.names)){
  r<-read.csv(file = paste0(base_dir, "/automatic_analysis/results/",i,"/stSpatialDE.csv"), header = TRUE, as.is = TRUE, row.names = 1)
  r  <-r[r$qval==0,]
  mm <-sort(r$LLR,decreasing= TRUE,index.return = TRUE)
  
  mylist_qval[[ i ]]<-r$g.1
  mylist_top50_LLR[[ i ]]<-r$g.1[mm$ix[1:50]]
  mylist_top100_LLR[[ i ]]<-r$g.1[mm$ix[1:100]]
}
dictionary_terms<-c(unlist(unique(dataset.labels)),unlist(biological.replicates),"")
for (temp in dictionary_terms){
temp_list1 <- list()
temp_list2 <- list()
temp_list3 <- list()

#temp<-dictionary_terms[1]
if ((temp==dictionary_terms[1]|temp==dictionary_terms[2])&(length(mylist_qval[dataset.labels==temp])<=4 & length(mylist_qval[dataset.labels==temp])>=2)){
  temp_list1<-mylist_qval[dataset.labels==temp]
  temp_list2<-mylist_top50_LLR[dataset.labels==temp]
  temp_list3<-mylist_top100_LLR[dataset.labels==temp]
}else if((temp==dictionary_terms[3] | temp==dictionary_terms[4]) & (length(mylist_qval[dataset.labels==temp]) <=4 & length(mylist_qval[dataset.labels==temp])>=2)) {
  temp_list1<-mylist_qval[grepl(datasets, pattern=temp)]
  temp_list2<-mylist_top50_LLR[grepl(datasets, pattern=temp)]
  temp_list3<-mylist_top100_LLR[grepl(datasets, pattern=temp)]
}else if (temp=="" & ( length(mylist_qval)<=4 & length(mylist_qval)>2)){
  temp_list1<-mylist_qval
  temp_list2<-mylist_top50_LLR
  temp_list3<-mylist_top100_LLR
}
if (length(temp_list1)!=0){
  print(temp)
g <- ggVennDiagram(temp_list1)
g <- g + ggtitle(paste0("Spatially Differentially Expressed genes\n with 0 p-value in ",curr_datatypes, " ",temp)) 
g <- g + theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
g <- g + scale_x_continuous(expand = expansion(mult = .2))
png(paste0(plots_dir, "/", analysis_file_prefix, "venn_SpatialDE_pval_", temp,".png"),width = 480, height = 480)
print(g)
d <- dev.off()

g <- ggVennDiagram(temp_list2)
g <- g + ggtitle(paste0("Top 50 Spatially Differentially Expressed \ngenes  in ",curr_datatypes, " ",temp)) 
g <- g + theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
g <- g + scale_x_continuous(expand = expansion(mult = .2))
png(paste0(plots_dir, "/", analysis_file_prefix, "venn_SpatialDE_top50_", temp,".png"),width = 480, height = 480)
print(g)
d <- dev.off()

g <- ggVennDiagram(temp_list3)
g <- g + ggtitle(paste0("Top 100 Spatially Differentially Expressed \ngenes  in ",curr_datatypes, " ",temp)) 
g <- g + theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
g <- g + scale_x_continuous(expand = expansion(mult = .2))
png(paste0(plots_dir, "/", analysis_file_prefix, "venn_SpatialDE_top100_", temp,".png"),width = 480, height = 480)
print(g)
d <- dev.off()
}
}
#}
```





